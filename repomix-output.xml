This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.env.example
.repomixignore
components.json
docker-compose.yml
Dockerfile
eslint.config.js
index.html
package.json
public/assets/Caminhao_medio.json
public/assets/caminhao_pequeno.json
public/assets/caminhonete.json
public/assets/carreta.json
src/api/authService.ts
src/api/config.ts
src/api/gameService.ts
src/api/teamService.ts
src/App.css
src/App.tsx
src/components/AudioControl.tsx
src/components/AudioManager.tsx
src/components/ButtonHomeBack.tsx
src/components/Cloud.tsx
src/components/CreateTeamButton.tsx
src/components/PixelProgressBar/PixelProgressBar.css
src/components/PixelProgressBar/PixelProgressBar.tsx
src/components/ProtectedRoute.tsx
src/components/SelectTeamButton.tsx
src/components/TeamCard.tsx
src/components/ui/button.tsx
src/components/ui/card.tsx
src/components/ui/carousel.tsx
src/components/ui/dialog.tsx
src/components/ui/input.tsx
src/components/ui/separator.tsx
src/constants/teams.ts
src/contexts/AudioContext.tsx
src/contexts/AuthContext.tsx
src/hooks/useRanking.ts
src/index.css
src/lib/utils.ts
src/main.tsx
src/pages/auth/Cadastro/Cadastro.tsx
src/pages/auth/ForgotPassword/ForgotPassword.tsx
src/pages/auth/Login/Login.tsx
src/pages/ChooseTeam/ChooseTeam.tsx
src/pages/Desafio/ApresentacaoDesafio.tsx
src/pages/escolherVeiculo/index.ts
src/pages/escolherVeiculo/VehicleSelectionPage.tsx
src/pages/fuel/FuelPage.tsx
src/pages/Game-truck/game.css
src/pages/Game-truck/game.tsx
src/pages/Game-truck/GameMiniMap.tsx
src/pages/Game-truck/kaboom.ts
src/pages/GameSelection/components/Footer.tsx
src/pages/GameSelection/components/GameCard.tsx
src/pages/GameSelection/components/PixelHeading.tsx
src/pages/GameSelection/GameSelectionPage.tsx
src/pages/Home/HomePage.tsx
src/pages/Home/index.ts
src/pages/mapaRota/ChallengeSelector.tsx
src/pages/mapaRota/challengesManager.ts
src/pages/mapaRota/constants.ts
src/pages/mapaRota/FuelModal.tsx
src/pages/mapaRota/MapComponent.tsx
src/pages/mapaRota/routesData.ts
src/pages/PauseMenu/PauseMenu.tsx
src/pages/Perfil/ChangePassword.tsx
src/pages/Perfil/CriarEquipe.tsx
src/pages/Perfil/EditarEquipe.tsx
src/pages/Perfil/EditarPerfil.tsx
src/pages/Perfil/EntrarEquipe.tsx
src/pages/Perfil/ExcluirEquipe.tsx
src/pages/Perfil/PerfilPage.tsx
src/pages/Ranking/RankingPage.tsx
src/pages/RoutesPage/RoutesPage.tsx
src/pages/Tutorial/TutorialPage.tsx
src/services/challengeService.ts
src/styles/pixelArt.css
src/types/index.ts
src/types/ranking.ts
src/types/vehicle.ts
src/utils/mapUtils.ts
tsconfig.app.json
tsconfig.json
tsconfig.node.json
tsconfig.tsbuildinfo
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".env.example">
VITE_API_URL=http://localhost:8000
</file>

<file path=".repomixignore">
# Dependencies
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*

# Build outputs
build/
dist/
out/
.next/
.nuxt/
.output/
.vercel/
.netlify/

# Cache directories
.cache/
.parcel-cache/
.tmp/
.temp/
.vite/
.turbo/

# Environment files
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# IDE/Editor files
.vscode/
.idea/
*.swp
*.swo
*~

# OS generated files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Logs
logs/
*.log

# Test coverage
coverage/
.nyc_output/
.coverage/

# Package manager lock files (mantém apenas um)
# package-lock.json
# yarn.lock
# pnpm-lock.yaml

# Assets grandes (imagens, vídeos, fontes)
*.png
*.jpg
*.jpeg
*.gif
*.svg
*.ico
*.webp
*.mp4
*.avi
*.mov
*.wmv
*.flv
*.woff
*.woff2
*.ttf
*.eot
*.otf

# Documentação (se não for essencial)
README.md
CHANGELOG.md
LICENSE
*.md

# Configurações não essenciais
.prettierrc*
.eslintrc*
.stylelintrc*
.editorconfig
.gitignore
.gitattributes
tailwind.config.js
postcss.config.js
vite.config.*
webpack.config.*
rollup.config.*
babel.config.*
jest.config.*
cypress.json
playwright.config.*

# Testes (se não quiser incluir)
# __tests__/
# **/*.test.*
# **/*.spec.*
# cypress/
# e2e/

# Storybook
.storybook/
storybook-static/

# Tipos gerados automaticamente
*.d.ts

# Arquivos de exemplo/demo
examples/
demo/
docs/
documentation/

# Mapas de source
*.map

# Arquivos de rotas específicos (dados de path grandes)
src/pages/mapaRota/paths/route1Path.ts
src/pages/mapaRota/paths/route2Path.ts
src/pages/mapaRota/paths/route3Path.ts
src/pages/mapaRota/paths/route4Path.ts

# Ou se quiser ignorar todos os paths dessa pasta:
# src/pages/mapaRota/paths/
</file>

<file path="components.json">
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": false,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.js",
    "css": "src/index.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}
</file>

<file path="Dockerfile">
# Usa a imagem oficial do Node.js
FROM node:23-alpine3.20

# Define o diretório de trabalho dentro do container
WORKDIR /app


# Copia os arquivos de configuração do projeto
COPY package*.json ./
COPY vite.config.ts ./

# Instala as dependências
RUN npm install

# # Copia o restante dos arquivos do projeto
COPY . .

# # Expõe a porta que o Vite usa por padrão
EXPOSE 5173

# # Comando para iniciar o servidor de desenvolvimento
CMD ["npm", "run", "dev"]
</file>

<file path="eslint.config.js">
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'

export default tseslint.config(
  { ignores: ['dist'] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ['**/*.{ts,tsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
)
</file>

<file path="index.html">
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>Jogos Logísticos</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta charset="utf-8" />
  <meta content="width=device-width, initial-scale=1" name="viewport" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Silkscreen:wght@400;700&family=Signika:wght@700&display=swap"
    rel="stylesheet">
  <link href="./src/index.css" rel="stylesheet" />
  <link href="./src/App.css" rel="stylesheet" />
</head>

<body>
  <div id="app"></div>
  <script type="module" src="./src/main.tsx"></script>
</body>

</html>
</file>

<file path="src/components/ButtonHomeBack.tsx">
import { ReactNode } from 'react';

interface ButtonHomeBackProps {
    onClick: () => void;
    children: ReactNode;  
}
/// <button onClick={() => navigate(-1)} className="w-10 h-10 bg-white rounded-md items-center justify-center  flex text-black" ><div className="justify-self-center"><ArrowLeft size={25} /></div></button>
export const ButtonHomeBack = ({ 
  onClick, 
  children
}: ButtonHomeBackProps) => {
  return (
    <button 
      onClick={onClick}
      type="button"
      className="flex items-center justify-center w-14 h-14 bg-white border-2 border-black hover:shadow-[4px_4px_0px_0px_rgba(0,0,0,1)] transition-all hover:-translate-x-[2px] hover:-translate-y-[2px]"
      aria-label="Voltar para página anterior"
    >
        <div className="justify-self-center"> 
            {children}
        </div>
    </button>
  );
};
</file>

<file path="src/components/Cloud.tsx">
import React from 'react';

interface CloudProps {
  className?: string;
  position: string;
}
// Essas nuvens são usadas para criar um efeito visual de nuvens pixeladas no fundo do jogo. 
// são menores e mais simples que as nuvens do jogo, mas nao exclui a possibilidade de serem usadas no jogo, mas atualmente 
//eelas não estão sendo utilizadas.

const Cloud: React.FC<CloudProps> = ({ className, position }) => {
  return (
    <div className={`pixel-cloud ${position} ${className}`}>
      <svg width="120" height="60" viewBox="0 0 120 60" fill="none" xmlns="http://www.w3.org/2000/svg">
        <rect x="20" y="20" width="20" height="20" fill="#B8B5FF" />
        <rect x="40" y="20" width="20" height="20" fill="#B8B5FF" />
        <rect x="60" y="20" width="20" height="20" fill="#B8B5FF" />
        <rect x="0" y="40" width="20" height="20" fill="#B8B5FF" />
        <rect x="20" y="40" width="20" height="20" fill="#B8B5FF" />
        <rect x="40" y="40" width="20" height="20" fill="#B8B5FF" />
        <rect x="60" y="40" width="20" height="20" fill="#B8B5FF" />
        <rect x="80" y="40" width="20" height="20" fill="#B8B5FF" />
        <rect x="100" y="40" width="20" height="20" fill="#B8B5FF" />
      </svg>
    </div>
  );
};

export default Cloud;
</file>

<file path="src/components/CreateTeamButton.tsx">
import React from 'react';
import { Plus } from 'lucide-react';

interface CreateTeamButtonProps {
  onClick: () => void;
}

const CreateTeamButton: React.FC<CreateTeamButtonProps> = ({ onClick }) => {
  return (
    <div 
      onClick={onClick} 
      className=" bg-white border-2 border-black rounded-lg p-6 flex flex-col items-center justify-center h-22 cursor-pointer 
        hover:shadow-[4px_4px_0px_0px_rgba(0,0,0,1)] transition-all hover:-translate-x-[2px] hover:-translate-y-[2px]"
    >
      <div className="w-8 h-8 rounded-full border-2 border-cyan-400 flex items-center justify-center">
        <Plus size={32} className="text-cyan-400" />
      </div>
      <span className="font-pixel text-cyan-400 text-center mt-4">CRIAR NOVA EQUIPE</span>
    </div>
  );
};

export default CreateTeamButton;
</file>

<file path="src/components/ProtectedRoute.tsx">
import { Navigate } from 'react-router-dom';
import { useAuth } from '../contexts/AuthContext';
import { ReactNode } from 'react';

interface ProtectedRouteProps {
  children: ReactNode;
  redirectTo?: string;
}

export const ProtectedRoute: React.FC<ProtectedRouteProps> = ({
  children,
  redirectTo = '/login'
}) => {
  const { isAuthenticated, loading } = useAuth();

  // Se ainda estiver carregando, mostra um indicador de carregamento
  if (loading) {
    return (
      <div className="flex h-screen items-center justify-center bg-gradient-to-b from-sky-300 to-purple-400">
        <div className="text-center">
          <div className="animate-spin rounded-full h-32 w-32 border-b-2 border-black mx-auto mb-4"></div>
          <p className="[font-family:'Silkscreen',Helvetica] text-black text-lg">CARREGANDO...</p>
        </div>
      </div>
    );
  }

  // Se não estiver autenticado, redireciona para o login
  if (!isAuthenticated) {
    return <Navigate to={redirectTo} replace />;
  }

  // Se estiver autenticado, renderiza os componentes filhos
  return <>{children}</>;
};

export default ProtectedRoute;
</file>

<file path="src/components/SelectTeamButton.tsx">
import React from 'react';

interface SelectTeamButtonProps {
  onClick: () => void;
}

const SelectTeamButton: React.FC<SelectTeamButtonProps> = ({ onClick }) => {
  return (
    <button 
      onClick={onClick}
      className="w-[500px] mx-auto bg-orange-500 text-black font-bold py-2 px-6 border-2 border-black mb-2
        hover:shadow-[4px_4px_0px_0px_rgba(0,0,0,1)] transition-all 
        hover:-translate-x-[2px] hover:-translate-y-[2px] text-xl"
    >
      ESCOLHER ESSA EQUIPE
    </button>

  );
};

export default SelectTeamButton;
</file>

<file path="src/components/TeamCard.tsx">
import React from 'react';
import { Team } from '../types';
import { Users, Trophy, Truck, ListChecks } from 'lucide-react';
import clsx from 'clsx';

interface TeamCardProps {
  team: Team;
  onClick?: () => void;
  selected?: boolean;
}

const TeamCard = ({ team, onClick, selected }: TeamCardProps) => {
  return (
    <div 
      className={clsx(
        'p-4 border-2 border-black transition-all cursor-pointer bg-white',
        'hover:shadow-[4px_4px_0px_0px_rgba(0,0,0,1)]',
        'hover:-translate-x-[2px] hover:-translate-y-[2px]',
        selected ? 'ring-4 ring-yellow-400' : ''
      )}
      onClick={onClick}
    >
      
      <div className="flex items-start">
        {/* Main Team Info */}
        <div className="flex items-start space-x-4">
          <div className="w-16 h-16 bg-gray-300 border-2 border-black"></div>
          <div className="flex-1">
            <h3 className="font-pixel text-xl font-bold">{team.nome}</h3>
            <div className="flex space-x-4 mt-2">
              <div className="flex items-center space-x-1">
                <Users size={18} />
                <span className="font-pixel">{team.stats.people}</span>
              </div>
              
              <div className="flex items-center space-x-1">
                <Trophy size={18} />
                <span className="font-pixel">{team.stats.trophy}</span>
              </div>
              
              {team.stats.trucks && (
                <div className="flex items-center space-x-1">
                  <Truck size={18} />
                  <span className="font-pixel">{team.stats.trucks}</span>
                </div>
              )}
              
              {team.stats.tasks && (
                <div className="flex items-center space-x-1">
                  <ListChecks size={18} />
                  <span className="font-pixel">{team.stats.tasks}</span>
                </div>
              )}
            </div>
          </div>
        </div>

        {/* History Cards */}
        {team.history && (
          <div className="flex ml-auto gap-2 w-[850px]">
            {team.history.map((historyItem) => (
              <div
                key={historyItem.id}
                className={clsx(
                  'p-2 border-2 border-black flex-1',
                  historyItem.color
                )}
              >
                <h4 className="font-pixel text-sm font-bold mb-2">{historyItem.name}</h4>
                <div className="flex flex-wrap gap-2">
                  <div className="flex items-center space-x-1">
                    <Users size={14} />
                    <span className="font-pixel text-sm">{historyItem.stats.people}</span>
                  </div>
                  <div className="flex items-center space-x-1">
                    <Trophy size={14} />
                    <span className="font-pixel text-sm">{historyItem.stats.trophy}</span>
                  </div>
                  {historyItem.stats.tasks && (
                    <div className="flex items-center space-x-1">
                      <ListChecks size={14} />
                      <span className="font-pixel text-sm">{historyItem.stats.tasks}</span>
                    </div>
                  )}
                </div>
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  );
};

export default TeamCard;
</file>

<file path="src/components/ui/button.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
        outline:
          "border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }
</file>

<file path="src/components/ui/card.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-xl border bg-card text-card-foreground shadow",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("font-semibold leading-none tracking-tight", className)}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }
</file>

<file path="src/components/ui/carousel.tsx">
import * as React from "react"
import useEmblaCarousel, {
  type UseEmblaCarouselType,
} from "embla-carousel-react"
import { ArrowLeft, ArrowRight } from "lucide-react"

import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"

type CarouselApi = UseEmblaCarouselType[1]
type UseCarouselParameters = Parameters<typeof useEmblaCarousel>
type CarouselOptions = UseCarouselParameters[0]
type CarouselPlugin = UseCarouselParameters[1]

type CarouselProps = {
  opts?: CarouselOptions
  plugins?: CarouselPlugin
  orientation?: "horizontal" | "vertical"
  setApi?: (api: CarouselApi) => void
}

type CarouselContextProps = {
  carouselRef: ReturnType<typeof useEmblaCarousel>[0]
  api: ReturnType<typeof useEmblaCarousel>[1]
  scrollPrev: () => void
  scrollNext: () => void
  canScrollPrev: boolean
  canScrollNext: boolean
} & CarouselProps

const CarouselContext = React.createContext<CarouselContextProps | null>(null)

function useCarousel() {
  const context = React.useContext(CarouselContext)

  if (!context) {
    throw new Error("useCarousel must be used within a <Carousel />")
  }

  return context
}

const Carousel = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & CarouselProps
>(
  (
    {
      orientation = "horizontal",
      opts,
      setApi,
      plugins,
      className,
      children,
      ...props
    },
    ref
  ) => {
    const [carouselRef, api] = useEmblaCarousel(
      {
        ...opts,
        axis: orientation === "horizontal" ? "x" : "y",
      },
      plugins
    )
    const [canScrollPrev, setCanScrollPrev] = React.useState(false)
    const [canScrollNext, setCanScrollNext] = React.useState(false)

    const onSelect = React.useCallback((api: CarouselApi) => {
      if (!api) {
        return
      }

      setCanScrollPrev(api.canScrollPrev())
      setCanScrollNext(api.canScrollNext())
    }, [])

    const scrollPrev = React.useCallback(() => {
      api?.scrollPrev()
    }, [api])

    const scrollNext = React.useCallback(() => {
      api?.scrollNext()
    }, [api])

    const handleKeyDown = React.useCallback(
      (event: React.KeyboardEvent<HTMLDivElement>) => {
        if (event.key === "ArrowLeft") {
          event.preventDefault()
          scrollPrev()
        } else if (event.key === "ArrowRight") {
          event.preventDefault()
          scrollNext()
        }
      },
      [scrollPrev, scrollNext]
    )

    React.useEffect(() => {
      if (!api || !setApi) {
        return
      }

      setApi(api)
    }, [api, setApi])

    React.useEffect(() => {
      if (!api) {
        return
      }

      onSelect(api)
      api.on("reInit", onSelect)
      api.on("select", onSelect)

      return () => {
        api?.off("select", onSelect)
      }
    }, [api, onSelect])

    return (
      <CarouselContext.Provider
        value={{
          carouselRef,
          api: api,
          opts,
          orientation:
            orientation || (opts?.axis === "y" ? "vertical" : "horizontal"),
          scrollPrev,
          scrollNext,
          canScrollPrev,
          canScrollNext,
        }}
      >
        <div
          ref={ref}
          onKeyDownCapture={handleKeyDown}
          className={cn("relative", className)}
          role="region"
          aria-roledescription="carousel"
          {...props}
        >
          {children}
        </div>
      </CarouselContext.Provider>
    )
  }
)
Carousel.displayName = "Carousel"

const CarouselContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const { carouselRef, orientation } = useCarousel()

  return (
    <div ref={carouselRef} className="overflow-hidden">
      <div
        ref={ref}
        className={cn(
          "flex",
          orientation === "horizontal" ? "-ml-4" : "-mt-4 flex-col",
          className
        )}
        {...props}
      />
    </div>
  )
})
CarouselContent.displayName = "CarouselContent"

const CarouselItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const { orientation } = useCarousel()

  return (
    <div
      ref={ref}
      role="group"
      aria-roledescription="slide"
      className={cn(
        "min-w-0 shrink-0 grow-0 basis-full",
        orientation === "horizontal" ? "pl-4" : "pt-4",
        className
      )}
      {...props}
    />
  )
})
CarouselItem.displayName = "CarouselItem"

const CarouselPrevious = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<typeof Button>
>(({ className, variant = "outline", size = "icon", ...props }, ref) => {
  const { orientation, scrollPrev, canScrollPrev } = useCarousel()

  return (
    <Button
      ref={ref}
      variant={variant}
      size={size}
      className={cn(
        "absolute  h-8 w-8 rounded-full",
        orientation === "horizontal"
          ? "-left-12 top-1/2 -translate-y-1/2"
          : "-top-12 left-1/2 -translate-x-1/2 rotate-90",
        className
      )}
      disabled={!canScrollPrev}
      onClick={scrollPrev}
      {...props}
    >
      <ArrowLeft className="h-4 w-4" />
      <span className="sr-only">Previous slide</span>
    </Button>
  )
})
CarouselPrevious.displayName = "CarouselPrevious"

const CarouselNext = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<typeof Button>
>(({ className, variant = "outline", size = "icon", ...props }, ref) => {
  const { orientation, scrollNext, canScrollNext } = useCarousel()

  return (
    <Button
      ref={ref}
      variant={variant}
      size={size}
      className={cn(
        "absolute h-8 w-8 rounded-full",
        orientation === "horizontal"
          ? "-right-12 top-1/2 -translate-y-1/2"
          : "-bottom-12 left-1/2 -translate-x-1/2 rotate-90",
        className
      )}
      disabled={!canScrollNext}
      onClick={scrollNext}
      {...props}
    >
      <ArrowRight className="h-4 w-4" />
      <span className="sr-only">Next slide</span>
    </Button>
  )
})
CarouselNext.displayName = "CarouselNext"

export {
  type CarouselApi,
  Carousel,
  CarouselContent,
  CarouselItem,
  CarouselPrevious,
  CarouselNext,
}
</file>

<file path="src/components/ui/dialog.tsx">
import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 opacity-80 transition-all duration-300 ease-in-out
               hover:scale-110 rounded-md text bg-red-600  ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <h1 className="font-pixel text-sm text-white" >X</h1>
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogTrigger,
  DialogClose,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}
</file>

<file path="src/components/ui/input.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

const Input = React.forwardRef<HTMLInputElement, React.ComponentProps<"input">>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-base shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }
</file>

<file path="src/components/ui/separator.tsx">
import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(
  (
    { className, orientation = "horizontal", decorative = true, ...props },
    ref
  ) => (
    <SeparatorPrimitive.Root
      ref={ref}
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "shrink-0 bg-border",
        orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
        className
      )}
      {...props}
    />
  )
)
Separator.displayName = SeparatorPrimitive.Root.displayName

export { Separator }
</file>

<file path="src/constants/teams.ts">
import { Team } from '../types';

export const TEAMS: Team[] = [
  {
    id: 'team1',
    name: 'ENTREGA RÁPIDA',
    stats: {
      people: 4,
      trophy: 25,
    },
    selected: false,
    history: [
      {
        id: 'history1',
        name: 'ENTREGA EFICIENTE',
        stats: {
          people: 3,
          trophy: 15,
          tasks: 4
        },
        color: 'bg-yellow-500'
      },
      {
        id: 'history2',
        name: 'JOGO 2',
        stats: {
          people: 2,
          trophy: 10,
          tasks: 3
        },
        color: 'bg-cyan-500'
      },
      {
        id: 'history3',
        name: 'JOGO 3',
        stats: {
          people: 2,
          trophy: 5,
          tasks: 1
        },
        color: 'bg-emerald-500'
      }
    ]
  },
  {
    id: 'team2',
    name: 'FRUIT VALE',
    stats: {
      people: 4,
      trophy: 5,
      trucks: 3
    },
    selected: false,
    history: [
      {
        id: 'history1',
        name: 'ENTREGA EFICIENTE',
        stats: {
          people: 3,
          trophy: 15,
          tasks: 4
        },
        color: 'bg-yellow-500'
      },
      {
        id: 'history2',
        name: 'JOGO 2',
        stats: {
          people: 2,
          trophy: 10,
          tasks: 3
        },
        color: 'bg-cyan-500'
      },
      {
        id: 'history3',
        name: 'JOGO 3',
        stats: {
          people: 2,
          trophy: 5,
          tasks: 1
        },
        color: 'bg-emerald-500'
      }
    ]
  }
];
</file>

<file path="src/lib/utils.ts">
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
</file>

<file path="src/pages/auth/ForgotPassword/ForgotPassword.tsx">
import { useState } from "react";
import { useNavigate, useParams } from "react-router-dom";
import { Button } from "../../../components/ui/button";
import {
  Card,
  CardContent,
  CardHeader,
  CardTitle,
} from "../../../components/ui/card";
import { Input } from "../../../components/ui/input";
import { ArrowLeft, House, AlertCircle } from 'lucide-react';
import { ButtonHomeBack } from "@/components/ButtonHomeBack";
import AuthService from "../../../api/authService";

export const ForgotPassword = () => {
  const navigate = useNavigate();
  const { uidb64, token } = useParams(); // Para reset de senha
  const [step, setStep] = useState(uidb64 && token ? 2 : 1);
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [confirmPassword, setConfirmPassword] = useState("");
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");
  const [success, setSuccess] = useState("");

  const handleEmailSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    if (!email) {
      setError("Por favor, informe seu e-mail");
      return;
    }

    setLoading(true);
    setError("");

    try {
      await AuthService.requestPasswordReset({ email });
      setSuccess("E-mail de recuperação enviado! Verifique sua caixa de entrada.");
      setTimeout(() => {
        if (!uidb64 && !token) {
          navigate('/login');
        }
      }, 3000);
    } catch (error: any) {
      if (error.response && error.response.data) {
        if (error.response.data.email) {
          setError(error.response.data.email.join(", "));
        } else if (error.response.data.detail) {
          setError(error.response.data.detail);
        } else {
          setError("Falha ao solicitar recuperação de senha.");
        }
      } else {
        setError("Erro de conexão. Tente novamente mais tarde.");
      }
    } finally {
      setLoading(false);
    }
  };

  const handlePasswordReset = async (e: React.FormEvent) => {
    e.preventDefault();

    if (!password || !confirmPassword) {
      setError("Por favor, preencha todos os campos");
      return;
    }

    if (password !== confirmPassword) {
      setError("As senhas não conferem");
      return;
    }

    setLoading(true);
    setError("");

    try {
      await AuthService.confirmPasswordReset({
        password,
        password2: confirmPassword,
        token: token || "",
        uidb64: uidb64 || ""
      });

      setSuccess("Senha alterada com sucesso!");
      setTimeout(() => {
        navigate('/login');
      }, 2000);
    } catch (error: any) {
      if (error.response && error.response.data) {
        if (typeof error.response.data === 'object') {
          const errorMessages = Object.entries(error.response.data)
            .map(([key, value]) => `${key}: ${Array.isArray(value) ? value.join(", ") : value}`)
            .join("; ");
          setError(errorMessages);
        } else {
          setError("Falha ao redefinir senha. Verifique o link ou tente novamente.");
        }
      } else {
        setError("Erro de conexão. Tente novamente mais tarde.");
      }
    } finally {
      setLoading(false);
    }
  };

  const renderEmailScreen = () => (
    <Card className="w-[700px] h-auto rounded-[18px] border-2 border-solid border-black bg-white">
      <CardHeader className="pb-0">
        <CardTitle className="text-[35px] text-center [font-family:'Silkscreen',Helvetica] font-bold">
          ESQUECI A SENHA
        </CardTitle>
      </CardHeader>
      <CardContent className="pt-1 px-[45px]">
        {success && (
          <div className="bg-green-100 border border-green-400 text-green-700 px-4 py-3 rounded relative mb-4">
            {success}
          </div>
        )}

        {error && (
          <div className="text-red-500 flex items-center gap-2 mb-4">
            <AlertCircle size={20} />
            <span>{error}</span>
          </div>
        )}

        <form className="space-y-2" onSubmit={handleEmailSubmit}>
          <div className="space-y-2">
            <label
              htmlFor="email"
              className="block [font-family:'Silkscreen',Helvetica] font-bold text-black text-[32px]"
            >
              CONFIRME O EMAIL
            </label>
            <Input
              id="email"
              type="email"
              placeholder="teste@email.com"
              className="h-[55px] rounded-xl border border-solid border-black"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
            />
          </div>

          <div className="flex justify-end pt-4">
            <Button
              type="submit"
              disabled={loading}
              className="w-[274px] h-[53px] bg-[#e3922a] rounded-md [font-family:'Silkscreen',Helvetica] font-bold text-black text-[32px] hover:bg-[#e3922a] transform transition-transform duration-300 hover:scale-105"
            >
              {loading ? "ENVIANDO..." : "ENVIAR"}
            </Button>
          </div>
        </form>
      </CardContent>
    </Card>
  );

  const renderNewPasswordScreen = () => (
    <Card className="w-[700px] h-auto rounded-[18px] border-2 border-solid border-black bg-white">
      <CardHeader className="pb-0">
        <CardTitle className="text-[35px] text-center [font-family:'Silkscreen',Helvetica] font-bold">
          NOVA SENHA
        </CardTitle>
      </CardHeader>
      <CardContent className="pt-1 px-[45px]">
        {success && (
          <div className="bg-green-100 border border-green-400 text-green-700 px-4 py-3 rounded relative mb-4">
            {success}
          </div>
        )}

        {error && (
          <div className="text-red-500 flex items-center gap-2 mb-4">
            <AlertCircle size={20} />
            <span>{error}</span>
          </div>
        )}

        <form className="space-y-2" onSubmit={handlePasswordReset}>
          <div className="space-y-2">
            <label
              htmlFor="newPassword"
              className="block [font-family:'Silkscreen',Helvetica] font-bold text-black text-[32px]"
            >
              NOVA SENHA
            </label>
            <Input
              id="newPassword"
              type="password"
              className="h-[55px] rounded-xl border border-solid border-black"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
            />
          </div>

          <div className="space-y-2">
            <label
              htmlFor="confirmPassword"
              className="block [font-family:'Silkscreen',Helvetica] font-bold text-black text-[32px]"
            >
              CONFIRME A SENHA
            </label>
            <Input
              id="confirmPassword"
              type="password"
              className="h-[55px] rounded-xl border border-solid border-black"
              value={confirmPassword}
              onChange={(e) => setConfirmPassword(e.target.value)}
            />
          </div>

          <div className="flex justify-end pt-4">
            <Button
              type="submit"
              disabled={loading}
              className="w-[274px] h-[53px] bg-[#e3922a] rounded-md [font-family:'Silkscreen',Helvetica] font-bold text-black text-[32px] hover:bg-[#e3922a] transform transition-transform duration-300 hover:scale-105"
            >
              {loading ? "ENVIANDO..." : "ALTERAR"}
            </Button>
          </div>
        </form>
      </CardContent>
    </Card>
  );

  return (
    <div className="bg-white flex flex-row justify-center w-full">
      <div className="w-full min-h-screen [background:linear-gradient(180deg,rgba(32,2,89,1)_0%,rgba(121,70,213,1)_100%)] relative overflow-hidden">
        {/* Imagens de decoração */}
        <img
          className="w-[375px] h-[147px] absolute top-[120px] left-[157px] object-cover animate-float-right"
          alt="Cloud decoration"
          src="/nuvemleft.png"
        />
        <img
          className="w-[436px] h-[170px] absolute bottom-[30px] right-[27px] object-cover animate-float-left opacity-75 scale-110"
          alt="Cloud decoration"
          src="/nuvemright.png"
        />

        {/* Botões de navegação */}
        <div className="flex gap-5 absolute top-14 left-[33px]">
          <ButtonHomeBack onClick={() => navigate("/login")}><ArrowLeft /></ButtonHomeBack>
          <ButtonHomeBack onClick={() => navigate("/")}><House /></ButtonHomeBack>
        </div>

        {/* Conteúdo principal */}
        <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2">
          {step === 1 ? renderEmailScreen() : renderNewPasswordScreen()}
        </div>
      </div>
    </div>
  );
};

export default ForgotPassword;
</file>

<file path="src/pages/escolherVeiculo/index.ts">
export { VehicleSelectionPage } from './VehicleSelectionPage';
</file>

<file path="src/pages/Game-truck/game.css">
@import url('https://fonts.googleapis.com/css2?family=Silkscreen:wght@400;700&display=swap');

/* Garantir que o body não tenha margem/padding para tela cheia */
body {
  margin: 0;
  padding: 0;
  overflow: hidden; /* Evitar scroll bars em tela cheia */
}

.tittle {
    font-family: "Silkscreen", sans-serif;
}

.endMessage {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: white;
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    text-align: center;
    color: black;
    font-family: "Silkscreen", sans-serif;
    z-index: 2000;
}

/* Ajustes responsivos para diferentes tamanhos de tela */
@media (max-width: 768px) {
  .endMessage {
    width: 90%;
    max-width: 350px;
    padding: 15px;
  }
}
</file>

<file path="src/pages/Game-truck/kaboom.ts">
import kaboom from "kaboom";

export const k = kaboom({
  width: 640,
  height: 480,
  canvas: document.createElement("canvas"), // será substituído depois!
  scale: 2,
  background: [0, 0, 0],
});
</file>

<file path="src/pages/GameSelection/components/Footer.tsx">
import React from 'react';

const Footer: React.FC = () => {
  return (
    <footer 
      className="w-full text-center py-6 text-white text-[8px] tracking-wider opacity-70"
      style={{ fontFamily: "'Press Start 2P', cursive" }}
    >
      © 2025 JOGOS LOGÍSTICOS - TODOS OS DIREITOS RESERVADOS
    </footer>
  );
};

export default Footer;
</file>

<file path="src/pages/GameSelection/components/GameCard.tsx">
import React from 'react';

interface GameCardProps {
  title: string;
  description: string;
  isActive: boolean;
  onClick: () => void;
  borderColor: string;
  buttonBgColor: string;
  buttonHoverColor: string;
  icon: React.ReactNode;
}

const GameCard: React.FC<GameCardProps> = ({ 
  title, 
  description, 
  isActive, 
  onClick,
  borderColor,
  buttonBgColor,
  buttonHoverColor,
  icon
}) => {
  return (
    <div 
      className={`
        bg-white overflow-hidden transition-all duration-300 flex flex-col hover:opacity-100 hover:scale-100
        border-t-4 ${borderColor} 
        ${isActive ? 'opacity-100 scale-100' : 'opacity-50 scale-95'}
      `}
      onClick={onClick}
      style={{ fontFamily: "'Press Start 2P', cursive" }}
    >
      <div className="bg-gray-300 aspect-video flex items-center justify-center">
        <div className={`${isActive ? 'text-gray-700' : 'text-gray-400'}`}>
          {icon}
        </div>
      </div>
      
      <div className="p-6 flex-grow">
        <h3 className={`text-center font-bold text-sm mb-4 leading-relaxed ${isActive ? 'text-black' : 'text-gray-400'}`}>
          {title}
        </h3>
        
        <p className={`text-center text-[8px] leading-relaxed ${isActive ? 'text-black' : 'text-gray-400'}`}>
          {description}
        </p>
      </div>
      
      <div className="p-4">
        <button 
          className={`
            w-full py-3 text-center text-sm
            transition-colors duration-200
            ${buttonBgColor} ${buttonHoverColor}
            ${isActive ? 'text-black' : 'text-gray-500'}
          `}
        >
          JOGAR
        </button>
      </div>
    </div>
  );
};

export default GameCard;
</file>

<file path="src/pages/GameSelection/components/PixelHeading.tsx">
import React from 'react';

interface PixelHeadingProps {
  text: string;
  className?: string;
}

const PixelHeading: React.FC<PixelHeadingProps> = ({ text, className = '' }) => {
  return (
    <h1 
      className={`
        text-3xl md:text-4xl text-white tracking-widest uppercase
        drop-shadow-xl
        ${className}
      `}
      style={{ fontFamily: "'Press Start 2P', cursive" }}
    >
      {text.split('').map((char, index) => (
        <span 
          key={index} 
          className="inline-block transform transition-all duration-200 hover:scale-110 hover:text-yellow-300"
          style={{ padding: '0 0.05em' }}
        >
          {char === ' ' ? '\u00A0' : char}
        </span>
      ))}
    </h1>
  );
};

export default PixelHeading;
</file>

<file path="src/pages/Home/index.ts">
export { HomePage } from "./HomePage";
</file>

<file path="src/pages/Perfil/ChangePassword.tsx">
import { useState } from "react";
import { useNavigate } from "react-router-dom";
import { useAuth } from "../../contexts/AuthContext";
import { Button } from "../../components/ui/button";
import { Card, CardContent } from "../../components/ui/card";
import { Eye, EyeOff, ArrowLeft, Lock } from 'lucide-react';

export const ChangePassword = () => {
  const navigate = useNavigate();
  const { user } = useAuth();
  
  const [formData, setFormData] = useState({
    currentPassword: '',
    newPassword: '',
    confirmPassword: ''
  });
  
  const [showPasswords, setShowPasswords] = useState({
    current: false,
    new: false,
    confirm: false
  });
  
  const [errors, setErrors] = useState<Record<string, string>>({});
  const [isLoading, setIsLoading] = useState(false);
  const [successMessage, setSuccessMessage] = useState('');

  const handleInputChange = (field: string, value: string) => {
    setFormData(prev => ({ ...prev, [field]: value }));
    // Limpar erro específico quando usuário começar a digitar
    if (errors[field]) {
      setErrors(prev => ({ ...prev, [field]: '' }));
    }
    // Limpar mensagem de sucesso
    if (successMessage) {
      setSuccessMessage('');
    }
  };

  const togglePasswordVisibility = (field: 'current' | 'new' | 'confirm') => {
    setShowPasswords(prev => ({ ...prev, [field]: !prev[field] }));
  };

  const validateForm = (): boolean => {
    const newErrors: Record<string, string> = {};

    // Validar senha atual
    if (!formData.currentPassword) {
      newErrors.currentPassword = 'Senha atual é obrigatória';
    }

    // Validar nova senha
    if (!formData.newPassword) {
      newErrors.newPassword = 'Nova senha é obrigatória';
    } else if (formData.newPassword.length < 8) {
      newErrors.newPassword = 'Nova senha deve ter pelo menos 8 caracteres';
    } else if (formData.newPassword === formData.currentPassword) {
      newErrors.newPassword = 'Nova senha deve ser diferente da atual';
    }

    // Validar confirmação
    if (!formData.confirmPassword) {
      newErrors.confirmPassword = 'Confirmação de senha é obrigatória';
    } else if (formData.newPassword !== formData.confirmPassword) {
      newErrors.confirmPassword = 'Senhas não conferem';
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!validateForm()) return;

    setIsLoading(true);
    setErrors({});

    try {

      // Simulando uma chamada API
      await new Promise(resolve => setTimeout(resolve, 1500));
      
      // Simular sucesso
      setSuccessMessage('Senha alterada com sucesso!');
      setFormData({ currentPassword: '', newPassword: '', confirmPassword: '' });
      
      // Redirecionar após 2 segundos
      setTimeout(() => {
        navigate('/perfil');
      }, 2000);

    } catch (error) {
      // Tratar diferentes tipos de erro
      setErrors({ 
        currentPassword: 'Senha atual incorreta' 
      });
    } finally {
      setIsLoading(false);
    }
  };

  const handleGoBack = () => {
    navigate('/perfil');
  };

  const titleStyle = {
    color: "#E3922A",
    textShadow: "2px 3px 0.6px #000"
  };

  return (
    <div className="bg-white flex flex-row justify-center w-full h-screen overflow-hidden">
      <div className="w-full h-full [background:linear-gradient(180deg,rgba(57,189,248,1)_0%,rgba(154,102,248,1)_100%)] relative overflow-hidden">
        
        {}
        <img
          className="w-[375px] h-[147px] absolute top-[120px] left-[157px] object-cover animate-float-right"
          alt="Cloud decoration"
          src="/nuvemleft.png"
        />
        <img
          className="w-[436px] h-[170px] absolute bottom-[30px] right-[27px] object-cover animate-float-left opacity-75 scale-110"
          alt="Cloud decoration"
          src="/nuvemright.png"
        />

        {/* Main content */}
        <div className="max-w-md mx-auto py-8 px-4 relative z-10 h-full flex flex-col justify-center">
          
          {/* Back button */}
          <Button
            variant="outline"
            onClick={handleGoBack}
            className="mb-2 border-2 border-black bg-white hover:bg-gray-100"
          >
            <ArrowLeft size={20} className="mr-2" />
            <span className="[font-family:'Silkscreen',Helvetica] font-bold">VOLTAR</span>
          </Button>

          <Card className="border-2 border-solid border-black rounded-lg overflow-hidden">
            <CardContent className="p-4">
              
              {/* Header */}
              <div className="text-center mb-4">
                <div className="w-12 h-12 mx-auto mb-3 bg-orange-100 rounded-full flex items-center justify-center border-2 border-orange-500">
                  <Lock size={24} className="text-orange-500" />
                </div>
                <h2 className="[font-family:'Silkscreen',Helvetica] font-bold text-xl" style={titleStyle}>
                  ALTERAR SENHA
                </h2>
                <p className="[font-family:'Silkscreen',Helvetica] text-xs mt-1 text-gray-600">
                  Olá, {user?.first_name || user?.username}! Altere sua senha abaixo.
                </p>
              </div>

              {/* Success message */}
              {successMessage && (
                <div className="mb-4 p-3 bg-green-100 border-2 border-green-500 rounded-lg text-center">
                  <span className="[font-family:'Silkscreen',Helvetica] text-green-700 font-bold">
                    {successMessage}
                  </span>
                </div>
              )}

              {/* Form */}
              <form onSubmit={handleSubmit} className="space-y-3">
                
                {/* Current Password */}
                <div>
                  <label className="[font-family:'Silkscreen',Helvetica] text-sm font-bold block mb-2">
                    SENHA ATUAL *
                  </label>
                  <div className="relative">
                    <input
                      type={showPasswords.current ? "text" : "password"}
                      value={formData.currentPassword}
                      onChange={(e) => handleInputChange('currentPassword', e.target.value)}
                      className="w-full px-3 py-2 border-2 border-black rounded focus:outline-none focus:border-orange-500 [font-family:'Silkscreen',Helvetica]"
                      placeholder="Digite sua senha atual"
                      disabled={isLoading}
                    />
                    <button
                      type="button"
                      onClick={() => togglePasswordVisibility('current')}
                      className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-500 hover:text-gray-700 bg-transparent border-0 outline-0 shadow-none focus:outline-0 focus:shadow-none focus:ring-0 active:outline-0 active:shadow-none"
                      style={{ boxShadow: 'none', outline: 'none' }}
                      disabled={isLoading}
                    >
                      {showPasswords.current ? <EyeOff size={20} /> : <Eye size={20} />}
                    </button>
                  </div>
                  {errors.currentPassword && (
                    <span className="text-red-500 text-xs [font-family:'Silkscreen',Helvetica] mt-1 block">
                      {errors.currentPassword}
                    </span>
                  )}
                </div>

                {/* New Password */}
                <div>
                  <label className="[font-family:'Silkscreen',Helvetica] text-sm font-bold block mb-2">
                    NOVA SENHA *
                  </label>
                  <div className="relative">
                    <input
                      type={showPasswords.new ? "text" : "password"}
                      value={formData.newPassword}
                      onChange={(e) => handleInputChange('newPassword', e.target.value)}
                      className="w-full px-3 py-2 border-2 border-black rounded focus:outline-none focus:border-orange-500 [font-family:'Silkscreen',Helvetica]"
                      placeholder="Digite sua nova senha"
                      disabled={isLoading}
                    />
                    <button
                      type="button"
                      onClick={() => togglePasswordVisibility('new')}
                      className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-500 hover:text-gray-700 bg-transparent border-0 outline-0 shadow-none focus:outline-0 focus:shadow-none focus:ring-0 active:outline-0 active:shadow-none"
                      style={{ boxShadow: 'none', outline: 'none' }}
                      disabled={isLoading}
                    >
                      {showPasswords.new ? <EyeOff size={20} /> : <Eye size={20} />}
                    </button>
                  </div>
                  {errors.newPassword && (
                    <span className="text-red-500 text-xs [font-family:'Silkscreen',Helvetica] mt-1 block">
                      {errors.newPassword}
                    </span>
                  )}
                  <span className="text-gray-500 text-xs [font-family:'Silkscreen',Helvetica] mt-1 block">
                    Mínimo de 8 caracteres
                  </span>
                </div>

                {/* Confirm Password */}
                <div>
                  <label className="[font-family:'Silkscreen',Helvetica] text-sm font-bold block mb-2">
                    CONFIRMAR NOVA SENHA *
                  </label>
                  <div className="relative">
                    <input
                      type={showPasswords.confirm ? "text" : "password"}
                      value={formData.confirmPassword}
                      onChange={(e) => handleInputChange('confirmPassword', e.target.value)}
                      className="w-full px-3 py-2 border-2 border-black rounded focus:outline-none focus:border-orange-500 [font-family:'Silkscreen',Helvetica]"
                      placeholder="Confirme sua nova senha"
                      disabled={isLoading}
                    />
                    <button
                      type="button"
                      onClick={() => togglePasswordVisibility('confirm')}
                      className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-500 hover:text-gray-700 bg-transparent border-0 outline-0 shadow-none focus:outline-0 focus:shadow-none focus:ring-0 active:outline-0 active:shadow-none"
                      style={{ boxShadow: 'none', outline: 'none' }}
                      disabled={isLoading}
                    >
                      {showPasswords.confirm ? <EyeOff size={20} /> : <Eye size={20} />}
                    </button>
                  </div>
                  {errors.confirmPassword && (
                    <span className="text-red-500 text-xs [font-family:'Silkscreen',Helvetica] mt-1 block">
                      {errors.confirmPassword}
                    </span>
                  )}
                </div>

                {/* Submit Button */}
                <Button
                  type="submit"
                  disabled={isLoading}
                  className="w-full bg-orange-400 text-black hover:bg-orange-500 h-10 border-2 border-black [font-family:'Silkscreen',Helvetica] font-bold mt-4"
                >
                  {isLoading ? (
                    <div className="flex items-center justify-center">
                      <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-black mr-2"></div>
                      ALTERANDO...
                    </div>
                  ) : (
                    'ALTERAR SENHA'
                  )}
                </Button>

              </form>

            </CardContent>
          </Card>
        </div>
      </div>
    </div>
  );
};

export default ChangePassword;
</file>

<file path="src/styles/pixelArt.css">
/* Pixel Art Styling */
@font-face {
  font-family: 'PixelFont';
  src: url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
  font-display: swap;
}

.font-pixel {
  font-family: 'Press Start 2P', monospace;
  letter-spacing: 1px;
  line-height: 1.5;
}

/* Custom utility classes */
.hover\:scale-102:hover {
  transform: scale(1.02);
}

/* Transitions */
.transition-all {
  transition: all 0.3s ease;
}
</file>

<file path="tsconfig.app.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
</file>

<file path="tsconfig.node.json">
{
  "compilerOptions": {
    "composite": true,
    "allowSyntheticDefaultImports": true,
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": false,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="tsconfig.tsbuildinfo">
{"root":["./src/App.tsx","./src/main.tsx","./src/vite-env.d.ts","./src/api/authService.ts","./src/api/config.ts","./src/api/gameService.ts","./src/api/teamService.ts","./src/components/ButtonHomeBack.tsx","./src/components/Cloud.tsx","./src/components/CreateTeamButton.tsx","./src/components/ProtectedRoute.tsx","./src/components/SelectTeamButton.tsx","./src/components/TeamCard.tsx","./src/components/ui/button.tsx","./src/components/ui/card.tsx","./src/components/ui/carousel.tsx","./src/components/ui/dialog.tsx","./src/components/ui/input.tsx","./src/components/ui/separator.tsx","./src/constants/teams.ts","./src/contexts/AuthContext.tsx","./src/lib/utils.ts","./src/pages/ChooseTeam/ChooseTeam.tsx","./src/pages/Desafio/ApresentacaoDesafio.tsx","./src/pages/Game-truck/game.tsx","./src/pages/Game-truck/kaboom.ts","./src/pages/GameSelection/GameSelectionPage.tsx","./src/pages/GameSelection/components/Footer.tsx","./src/pages/GameSelection/components/GameCard.tsx","./src/pages/GameSelection/components/PixelHeading.tsx","./src/pages/Home/HomePage.tsx","./src/pages/Home/index.ts","./src/pages/Perfil/ChangePassword.tsx","./src/pages/Perfil/CriarEquipe.tsx","./src/pages/Perfil/EditarEquipe.tsx","./src/pages/Perfil/EditarPerfil.tsx","./src/pages/Perfil/ExcluirEquipe.tsx","./src/pages/Perfil/PerfilPage.tsx","./src/pages/Ranking/RankingPage.tsx","./src/pages/RoutesPage/RoutesPage.tsx","./src/pages/Tutorial/TutorialPage.tsx","./src/pages/auth/Cadastro/Cadastro.tsx","./src/pages/auth/ForgotPassword/ForgotPassword.tsx","./src/pages/auth/Login/Login.tsx","./src/pages/escolherVeiculo/VehicleSelectionPage.tsx","./src/pages/escolherVeiculo/index.ts","./src/pages/fuel/FuelPage.tsx","./src/pages/mapaRota/FuelModal.tsx","./src/pages/mapaRota/MapComponent.tsx","./src/pages/mapaRota/routesData.ts","./src/pages/mapaRota/paths/route1Path.ts","./src/pages/mapaRota/paths/route2Path.ts","./src/pages/mapaRota/paths/route3Path.ts","./src/pages/mapaRota/paths/route4Path.ts","./src/types/index.ts","./src/types/vehicle.ts"],"errors":true,"version":"5.7.3"}
</file>

<file path="docker-compose.yml">
services:
  frontend:
    build: .
    ports:
      - "5173:5173"
    volumes:
      - .:/app:z
      - /app/node_modules
    environment:
      - CHOKIDAR_USEPOLLING=true
    stdin_open: true
    tty: true
    command: npm run dev -- --host 0.0.0.0
</file>

<file path="package.json">
{
  "name": "app",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@radix-ui/react-dialog": "^1.1.14",
    "@radix-ui/react-separator": "^1.1.7",
    "@radix-ui/react-slot": "^1.2.3",
    "@tanstack/react-query": "^5.80.6",
    "@tanstack/react-query-devtools": "^5.80.6",    "@types/react-router-dom": "^5.3.3",
    "axios": "^1.9.0",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "embla-carousel": "^8.6.0",
    "embla-carousel-react": "^8.6.0",
    "http-proxy-middleware": "^3.0.5",
    "kaboom": "^3000.1.17",
    "leaflet": "^1.9.4",
    "lucide-react": "^0.506.0",
    "radix-ui": "^1.3.4",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-leaflet": "^5.0.0",
    "react-router-dom": "^7.6.2",
    "tailwind-merge": "^3.3.1",
    "tailwindcss-animate": "^1.0.7"
  },
  "devDependencies": {
    "@eslint/js": "^9.21.0",
    "@types/leaflet": "^1.9.17",
    "@types/node": "^22.15.3",
    "@types/react": "^19.1.4",
    "@types/react-dom": "^19.1.5",
    "@vitejs/plugin-react": "^4.3.4",
    "autoprefixer": "^10.4.21",
    "eslint": "^9.21.0",
    "eslint-plugin-react-hooks": "^5.1.0",
    "eslint-plugin-react-refresh": "^0.4.19",
    "globals": "^15.15.0",
    "postcss": "^8.5.3",
    "tailwindcss": "^3.4.17",
    "typescript": "~5.7.2",
    "typescript-eslint": "^8.24.1",
    "vite": "^6.2.0"
  }
}
</file>

<file path="public/assets/Caminhao_medio.json">
{ "frames": {
   "Caminhao_medio1 0.png": {
    "frame": { "x": 0, "y": 0, "w": 600, "h": 531 },
    "rotated": false,
    "trimmed": false,
    "spriteSourceSize": { "x": 0, "y": 0, "w": 600, "h": 531 },
    "sourceSize": { "w": 600, "h": 531 },
    "duration": 100
   },
   "Caminhao_medio1 1.png": {
    "frame": { "x": 600, "y": 0, "w": 600, "h": 531 },
    "rotated": false,
    "trimmed": false,
    "spriteSourceSize": { "x": 0, "y": 0, "w": 600, "h": 531 },
    "sourceSize": { "w": 600, "h": 531 },
    "duration": 100
   }
 },
 "meta": {
  "app": "https://github.com/LibreSprite/LibreSprite/",
  "version": "1.1-dev",
  "image": "C:\\Users\\nicka\\OneDrive\\Documentos\\Sprites\\Caminhao_medio1-sheet.png",
  "format": "RGBA8888",
  "size": { "w": 1200, "h": 531 },
  "scale": "1",
  "frameTags": [
  ],
  "layers": [
   { "name": "Estrutura caminhão", "opacity": 255, "blendMode": "normal" },
   { "name": "detalhes e sombras caçamba", "opacity": 124, "blendMode": "normal" },
   { "name": "Pneusss", "opacity": 255, "blendMode": "normal" }
  ]
 }
}
</file>

<file path="public/assets/caminhao_pequeno.json">
{ "frames": {
   "caminhão_pequeno 0.ase": {
    "frame": { "x": 0, "y": 0, "w": 600, "h": 531 },
    "rotated": false,
    "trimmed": false,
    "spriteSourceSize": { "x": 0, "y": 0, "w": 600, "h": 531 },
    "sourceSize": { "w": 600, "h": 531 },
    "duration": 80
   },
   "caminhão_pequeno 1.ase": {
    "frame": { "x": 600, "y": 0, "w": 600, "h": 531 },
    "rotated": false,
    "trimmed": false,
    "spriteSourceSize": { "x": 0, "y": 0, "w": 600, "h": 531 },
    "sourceSize": { "w": 600, "h": 531 },
    "duration": 80
   }
 },
 "meta": {
  "app": "https://github.com/LibreSprite/LibreSprite/",
  "version": "1.1-dev",
  "image": "C:\\Users\\nicka\\OneDrive\\Documentos\\Sprites\\caminhão_pequeno.png",
  "format": "RGBA8888",
  "size": { "w": 1200, "h": 531 },
  "scale": "1",
  "frameTags": [
  ],
  "layers": [
   { "name": "Layer 1", "opacity": 255, "blendMode": "normal" },
   { "name": "Pneus", "opacity": 255, "blendMode": "normal" }
  ]
 }
}
</file>

<file path="public/assets/caminhonete.json">
{ "frames": {
   "caminhonete 0.ase": {
    "frame": { "x": 0, "y": 0, "w": 600, "h": 531 },
    "rotated": false,
    "trimmed": false,
    "spriteSourceSize": { "x": 0, "y": 0, "w": 600, "h": 531 },
    "sourceSize": { "w": 600, "h": 531 },
    "duration": 100
   },
   "caminhonete 1.ase": {
    "frame": { "x": 600, "y": 0, "w": 600, "h": 531 },
    "rotated": false,
    "trimmed": false,
    "spriteSourceSize": { "x": 0, "y": 0, "w": 600, "h": 531 },
    "sourceSize": { "w": 600, "h": 531 },
    "duration": 100
   }
 },
 "meta": {
  "app": "https://github.com/LibreSprite/LibreSprite/",
  "version": "1.1-dev",
  "image": "C:\\Users\\nicka\\OneDrive\\Documentos\\Sprites\\caminhonete.png",
  "format": "RGBA8888",
  "size": { "w": 1200, "h": 531 },
  "scale": "1",
  "frameTags": [
  ],
  "layers": [
   { "name": "vidro detalhes + porta", "opacity": 255, "blendMode": "normal" },
   { "name": "carro", "opacity": 255, "blendMode": "normal" },
   { "name": "sombra inferior", "opacity": 82, "blendMode": "normal" },
   { "name": "Pneus", "opacity": 255, "blendMode": "normal" }
  ]
 }
}
</file>

<file path="public/assets/carreta.json">
{ "frames": {
   "carreta 0.ase": {
    "frame": { "x": 0, "y": 0, "w": 600, "h": 530 },
    "rotated": false,
    "trimmed": false,
    "spriteSourceSize": { "x": 0, "y": 0, "w": 600, "h": 530 },
    "sourceSize": { "w": 600, "h": 530 },
    "duration": 100
   },
   "carreta 1.ase": {
    "frame": { "x": 600, "y": 0, "w": 600, "h": 530 },
    "rotated": false,
    "trimmed": false,
    "spriteSourceSize": { "x": 0, "y": 0, "w": 600, "h": 530 },
    "sourceSize": { "w": 600, "h": 530 },
    "duration": 100
   }
 },
 "meta": {
  "app": "https://github.com/LibreSprite/LibreSprite/",
  "version": "1.1-dev",
  "image": "C:\\Users\\nicka\\OneDrive\\Documentos\\Sprites\\carreta.png",
  "format": "RGBA8888",
  "size": { "w": 1200, "h": 530 },
  "scale": "1",
  "frameTags": [
  ],
  "layers": [
   { "name": "Layer 1", "opacity": 255, "blendMode": "normal" },
   { "name": "Pneus", "opacity": 255, "blendMode": "normal" },
   { "name": "sombreamento ", "opacity": 111, "blendMode": "normal" }
  ]
 }
}
</file>

<file path="src/App.css">
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.truck-tooltip {
  background-color: rgba(0, 0, 0, 0.75) !important;
  border: 1px solid white !important;
  color: white !important;
  padding: 4px 8px !important;
  border-radius: 4px !important;
  font-size: 10px !important;
  text-align: center !important;
  font-family: 'Silkscreen', monospace !important;
  
  /* Remove a seta padrão do tooltip do Leaflet */
  &::before {
    display: none;
  }
}

.read-the-docs {
  color: #888;
}
</file>

<file path="src/components/AudioControl.tsx">
import React from 'react';
import { useAudio } from '../contexts/AudioContext';
import { Volume2, VolumeX } from 'lucide-react';

interface AudioControlProps {
  className?: string;
}

export const AudioControl: React.FC<AudioControlProps> = ({ className = '' }) => {
  const { isPlaying, volume, toggleMusic, setVolume } = useAudio();

  return (
    <div className={`flex items-center gap-2 ${className}`}>
      <button
        onClick={toggleMusic}
        className="p-2 rounded-full bg-white/10 hover:bg-white/20 transition-colors"
        title={isPlaying ? 'Pausar música' : 'Tocar música'}
      >
        {isPlaying ? (
          <Volume2 className="w-5 h-5 text-white" />
        ) : (
          <VolumeX className="w-5 h-5 text-white" />
        )}
      </button>
      
      {isPlaying && (
        <input
          type="range"
          min="0"
          max="1"
          step="0.1"
          value={volume}
          onChange={(e) => setVolume(parseFloat(e.target.value))}
          className="w-20 h-2 bg-white/20 rounded-lg appearance-none cursor-pointer slider"
          title="Volume"
        />
      )}
    </div>
  );
};
</file>

<file path="src/components/AudioManager.tsx">
import { useEffect, useRef } from 'react';
import { useLocation } from 'react-router-dom';
import { useAudio } from '../contexts/AudioContext';

export const AudioManager = () => {
  const location = useLocation();
  const { playMenuMusic, stopMenuMusic, userPaused } = useAudio();
  const hasInitialized = useRef(false);
  const lastPathname = useRef(location.pathname);

  useEffect(() => {
    // Parar a música quando estiver no jogo
    if (location.pathname === '/game') {
      stopMenuMusic();
    } else {
      // Só tocar música se:
      // 1. Não estiver pausada pelo usuário
      // 2. Não estivesse no jogo antes (evita tocar quando sai do jogo)
      if (!userPaused && lastPathname.current !== '/game') {
        const timer = setTimeout(() => {
          playMenuMusic();
        }, 500);
        
        return () => clearTimeout(timer);
      }
    }
    
    lastPathname.current = location.pathname;
  }, [location.pathname, playMenuMusic, stopMenuMusic, userPaused]);

  // Efeito para iniciar a música apenas na primeira carga
  useEffect(() => {
    if (!hasInitialized.current && location.pathname !== '/game') {
      hasInitialized.current = true;
      const initialTimer = setTimeout(() => {
        playMenuMusic();
      }, 1000);
      
      return () => clearTimeout(initialTimer);
    }
  }, [location.pathname, playMenuMusic]);

  return null; // Este componente não renderiza nada
};
</file>

<file path="src/components/PixelProgressBar/PixelProgressBar.css">
/* src/components/PixelProgressBar/PixelProgressBar.css */

/* Container principal para alinhar a barra e o texto */
.pixel-progress-bar-container {
  position: relative;
  width: min(60vw, 800px);
  height: min(4vh, 30px);
}

/* A "caixa" externa da barra de progresso */
.pixel-progress-bar {
  width: 100%;
  height: 100%;
  background-color: #333; /* Fundo escuro */
  border: 3px solid #000; /* Borda preta e grossa */
  box-shadow: 6px 6px 0px 0px rgba(0,0,0,1); /* Sombra dura, sem blur */
  padding: 4px; /* Espaçamento interno para criar efeito de borda dupla */
  box-sizing: border-box;
}

/* A barra de preenchimento interna */
.pixel-progress-bar-inner {
  height: 100%;
  background-color: #88ffb4; /* Um verde vibrante, cor do progresso */
  
  /* Este gradiente cria o efeito de blocos pixelados!
    Ele desenha um bloco verde de 8px, seguido de um espaço transparente de 2px,
    e repete esse padrão por toda a extensão da barra.
  */
  background-image: repeating-linear-gradient(
    to right,
    #4ade80,          /* Cor do bloco */
    #4ade80 8px,      /* Fim do bloco (8px de largura) */
    transparent 8px,   /* Início do espaço (mesma posição, tornando-o invisível) */
    transparent 10px   /* Fim do espaço (2px de largura) */
  );

  /* Transição em "passos" para que o preenchimento não seja suave */
  transition: width 0.2s steps(10, end);
}

/* Estilo para o texto de porcentagem */
.pixel-progress-bar-text {
  position: absolute;
  right: 18px; /* Posição à direita */
  top: 50%;
  transform: translateY(-50%); /* Centraliza verticalmente */
  font-family: 'Silkscreen', monospace; /* Fonte pixelada */
  font-size: 16px;

  color: white;
  /* Efeito de contorno no texto */
  text-shadow: 
    -2px -2px 0 #000,  
     2px -2px 0 #000,
    -2px  2px 0 #000,
     2px  2px 0 #000;
  z-index: 2; /* Garante que o texto fique na frente da barra */
}
</file>

<file path="src/components/PixelProgressBar/PixelProgressBar.tsx">
import React from 'react';
import './PixelProgressBar.css'; // Vamos criar este arquivo de estilo a seguir

interface PixelProgressBarProps {
  progress: number; // Progresso de 0 a 100
  className?: string;
}

export const PixelProgressBar: React.FC<PixelProgressBarProps> = ({
  progress,
  className = ''
}) => {
  // Garante que o progresso não passe de 100% ou seja menor que 0
  const cappedProgress = Math.min(100, Math.max(0, progress));

  return (
    <div className={`pixel-progress-bar-container ${className}`}>
      {/* Container externo que dá o visual da "caixa" */}
      <div className="pixel-progress-bar">
        {/* Barra interna que representa o preenchimento */}
        <div
          className="pixel-progress-bar-inner"
          style={{ width: `${cappedProgress}%` }}
        ></div>
      </div>
      {/* Texto de porcentagem */}
      <span className="pixel-progress-bar-text">
        {Math.floor(cappedProgress)}%
      </span>
    </div>
  );
};
</file>

<file path="src/contexts/AudioContext.tsx">
import React, { createContext, useContext, useEffect, useRef, useState } from 'react';

interface AudioContextType {
  isPlaying: boolean;
  volume: number;
  userPaused: boolean;
  playMenuMusic: () => void;
  stopMenuMusic: () => void;
  pauseMenuMusic: () => void;
  setVolume: (volume: number) => void;
  toggleMusic: () => void;
  setUserPaused: (paused: boolean) => void;
  resetUserPaused: () => void;
}

const AudioContext = createContext<AudioContextType | undefined>(undefined);

export const useAudio = () => {
  const context = useContext(AudioContext);
  if (!context) {
    throw new Error('useAudio deve ser usado dentro de um AudioProvider');
  }
  return context;
};

interface AudioProviderProps {
  children: React.ReactNode;
}

export const AudioProvider: React.FC<AudioProviderProps> = ({ children }) => {
  const audioRef = useRef<HTMLAudioElement | null>(null);
  const [isPlaying, setIsPlaying] = useState(false);
  const [volume, setVolumeState] = useState(0.5);
  const [userPaused, setUserPaused] = useState(false);

  useEffect(() => {
    // Criar o elemento de áudio
    audioRef.current = new Audio('/audio/menu-music.mp3');
    audioRef.current.loop = true;
    audioRef.current.volume = volume;
    audioRef.current.preload = 'auto';

    // Event listeners
    const audio = audioRef.current;
    
    const handlePlay = () => setIsPlaying(true);
    const handlePause = () => setIsPlaying(false);
    const handleEnded = () => setIsPlaying(false);
    const handleCanPlayThrough = () => {
      // Quando o áudio estiver carregado, tentar reproduzir automaticamente
      audio.play().catch(error => {
        console.log('Autoplay bloqueado pelo navegador:', error);
      });
    };

    audio.addEventListener('play', handlePlay);
    audio.addEventListener('pause', handlePause);
    audio.addEventListener('ended', handleEnded);
    audio.addEventListener('canplaythrough', handleCanPlayThrough);

    // Cleanup
    return () => {
      audio.removeEventListener('play', handlePlay);
      audio.removeEventListener('pause', handlePause);
      audio.removeEventListener('ended', handleEnded);
      audio.removeEventListener('canplaythrough', handleCanPlayThrough);
      audio.pause();
    };
  }, []);

  const playMenuMusic = () => {
    if (audioRef.current && !isPlaying && !userPaused) {
      audioRef.current.play().catch(error => {
        console.error('Erro ao reproduzir música:', error);
      });
    }
  };

  const stopMenuMusic = () => {
    if (audioRef.current && isPlaying) {
      audioRef.current.pause();
    }
  };

  const pauseMenuMusic = () => {
    if (audioRef.current && isPlaying) {
      audioRef.current.pause();
    }
  };

  const setVolume = (newVolume: number) => {
    const clampedVolume = Math.max(0, Math.min(1, newVolume));
    setVolumeState(clampedVolume);
    if (audioRef.current) {
      audioRef.current.volume = clampedVolume;
    }
  };

  const toggleMusic = () => {
    if (isPlaying) {
      pauseMenuMusic();
      setUserPaused(true);
    } else {
      playMenuMusic();
      setUserPaused(false);
    }
  };

  const resetUserPaused = () => {
    setUserPaused(false);
  };

  const value: AudioContextType = {
    isPlaying,
    volume,
    userPaused,
    playMenuMusic,
    stopMenuMusic,
    pauseMenuMusic,
    setVolume,
    toggleMusic,
    setUserPaused,
    resetUserPaused,
  };

  return (
    <AudioContext.Provider value={value}>
      {children}
    </AudioContext.Provider>
  );
};
</file>

<file path="src/contexts/AuthContext.tsx">
// src/contexts/AuthContext.tsx - VERSÃO COMPLETA COM getAuthToken

import React, { createContext, useState, useEffect, useContext, ReactNode } from 'react';
import AuthService from '../api/authService';

interface User {
  id: number;
  username: string;
  email: string;
  nickname: string;
  first_name?: string;
  last_name?: string;
  data_nascimento?: string;
  equipe?: number; // ID da equipe, pode ser null
  // Dados adicionais que podem vir da API
  data_cadastro?: string;
  is_active?: boolean;
}

interface AuthContextType {
  user: User | null;
  loading: boolean;
  isAuthenticated: boolean;
  login: (username: string, password: string) => Promise<void>;
  logout: () => void;
  refreshUser: () => Promise<void>;
  // ✅ MÉTODO OBRIGATÓRIO para o useRanking funcionar
  getAuthToken: () => string | null;
}

const AuthContext = createContext<AuthContextType>({
  user: null,
  loading: true,
  isAuthenticated: false,
  login: async () => { },
  logout: () => { },
  refreshUser: async () => { },
  getAuthToken: () => null, // ✅ ADICIONADO
});

export const useAuth = () => useContext(AuthContext);

interface AuthProviderProps {
  children: ReactNode;
}

export const AuthProvider: React.FC<AuthProviderProps> = ({ children }) => {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);

  // ✅ FUNÇÃO OBRIGATÓRIA: Retorna o token de autenticação
  const getAuthToken = (): string | null => {
    try {
      // Tenta obter o token do localStorage primeiro
      const token = localStorage.getItem('authToken') || localStorage.getItem('access_token');

      if (token) {
        console.log('🔑 Token encontrado no localStorage');
        return token;
      }

      // Se não encontrar no localStorage, tenta do AuthService
      if (AuthService.isAuthenticated && AuthService.isAuthenticated()) {
        // Alguns AuthServices podem ter um método para obter o token atual
        if (typeof (AuthService as any).getToken === 'function') {
          const serviceToken = (AuthService as any).getToken();
          console.log('🔑 Token obtido do AuthService');
          return serviceToken;
        }
      }

      console.warn('⚠️ Token não encontrado');
      return null;
    } catch (error) {
      console.error('❌ Erro ao obter token:', error);
      return null;
    }
  };

  // Carrega o usuário quando o componente é montado
  useEffect(() => {
    const loadUser = async () => {
      if (AuthService.isAuthenticated()) {
        try {
          console.log('🔄 Carregando usuário autenticado...');
          await refreshUser();
          console.log('✅ Usuário carregado com sucesso');
        } catch (error) {
          console.error("❌ Erro ao carregar usuário:", error);
          // Se houver erro, limpa os tokens
          AuthService.logout();
        }
      } else {
        console.log('🚫 Usuário não está autenticado');
      }
      setLoading(false);
    };

    loadUser();
  }, []);

  const refreshUser = async () => {
    try {
      console.log('🔄 Atualizando dados do usuário...');
      const response = await AuthService.getProfile();

      // Log dos dados do usuário para debug
      console.log('👤 Dados do usuário:', {
        id: response.data.id,
        username: response.data.username,
        nickname: response.data.nickname,
        equipe: response.data.equipe
      });

      setUser(response.data);
    } catch (error) {
      console.error("❌ Erro ao obter perfil do usuário:", error);
      throw error;
    }
  };

  const login = async (username: string, password: string) => {
    try {
      console.log('🔐 Fazendo login para:', username);

      // Faz o login através do AuthService
      await AuthService.login({ username, password });
      console.log('✅ Login realizado com sucesso');

      // Carrega os dados do usuário
      await refreshUser();
      console.log('✅ Dados do usuário carregados após login');

    } catch (error) {
      console.error('❌ Erro no login:', error);
      throw error;
    }
  };

  const logout = () => {
    try {
      console.log('👋 Fazendo logout...');

      // Limpa os dados do AuthService
      AuthService.logout();

      // Limpa o estado do usuário
      setUser(null);

      // Limpa tokens adicionais do localStorage (se houver)
      localStorage.removeItem('authToken');
      localStorage.removeItem('access_token');
      localStorage.removeItem('refresh_token');

      console.log('✅ Logout realizado com sucesso');
    } catch (error) {
      console.error('❌ Erro no logout:', error);
    }
  };

  // ✅ VALOR DO CONTEXTO COM TODAS AS FUNÇÕES NECESSÁRIAS
  const contextValue: AuthContextType = {
    user,
    loading,
    isAuthenticated: !!user,
    login,
    logout,
    refreshUser,
    getAuthToken, // ✅ OBRIGATÓRIO para o useRanking
  };

  return (
    <AuthContext.Provider value={contextValue}>
      {children}
    </AuthContext.Provider>
  );
};

export default AuthContext;

// ✅ HOOK AUXILIAR: Para facilitar o acesso ao token em outros lugares
export const useAuthToken = (): string | null => {
  const { getAuthToken } = useAuth();
  return getAuthToken();
};

// ✅ HOOK AUXILIAR: Para verificar se o usuário tem equipe
export const useUserTeam = (): { hasTeam: boolean; teamId: number | null } => {
  const { user } = useAuth();
  return {
    hasTeam: !!user?.equipe,
    teamId: user?.equipe || null
  };
};
</file>

<file path="src/index.css">
@import url("https://fonts.googleapis.com/css2?family=Silkscreen:wght@400;700&display=swap");
@import url("https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap");

@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #242424;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

a {
  font-weight: 500;
  color: #646cff;
  text-decoration: inherit;
}
a:hover {
  color: #535bf2;
}

body {
  margin: 0;
  min-width: 320px;
  min-height: 100vh;
}

h1 {
  font-size: 3.2em;
  line-height: 1.1;
}

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #1a1a1a;
  cursor: pointer;
  transition: border-color 0.25s;
}
button:hover {
  border-color: #646cff;
}
button:focus,
button:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
}

@media (prefers-color-scheme: light) {
  :root {
    color: #213547;
    background-color: #ffffff;
  }
  a:hover {
    color: #747bff;
  }
  button {
    background-color: #f9f9f9;
  }
}

@layer base {
  html {
    font-family: "Silkscreen", sans-serif;
    font-family: "Press Start 2P", cursive;
  }
  body {
    @apply antialiased;
    image-rendering: pixelated;
  }
  :root {
    --background: 0 0% 100%;
    --foreground: 0 0% 3.9%;
    --card: 0 0% 100%;
    --card-foreground: 0 0% 3.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 0 0% 3.9%;
    --primary: 0 0% 9%;
    --primary-foreground: 0 0% 98%;
    --secondary: 0 0% 96.1%;
    --secondary-foreground: 0 0% 9%;
    --muted: 0 0% 96.1%;
    --muted-foreground: 0 0% 45.1%;
    --accent: 0 0% 96.1%;
    --accent-foreground: 0 0% 9%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 89.8%;
    --input: 0 0% 89.8%;
    --ring: 0 0% 3.9%;
    --chart-1: 12 76% 61%;
    --chart-2: 173 58% 39%;
    --chart-3: 197 37% 24%;
    --chart-4: 43 74% 66%;
    --chart-5: 27 87% 67%;
    --radius: 0.5rem;
  }
  .dark {
    --background: 0 0% 3.9%;
    --foreground: 0 0% 98%;
    --card: 0 0% 3.9%;
    --card-foreground: 0 0% 98%;
    --popover: 0 0% 3.9%;
    --popover-foreground: 0 0% 98%;
    --primary: 0 0% 98%;
    --primary-foreground: 0 0% 9%;
    --secondary: 0 0% 14.9%;
    --secondary-foreground: 0 0% 98%;
    --muted: 0 0% 14.9%;
    --muted-foreground: 0 0% 63.9%;
    --accent: 0 0% 14.9%;
    --accent-foreground: 0 0% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 14.9%;
    --input: 0 0% 14.9%;
    --ring: 0 0% 83.1%;
    --chart-1: 220 70% 50%;
    --chart-2: 160 60% 45%;
    --chart-3: 30 80% 55%;
    --chart-4: 280 65% 60%;
    --chart-5: 340 75% 55%;
  }
}
/* Estilos para o mapa Leaflet */
.leaflet-container {
  /* A largura e altura serão controladas pelo Tailwind no MapComponent.tsx */
  /* Remove width: 100%; height: 500px; daqui para usar as classes Tailwind */
}

/* Opcional: Estilos para o popup do Leaflet se quiser mais controle */
.leaflet-popup-content-wrapper {
  border-radius: 0.5rem; /* Arredonda as bordas do popup */
}
.leaflet-popup-content {
  margin: 0; /* Remove margem padrão */
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}
@layer components {
  .pixel-border {
    box-shadow: 0 0 0 2px #fff, 0 0 0 4px #000;
  }

  .pixel-button {
    @apply relative bg-amber-500 px-6 py-3 font-pixel 
    text-black font-bold border-2 border-black 
    transition-all duration-150 
    hover:brightness-110 active:brightness-90
    hover:-translate-y-1 active:translate-y-0;
  }

  .pixel-card {
    @apply bg-white border-2 border-black p-4 transition-all
    hover:shadow-[4px_4px_0px_0px_rgba(0,0,0,1)]
    hover:-translate-x-[2px] hover:-translate-y-[2px];
  }

  .pixel-cloud {
    @apply absolute opacity-75 animate-float;
  }

  .pixelated {
    image-rendering: pixelated;
  }
}
</file>

<file path="src/pages/Home/HomePage.tsx">
import { ArrowRightIcon } from "lucide-react";
import { useNavigate } from "react-router-dom";
import { Button } from "../../components/ui/button";
import { Card, CardContent } from "../../components/ui/card";
import { Separator } from "../../components/ui/separator";
import { AudioControl } from "../../components/AudioControl";

export const HomePage = () => {
  const navigate = useNavigate();

  const handleLogin = () => {
    navigate("/Login");
  };
  const handleCadastro = () => {
    navigate("/Cadastro");
  };


  return (
    <div className="bg-white flex flex-row justify-center w-full ">
      <div className="bg-white py-5 [background:linear-gradient(180deg,rgba(57,189,248,1)_0%,rgba(154,102,248,1)_100%)] w-full min-h-screen relative flex flex-col items-center justify-center">
        <div className="absolute top-14 right-[33px]">
          <AudioControl />
        </div>
        <Card className="w-[1039px] h-[455px] relative border-[3px] border-solid border-black rounded">
          <CardContent className="p-0 flex h-full">
            {/* Left purple section */}
            <div className="w-[512px] h-full bg-[#561c86] rounded border-r-[3px] border-solid border-black flex flex-col items-center px-12 py-5">
              <h1 className="[font-family:'Silkscreen',Helvetica] font-bold text-white text-[40px] text-center mt-3">
                Jogos Logisticos
              </h1>

              <Card className="w-full h-[202px] mt-8 border-[3px] border-solid border-black flex items-center justify-center bg-[#ffffff]">
                <CardContent className="p-0 flex items-center justify-center h-full">
                  <img
                    className="w-[45%] object-cover"
                    alt="Game logo"
                    src="/Logoifba.png"
                  />
                </CardContent>
              </Card>

              <p className="[font-family:'Silkscreen',Helvetica] font-normal text-white text-[15px] mt-3 text-center">
                Gerencie sua frota de caminhões, escolha
                <br />
                as melhores rotas e faça entregas com eficiência.
              </p>

            
            </div>

            {/* Right section */}
            <div className="flex-1 flex flex-col items-center px-10">
              <h2 className="[text-shadow:2px_3px_0.6px_#000000] [-webkit-text-stroke:1px_#000000] [font-family:'Silkscreen',Helvetica] font-bold text-[#ff8c00e3] text-[40px] text-center mt-5">
                Bem-vindo!
              </h2>

              <div className="w-full mt-16">
                <Button 
                onClick={handleLogin}
                className="w-full h-[58px] bg-[#ffd700] hover:bg-[#e6c200] text-[#1c1a1a] border border-solid border-black rounded-[3px] relative">
                  <span className="[font-family:'Silkscreen',Helvetica] font-bold text-2xl absolute left-1/2 transform -translate-x-1/2">
                    Entrar
                  </span>
                  <ArrowRightIcon className="absolute right-6 w-6 h-[21px]" />
                </Button>
              </div>

              <div className="w-full mt-5 flex items-center justify-center">
                <div className="[font-family:'Signika',Helvetica] font-bold text-[#8d8c8c] text-2xl">
                  <Separator className="inline-block w-[160px] h-px bg-[#8d8c8c]" />
                  <span className="mx-2">OU</span>
                  <Separator className="inline-block w-[160px] h-px bg-[#8d8c8c]" />
                </div>
              </div>

              <div className="w-full mt-10">
                <Button
                 onClick={handleCadastro}
                className="w-full h-[58px] bg-[#16bd81] hover:bg-[#14a974] text-[#1c1a1a] border border-solid border-black rounded-[3px] relative">
                  <span className="[font-family:'Silkscreen',Helvetica] font-bold text-2xl absolute left-1/2 transform -translate-x-1/2">
                    Cadastrar
                  </span>
                  <ArrowRightIcon className="absolute right-6 w-6 h-[21px]" />
                </Button>
              </div>
            </div>
          </CardContent>
        </Card>

        <footer className="mt-5 mb-10">
          <p className="[font-family:'Silkscreen',Helvetica] font-bold text-white text-[15px] text-center">
            © 2025 Jogos Logísticos - Todos os direitos reservados
          </p>
        </footer>
      </div>
    </div>
  );
};
</file>

<file path="src/pages/mapaRota/ChallengeSelector.tsx">
// Componente para seleção de desafios
import React, { useState } from 'react';
import { challenges, Challenge } from './challengesManager';
import { ChallengeId } from './constants';

interface ChallengeSelectorProps {
  onChallengeSelect: (challengeId: ChallengeId) => void;
  selectedChallenge?: ChallengeId;
}

export const ChallengeSelector: React.FC<ChallengeSelectorProps> = ({
  onChallengeSelect,
  selectedChallenge
}) => {
  return (
    <div className="bg-[#FFC06F] p-4 rounded-lg shadow-md border-2 border-black mb-6">
      <h2 className="text-xl font-['Silkscreen'] font-bold mb-3 text-black text-center border-b-2 border-black pb-2">
        SELECIONE O DESAFIO
      </h2>

      <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
        {challenges.map((challenge) => (
          <div
            key={challenge.id}
            className={`
              p-4 rounded-lg border-2 cursor-pointer transition-all duration-200
              ${selectedChallenge === challenge.id
                ? 'bg-green-500 border-green-700 text-white'
                : 'bg-white border-gray-300 hover:bg-gray-100'
              }
            `}
            onClick={() => onChallengeSelect(challenge.id)}
          >
            <h3 className="font-['Silkscreen'] font-bold text-lg mb-2">
              {challenge.name}
            </h3>
            <p className="text-sm mb-2">{challenge.description}</p>
            <div className="text-xs">
              <p><strong>Destino:</strong> {challenge.destination}</p>
              <p><strong>Dificuldade:</strong> {challenge.difficulty}</p>
              <p><strong>Duração:</strong> {challenge.estimatedDuration}</p>
              <p><strong>Rotas:</strong> {challenge.routes.length} disponíveis</p>
            </div>
          </div>
        ))}
      </div>

      {selectedChallenge && (
        <div className="mt-4 p-3 bg-green-100 border-2 border-green-500 rounded-lg">
          <p className="font-['Silkscreen'] text-green-800 text-center">
            ✅ Desafio selecionado: {challenges.find(c => c.id === selectedChallenge)?.name}
          </p>
        </div>
      )}
    </div>
  );
};
</file>

<file path="src/pages/mapaRota/challengesManager.ts">
// Gerenciador central dos desafios do jogo
// Coordena os três desafios: Salvador, Recife e Fortaleza

import { salvadorRoutes } from './challenges/salvador/routesData';
import { recifeRoutes } from './challenges/recife/routesData';
import { fortalezaRoutes } from './challenges/fortaleza/routesData';
import { Route, REFERENCE_COORDINATES, ChallengeId } from './constants';

// ChallengeId agora é importado de constants.ts

export interface Challenge {
  id: ChallengeId;
  name: string;
  description: string;
  destination: string;
  destinationCoordinates: [number, number];
  routes: Route[];
  difficulty: 'Fácil' | 'Médio' | 'Difícil';
  estimatedDuration: string;
}

export const challenges: Challenge[] = [
  {
    id: 'salvador',
    name: 'Desafio Salvador',
    description: 'Transporte de carga de Juazeiro para Salvador',
    destination: 'Salvador, BA',
    destinationCoordinates: REFERENCE_COORDINATES.SALVADOR,
    routes: salvadorRoutes,
    difficulty: 'Fácil',
    estimatedDuration: '7-8 horas'
  },
  {
    id: 'recife',
    name: 'Desafio Recife',
    description: 'Transporte de carga de Juazeiro para Recife',
    destination: 'Recife, PE',
    destinationCoordinates: REFERENCE_COORDINATES.RECIFE,
    routes: recifeRoutes,
    difficulty: 'Médio',
    estimatedDuration: '8-10 horas'
  },
  {
    id: 'fortaleza',
    name: 'Desafio Fortaleza',
    description: 'Transporte de carga de Juazeiro para Fortaleza',
    destination: 'Fortaleza, CE',
    destinationCoordinates: REFERENCE_COORDINATES.FORTALEZA,
    routes: fortalezaRoutes,
    difficulty: 'Difícil',
    estimatedDuration: '10-12 horas'
  }
];

// Função para obter um desafio específico
export const getChallenge = (challengeId: ChallengeId): Challenge | undefined => {
  return challenges.find(challenge => challenge.id === challengeId);
};

// Função para obter todas as rotas de um desafio
export const getChallengeRoutes = (challengeId: ChallengeId) => {
  const challenge = getChallenge(challengeId);
  return challenge?.routes || [];
};

// Função para obter coordenadas de destino
export const getDestinationCoordinates = (challengeId: ChallengeId): [number, number] => {
  const challenge = getChallenge(challengeId);
  return challenge?.destinationCoordinates || REFERENCE_COORDINATES.JUAZEIRO;
};

// Função de debug para testar as rotas
export const debugChallenges = () => {
  console.log("🔍 DEBUG - Testando todos os desafios:");
  challenges.forEach(challenge => {
    console.log(`- ${challenge.id}: ${challenge.name} (${challenge.routes.length} rotas)`);
    challenge.routes.forEach(route => {
      console.log(`  - ${route.name} (${route.distance}km)`);
    });
  });
};
</file>

<file path="src/pages/mapaRota/FuelModal.tsx">
// src/pages/mapaRota/FuelModal.tsx

import React, { useState } from 'react';
import { Vehicle } from '../../types/vehicle';

interface FuelModalProps {
  vehicle: Vehicle;
  availableMoney: number;
  onRefuel: (updatedVehicle: Vehicle, newBalance: number) => void;
  onClose: () => void;
}

export const FuelModal: React.FC<FuelModalProps> = ({
  vehicle,
  availableMoney,
  onRefuel,
  onClose
}) => {
  const [selectedVehicle, setSelectedVehicle] = useState<Vehicle>({ ...vehicle });
  const [fuelAmount, setFuelAmount] = useState<'full' | 'half' | 'quarter'>('full');
  const [availableBalance, setAvailableBalance] = useState(availableMoney);
  const [previewFuel, setPreviewFuel] = useState<number>(vehicle.maxCapacity); // Preview inicia com a opção 'full' selecionada

  const fuelCostPerLiter = 5.5;

  const calculateFuelCost = (option: 'full' | 'half' | 'quarter') => {
    const maxCapacity = selectedVehicle.maxCapacity;
    let fuelToAdd = 0;

    // Como o tanque sempre começa vazio, calculamos a quantidade total desejada
    switch (option) {
      case 'full':
        fuelToAdd = maxCapacity;
        break;
      case 'half':
        fuelToAdd = maxCapacity / 2;
        break;
      case 'quarter':
        fuelToAdd = maxCapacity / 4;
        break;
    }

    return fuelToAdd * fuelCostPerLiter;
  };

  const handleRefuel = () => {
    const cost = calculateFuelCost(fuelAmount);

    if (cost <= availableBalance) {
      // Calcular o novo combustível baseado na opção selecionada
      const newCurrentFuel = fuelAmount === 'full'
        ? selectedVehicle.maxCapacity
        : fuelAmount === 'half'
          ? selectedVehicle.maxCapacity / 2
          : selectedVehicle.maxCapacity / 4;

      const updatedVehicle = {
        ...selectedVehicle,
        currentFuel: newCurrentFuel
      };

      const newBalance = availableBalance - cost;

      setSelectedVehicle(updatedVehicle);
      setAvailableBalance(newBalance);

      onRefuel(updatedVehicle, newBalance);
    } else {
      alert('Saldo insuficiente para abastecer!');
    }
  };

  const calculatePreviewFuel = (option: 'full' | 'half' | 'quarter'): number => {
    const max = selectedVehicle.maxCapacity;

    switch (option) {
      case 'full':
        return max;
      case 'half':
        return max / 2;
      case 'quarter':
        return max / 4;
      default:
        return 0; // Tanque vazio por padrão
    }
  };


  return (
    <div className="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-[9999] p-4 overflow-y-auto">
      <div className="bg-[#200259] rounded-lg shadow-2xl border-4 border-black max-w-4xl w-full p-6 my-8">
        <h1 className="text-2xl font-['Silkscreen'] font-bold text-[#E3922A] text-center mb-4">
          ABASTECER VEÍCULO
        </h1>
        <p className="font-['Silkscreen'] text-white text-center text-md font-bold text-xl">
          Saldo após: R$ {(availableMoney - calculateFuelCost(fuelAmount)).toFixed(2)}
        </p>

        <div className="bg-[#FFC06F] p-4 rounded-lg shadow-md border-2 border-black mb-6">
          <div className="flex flex-col md:flex-row gap-4">
            <div className="flex justify-center items-center md:w-1/3">
              <img
                src={selectedVehicle.image}
                alt={selectedVehicle.name}
                className="h-40 object-contain"
              />
            </div>

            <div className="md:w-2/3">
              <h2 className="text-xl font-['Silkscreen'] font-bold mb-3 text-black text-center border-b-2 border-black pb-2">
                {selectedVehicle.name.toUpperCase()}
              </h2>

              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                  <h3 className="font-['Silkscreen'] text-lg font-bold text-black mb-2">CONSUMO</h3>
                  <p className="font-sans text-black text-md mb-1">- ASFALTO: {selectedVehicle.consumption.asphalt}KM/L</p>
                  <p className="font-sans text-black text-md mb-3">- TERRA: {selectedVehicle.consumption.dirt}KM/L</p>
                </div>

                <div>
                  <h3 className="font-['Silkscreen'] text-lg font-bold text-black mb-2">COMBUSTÍVEL</h3>
                  <p className="font-sans text-black text-md mb-1">ATUAL: 0L</p>
                  <p className="font-sans text-black text-md mb-3">MÁXIMO: {selectedVehicle.maxCapacity}L</p>
                </div>
              </div>

              <p className="font-sans text-black text-md mb-2">NÍVEL DO TANQUE</p>
              <div className="w-full bg-gray-200 rounded-full h-6 border-2 border-black mb-4 relative overflow-hidden shadow-inner">
                {/* Fundo branco (tanque vazio) */}
                <div className="w-full h-full bg-white rounded-full"></div>
                
                {/* Barra de preview - quantidade que será abastecida (verde) */}
                <div
                  className="bg-gradient-to-r from-green-400 via-green-500 to-green-600 h-full absolute top-0 left-0 transition-all duration-300"
                  style={{ width: `${(previewFuel / selectedVehicle.maxCapacity) * 100}%` }}
                ></div>
                
                <div className="absolute inset-0 flex items-center justify-center text-xs font-bold text-black">
                  0L → {previewFuel.toFixed(0)}L / {selectedVehicle.maxCapacity}L
                </div>
              </div>
            </div>
          </div>

          <div className="mt-4">
            <h3 className="font-['Silkscreen'] text-lg font-bold text-black mb-2">ABASTECER</h3>
            <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
              <div>
                <p className="font-sans text-black text-md mb-2">PREÇO DO DIESEL: R$ {fuelCostPerLiter.toFixed(2)}/L</p>
              </div>

              <div className="md:col-span-2">
                <div className="flex space-x-2 mb-2">
                  <button
                    onClick={() => {
                      const newPreview = calculatePreviewFuel('quarter');
                      setFuelAmount('quarter');
                      setPreviewFuel(newPreview);
                    }}
                    className={`flex-1 py-2 border-2 border-black rounded-md ${fuelAmount === 'quarter' ? 'bg-[#E3922A]' : 'bg-gray-200'}`}
                  >
                    1/4
                  </button>
                  <button
                    onClick={() => {
                      const newPreview = calculatePreviewFuel('half');
                      setFuelAmount('half');
                      setPreviewFuel(newPreview);
                    }}
                    className={`flex-1 py-2 border-2 border-black rounded-md ${fuelAmount === 'half' ? 'bg-[#E3922A]' : 'bg-gray-200'}`}
                  >
                    1/2
                  </button>
                  <button
                    onClick={() => {
                      const newPreview = calculatePreviewFuel('full');
                      setFuelAmount('full');
                      setPreviewFuel(newPreview);
                    }}
                    className={`flex-1 py-2 border-2 border-black rounded-md ${fuelAmount === 'full' ? 'bg-[#E3922A]' : 'bg-gray-200'}`}
                  >
                    CHEIO
                  </button>
                </div>
              </div>
            </div>

            <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4">
              <p className="font-sans text-black text-md font-bold text-xl">
                Custo: R$ {calculateFuelCost(fuelAmount).toFixed(2)}
              </p>

              <button
                onClick={handleRefuel}
                className="bg-[#E3922A] text-black font-bold py-2 px-4 rounded-md w-full shadow-md border-2 border-black hover:bg-[#FFC06F]"
              >
                ABASTECER
              </button>
            </div>
          </div>
        </div>

        <div className="flex justify-center">
          <button
            onClick={onClose}
            className="bg-gray-600 text-white font-bold py-3 px-8 rounded-md shadow-md border-2 border-black hover:bg-gray-700"
          >
            FECHAR
          </button>
        </div>
      </div>
    </div>
  );
};
</file>

<file path="src/pages/mapaRota/routesData.ts">
// Sistema de Rotas - Versão Limpa
// Gerencia todas as rotas dos desafios do jogo

import { challenges, getChallengeRoutes } from './challengesManager';
import { Route, ChallengeId, REFERENCE_COORDINATES, CHALLENGE_DESTINATIONS } from './constants';

// Re-exportar tipos e constantes para compatibilidade
export type { Route, ChallengeId, DirtSegment } from './constants';
export { REFERENCE_COORDINATES, CHALLENGE_DESTINATIONS } from './constants';

// ==================== FUNÇÕES PRINCIPAIS ====================

// Obter todas as rotas de um desafio específico
export const getRoutesByChallenge = (challengeId: ChallengeId): Route[] => {
  return getChallengeRoutes(challengeId);
};

// Obter rota específica por ID e desafio
export const getRoute = (challengeId: ChallengeId, routeId: number): Route | undefined => {
  const routes = getRoutesByChallenge(challengeId);
  return routes.find(route => route.routeId === routeId);
};

// Obter todas as rotas de todos os desafios
export const getAllRoutes = (): Route[] => {
  const allRoutes: Route[] = [];
  challenges.forEach(challenge => {
    allRoutes.push(...getChallengeRoutes(challenge.id));
  });
  return allRoutes;
};

// Obter informações do desafio
export const getChallengeInfo = (challengeId: ChallengeId) => {
  return challenges.find(challenge => challenge.id === challengeId);
};

// Validar se uma rota tem coordenadas válidas
export const validateRoute = (route: Route): boolean => {
  return !!(
    route.pathCoordinates &&
    route.pathCoordinates.length > 0 &&
    route.startCoordinates &&
    route.endCoordinates
  );
};

// Obter estatísticas de um desafio
export const getChallengeStats = (challengeId: ChallengeId) => {
  const routes = getRoutesByChallenge(challengeId);
  const challenge = getChallengeInfo(challengeId);

  return {
    challengeName: challenge?.name,
    totalRoutes: routes.length,
    averageDistance: routes.reduce((sum, route) => sum + route.distance, 0) / routes.length,
    averageTime: routes.reduce((sum, route) => sum + route.estimatedTimeHours, 0) / routes.length,
    destination: challenge?.destination,
    difficulty: challenge?.difficulty
  };
};

// ==================== UTILITÁRIOS ====================

// Função para converter string de tempo em horas decimais
export const parseEstimatedTime = (timeStr: string): number => {
  const timeMatch = timeStr.match(/(\d+)[hH]?(\d+)?m?i?n?/);
  if (timeMatch) {
    const hours = parseInt(timeMatch[1], 10);
    const minutes = timeMatch[2] ? parseInt(timeMatch[2], 10) : 0;
    return hours + minutes / 60;
  }

  const parts = timeStr.match(/(\d+)\s*-\s*(\d+)?h/i);
  if (parts) {
    const minHours = parseInt(parts[1], 10);
    const maxHours = parts[2] ? parseInt(parts[2], 10) : minHours;
    return (minHours + maxHours) / 2;
  }

  const singleHourMatch = timeStr.match(/(\d+)h/i);
  if (singleHourMatch) {
    return parseInt(singleHourMatch[1], 10);
  }

  return 0;
};

// ==================== COMPATIBILIDADE ====================

// Importação direta para evitar dependência circular
import { salvadorRoutes } from './challenges/salvador/routesData';

// Exportação para compatibilidade com RoutesPage
// Por padrão, retorna as rotas de Salvador (desafio principal)
export const routes = salvadorRoutes;
</file>

<file path="src/pages/PauseMenu/PauseMenu.tsx">
import { useNavigate } from "react-router-dom";
import { 
  Play, 
  User, 
  RotateCcw
} from 'lucide-react';

interface PauseMenuProps {
  isVisible: boolean;
  onResume: () => void;
  onGoToProfile?: () => void;
  onRestart?: () => void;
}

export const PauseMenu = ({ 
  isVisible, 
  onResume,
  onGoToProfile,
  onRestart
}: PauseMenuProps) => {
  const navigate = useNavigate();

  if (!isVisible) return null;

  const handleGoToProfile = () => {
    if (onGoToProfile) {
      onGoToProfile();
    } else {
      navigate("/perfil");
    }
  };

  const silkscreenFont = "[font-family:'Silkscreen',Helvetica]";
  const titleStyle = {
    color: "#E3922A",
    textShadow: "2px 3px 0.6px #000"
  };

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[9999]">
      <div className="w-full h-full [background:linear-gradient(180deg,rgba(57,189,248,0.9)_0%,rgba(154,102,248,0.9)_100%)] relative overflow-hidden flex items-center justify-center">
        
        {}
        <img
          className="w-[300px] h-[120px] absolute top-[100px] left-[50px] object-cover animate-float-right opacity-40"
          alt="Cloud decoration"
          src="/nuvemleft.png"
        />
        <img
          className="w-[350px] h-[140px] absolute bottom-[50px] right-[50px] object-cover animate-float-left opacity-40"
          alt="Cloud decoration"
          src="/nuvemright.png"
        />

        {/* Menu principal */}
        <div className="border-4 border-solid border-black rounded-lg overflow-hidden bg-white shadow-[8px_8px_0px_0px_rgba(0,0,0,1)] max-w-md w-full mx-4 relative z-10">
          <div className="p-6">
            
            {/* Título */}
            <div className="text-center mb-6">
              <h1 className={`${silkscreenFont} text-3xl font-bold`} style={titleStyle}>
                JOGO PAUSADO
              </h1>
              <div className="w-full h-1 bg-black mt-2"></div>
            </div>

            {/* Botões principais */}
            <div className="space-y-4">
              
              {/* Continuar Jogo */}
              <button
                onClick={onResume}
                className={`${silkscreenFont} w-full py-4 text-lg font-bold bg-green-500 hover:bg-green-600 text-white border-2 border-black rounded-md shadow-[4px_4px_0px_0px_rgba(0,0,0,1)] hover:shadow-[2px_2px_0px_0px_rgba(0,0,0,1)] active:shadow-none active:translate-x-[2px] active:translate-y-[2px] transition-all flex items-center justify-center`}
              >
                <Play size={20} className="mr-2" />
                CONTINUAR
              </button>

              {/* Grid de opções */}
              <div className="grid grid-cols-2 gap-4">
                
                {/* Perfil */}
                <button
                  onClick={handleGoToProfile}
                  className={`${silkscreenFont} py-4 text-sm font-bold bg-blue-500 hover:bg-blue-600 text-white border-2 border-black rounded-md shadow-[3px_3px_0px_0px_rgba(0,0,0,1)] hover:shadow-[1px_1px_0px_0px_rgba(0,0,0,1)] active:shadow-none active:translate-x-[2px] active:translate-y-[2px] transition-all flex flex-col items-center`}
                >
                  <User size={20} className="mb-1" />
                  PERFIL
                </button>

                {/* Reiniciar */}
                {onRestart && (
                  <button
                    onClick={onRestart}
                    className={`${silkscreenFont} py-4 text-sm font-bold bg-orange-500 hover:bg-orange-600 text-white border-2 border-black rounded-md shadow-[3px_3px_0px_0px_rgba(0,0,0,1)] hover:shadow-[1px_1px_0px_0px_rgba(0,0,0,1)] active:shadow-none active:translate-x-[2px] active:translate-y-[2px] transition-all flex flex-col items-center`}
                  >
                    <RotateCcw size={20} className="mb-1" />
                    REINICIAR
                  </button>
                )}
              </div>
            </div>

            {/* Dica */}
            <div className="text-center mt-6">
              <p className={`${silkscreenFont} text-xs text-gray-600`}>
                Pressione ESC para pausar/despausar
              </p>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

export default PauseMenu;
</file>

<file path="src/types/ranking.ts">
// src/types/ranking.ts - VERSÃO CORRIGIDA COM PartidaData

/**
 * Dados brutos de uma equipe como vêm da API de ranking.
 */
export interface TeamData {
  id: number;
  nome: string;
  eficiencia_media: number;
  partidas_contabilizadas: number;
  soma_eficiencia: number;
  stats: {
    partidas_total: number;
    partidas_concluidas: number;
    vitorias: number;
    derrotas: number;
    taxa_vitoria: number;
    eficiencia_media: number;
    partidas_contabilizadas: number;
    soma_eficiencia: number;
  };
}

/**
 * Dados formatados de uma equipe para uso na interface.
 */
export interface TeamRanking {
  position: number;
  name: string;
  points: number;
  victories: number;
  efficiency: number;
}

/**
 * Estatísticas resumidas da equipe do usuário logado.
 */
export interface UserStats {
  position: number;
  points: number;
  victories: number;
  efficiency: number;
}

/**
 * ✅ NOVA INTERFACE: Dados de uma partida finalizada
 */
export interface PartidaData {
  id: number;
  saldo: number;
  combustivel_atual: number;
  quantidade_carga: number;
  condicao_veiculo: number;
  estresse_motorista: number;
  tempo_real: number;
  pontuacao: number;
  distancia_percorrida: number;
  status: 'em_andamento' | 'pausado' | 'cancelada' | 'concluido';
  resultado?: 'vitoria' | 'derrota';
  motivo_finalizacao?: string;
  // Campos do sistema de eficiência
  eficiencia?: number;
  saldo_inicial?: number;
  quantidade_carga_inicial?: number;
  // Campos de tempo
  tempo_jogo?: number;
  ultima_atualizacao?: string;
  progresso?: number;
}

/**
 * Tabs disponíveis no ranking
 */
export type RankingTab = 'EFICIENCIA' | 'PONTOS' | 'VITORIAS';

/**
 * Resposta da API de ranking
 */
export type RankingApiResponse = TeamData[];
</file>

<file path="src/types/vehicle.ts">
// Definição do tipo de veículo
export interface Vehicle {
  id: string;
  name: string;
  capacity: number;
  consumption: {
    asphalt: number;
    dirt: number;
  };
  image: string;
  spriteSheet: string;
  maxCapacity: number;
  currentFuel: number;
  cost: number; // Custo do aluguel + motorista
}
</file>

<file path="src/utils/mapUtils.ts">
/**
 * Calcula a distância em km entre duas coordenadas geográficas.
 * @param coords1 - [latitude, longitude] do ponto 1
 * @param coords2 - [latitude, longitude] do ponto 2
 * @returns A distância em quilômetros.
 */
const haversineDistance = (coords1: [number, number], coords2: [number, number]): number => {
  const toRad = (x: number) => (x * Math.PI) / 180;
  const R = 6371; // Raio da Terra em km

  const dLat = toRad(coords2[0] - coords1[0]);
  const dLon = toRad(coords2[1] - coords1[1]);
  const lat1 = toRad(coords1[0]);
  const lat2 = toRad(coords2[0]);

  const a =
    Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.sin(dLon / 2) * Math.sin(dLon / 2) * Math.cos(lat1) * Math.cos(lat2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

  return R * c;
};

/**
 * Calcula a coordenada exata em uma rota com base na porcentagem de progresso total.
 * @param pathCoordinates - O array completo de coordenadas da rota.
 * @param progress - O progresso total da viagem (0 a 100).
 * @returns A coordenada [latitude, longitude] exata correspondente ao progresso.
 */
export const calculatePositionFromProgress = (
  pathCoordinates: [number, number][],
  progress: number
): [number, number] => {
  if (!pathCoordinates || pathCoordinates.length < 2) {
    return pathCoordinates?.[0] || [0, 0];
  }

  // 1. Calcula os comprimentos de cada segmento e a distância total
  const segmentLengths: number[] = [];
  let totalDistance = 0;
  for (let i = 0; i < pathCoordinates.length - 1; i++) {
    const segmentLength = haversineDistance(pathCoordinates[i], pathCoordinates[i + 1]);
    segmentLengths.push(segmentLength);
    totalDistance += segmentLength;
  }

  if (totalDistance === 0) {
    return pathCoordinates[0];
  }

  // 2. Determina a distância alvo com base no progresso
  const targetDistance = totalDistance * (progress / 100);

  // 3. Encontra o segmento correto e o fator de interpolação
  let distanceCovered = 0;
  for (let i = 0; i < segmentLengths.length; i++) {
    const currentSegmentLength = segmentLengths[i];

    // Verifica se a distância alvo está dentro deste segmento
    if (distanceCovered + currentSegmentLength >= targetDistance) {
      const distanceIntoSegment = targetDistance - distanceCovered;
      const progressInSegment = currentSegmentLength === 0 ? 0 : distanceIntoSegment / currentSegmentLength;

      const startPoint = pathCoordinates[i];
      const endPoint = pathCoordinates[i + 1];

      // 4. Interpola para encontrar as coordenadas exatas
      const lat = startPoint[0] + (endPoint[0] - startPoint[0]) * progressInSegment;
      const lng = startPoint[1] + (endPoint[1] - startPoint[1]) * progressInSegment;

      return [lat, lng];
    }
    distanceCovered += currentSegmentLength;
  }

  // Fallback para o último ponto se o progresso for 100% ou mais
  return pathCoordinates[pathCoordinates.length - 1];
};

/**
 * Retorna um array de coordenadas representando o caminho percorrido com base no progresso.
 * @param pathCoordinates - O array completo de coordenadas da rota.
 * @param progress - O progresso total da viagem (0 a 100).
 * @returns Um novo array de coordenadas representando o caminho concluído.
 */
export const calculatePathFromProgress = (
  pathCoordinates: [number, number][],
  progress: number
): [number, number][] => {
  if (!pathCoordinates || pathCoordinates.length < 2 || progress <= 0) {
    return [];
  }
  if (progress >= 100) {
    return pathCoordinates;
  }

  const segmentLengths: number[] = [];
  let totalDistance = 0;
  for (let i = 0; i < pathCoordinates.length - 1; i++) {
    const segmentLength = haversineDistance(pathCoordinates[i], pathCoordinates[i + 1]);
    segmentLengths.push(segmentLength);
    totalDistance += segmentLength;
  }

  if (totalDistance === 0) {
    return [];
  }

  const targetDistance = totalDistance * (progress / 100);
  const newPath: [number, number][] = [];
  let distanceCovered = 0;

  for (let i = 0; i < segmentLengths.length; i++) {
    const currentSegmentLength = segmentLengths[i];
    newPath.push(pathCoordinates[i]);

    if (distanceCovered + currentSegmentLength >= targetDistance) {
      const distanceIntoSegment = targetDistance - distanceCovered;
      const progressInSegment = currentSegmentLength === 0 ? 0 : distanceIntoSegment / currentSegmentLength;
      const startPoint = pathCoordinates[i];
      const endPoint = pathCoordinates[i + 1];
      const lat = startPoint[0] + (endPoint[0] - startPoint[0]) * progressInSegment;
      const lng = startPoint[1] + (endPoint[1] - startPoint[1]) * progressInSegment;
      newPath.push([lat, lng]);
      return newPath;
    }
    distanceCovered += currentSegmentLength;
  }

  return pathCoordinates;
};
</file>

<file path="src/api/teamService.ts">
// src/api/teamService.ts
import api from './config';
import { Team, TeamCreationData, TeamDetails } from '../types';

export const TeamService = {
  // Busca a lista de todas as equipes
  async getTeams(): Promise<Team[]> {
    const response = await api.get('/equipes/');
    return response.data;
  },

  // Cria uma nova equipe
  async createTeam(data: TeamCreationData): Promise<TeamDetails> {
    const response = await api.post<TeamDetails>('/equipes/', data);
    return response.data;
  },

  // Busca detalhes de uma equipe específica
  async getTeamDetails(teamId: number): Promise<TeamDetails> {
    const response = await api.get<TeamDetails>(`/equipes/${teamId}/`);
    return response.data;
  },

  // Atualiza dados da equipe
  async updateTeam(teamId: number, data: { nome: string }): Promise<TeamDetails> {
    const response = await api.patch<TeamDetails>(`/equipes/${teamId}/`, data);
    return response.data;
  },

  // Regenera código de convite
  async regenerateCode(teamId: number): Promise<{ detail: string; novo_codigo: string }> {
    const response = await api.post<{ detail: string; novo_codigo: string }>(`/equipes/${teamId}/regenerate-code/`);
    return response.data;
  },

  // Exclui a equipe
  async deleteTeam(teamId: number): Promise<void> {
    await api.delete(`/equipes/${teamId}/`);
  },

  // Faz o usuário atual entrar em uma equipe via código
  async joinTeam(code: string): Promise<{ detail: string }> {
    const response = await api.post<{ detail: string }>('/equipes/entrar/', { codigo: code });
    return response.data;
  },

  // Faz o usuário atual sair da equipe
  async leaveTeam(): Promise<{ detail: string }> {
    const response = await api.post<{ detail: string }>('/equipes/sair/');
    return response.data;
  }
};
</file>

<file path="src/pages/auth/Cadastro/Cadastro.tsx">
import { useState } from "react";
import { useNavigate } from "react-router-dom";
import { Button } from "../../../components/ui/button";
import { Card, CardContent } from "../../../components/ui/card";
import { ArrowLeft, AlertCircle } from 'lucide-react';
import { ButtonHomeBack } from "@/components/ButtonHomeBack";
import { AudioControl } from "@/components/AudioControl";
import AuthService from "../../../api/authService";

export const Cadastro = () => {
  const navigate = useNavigate();
  const [formData, setFormData] = useState({
    first_name: "",
    username: "",
    email: "",
    data_nascimento: "",
    password: "",
    password_confirm: "",
    nickname: "", // Será preenchido automaticamente com o valor do username
    last_name: ""
  });
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");
  const [success, setSuccess] = useState("");

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { id, value } = e.target;
    setFormData(prev => ({ ...prev, [id]: value }));
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    // Validação básica
    if (!formData.first_name || !formData.username || !formData.email || !formData.password || !formData.password_confirm) {
      setError("Por favor, preencha todos os campos obrigatórios");
      return;
    }

    if (formData.password !== formData.password_confirm) {
      setError("As senhas não conferem");
      return;
    }

    setLoading(true);
    setError("");
    setSuccess("");

    try {
      // Envia nickname igual ao username para satisfazer o backend
      const dataToSend = {
        ...formData,
        nickname: formData.username
      };

      await AuthService.register(dataToSend);
      setSuccess("Cadastro realizado com sucesso! Redirecionando para o login...");

      // Redireciona para o login após 2 segundos
      setTimeout(() => {
        navigate("/login");
      }, 2000);
    } catch (error: any) {
      if (error.response && error.response.data) {
        // Trata erros da API
        if (typeof error.response.data === 'object') {
          // Extrai mensagens de erro
          const errorMessages = Object.entries(error.response.data)
            .map(([key, value]) => `${key}: ${Array.isArray(value) ? value.join(", ") : value}`)
            .join("; ");
          setError(errorMessages);
        } else {
          setError("Falha ao realizar cadastro. Verifique os dados.");
        }
      } else {
        setError("Erro de conexão. Tente novamente mais tarde.");
      }
    } finally {
      setLoading(false);
    }
  };

  // 6 inputs na ordem solicitada: nome, usuário, email, data nascimento, senha, confirmar senha
  const formFields = [
    { id: "first_name", label: "NOME", type: "text" },
    { id: "username", label: "USUÁRIO", type: "text" },
    { id: "email", label: "EMAIL", type: "email" },
    { id: "data_nascimento", label: "DATA DE NASCIMENTO", type: "date" },
    { id: "password", label: "SENHA", type: "password" },
    { id: "password_confirm", label: "CONFIRMAR SENHA", type: "password" },
  ];

  return (
    <div className="bg-white flex flex-row justify-center w-full">
      <div className="w-full min-h-screen [background:linear-gradient(180deg,rgba(32,2,89,1)_0%,rgba(121,70,213,1)_100%)] relative overflow-hidden">
        {/* Nuvens com animação */}
        <img
          className="w-[375px] h-[147px] absolute top-[120px] left-[157px] object-cover animate-float-right opacity-75 scale-110"
          alt="Nuvem"
          src="/nuvemleft.png"
        />
        <img
          className="w-[436px] h-[170px] absolute bottom-[30px] right-[27px] object-cover animate-float-left opacity-75 scale-110"
          alt="Nuvem"
          src="/nuvemright.png"
        />

        {/* Botão de navegação */}
        <div className="absolute top-14 left-[33px]">
          <ButtonHomeBack onClick={() => navigate("/")}><ArrowLeft /></ButtonHomeBack>
        </div>

        {/* Controle de áudio */}
        <div className="absolute top-14 right-[33px]">
          <AudioControl />
        </div>

        {/* Card de Cadastro */}
        <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2">
          <Card className="w-[700px] rounded-[18px] border-2 border-solid border-black bg-white">
            <CardContent className="pt-8 px-[45px]">
              <h1 className="text-center text-[32px] [font-family:'Silkscreen',Helvetica] font-bold mb-8">
                CADASTRO
              </h1>

              {/* Mensagem de sucesso */}
              {success && (
                <div className="bg-green-100 border border-green-400 text-green-700 px-4 py-3 rounded relative mb-4">
                  {success}
                </div>
              )}

              {/* Mensagem de erro */}
              {error && (
                <div className="text-red-500 flex items-center gap-2 mb-4">
                  <AlertCircle size={20} />
                  <span>{error}</span>
                </div>
              )}

              <form className="space-y-4" onSubmit={handleSubmit}>
                <div className="grid grid-cols-2 gap-6">
                  {formFields.map((field) => (
                    <div key={field.id} className="space-y-2">
                      <label className="block [font-family:'Silkscreen',Helvetica] font-bold text-black text-[18px]">
                        {field.label}
                      </label>
                      <input
                        id={field.id}
                        type={field.type}
                        className="w-full h-[55px] rounded-xl border-2 border-solid border-black bg-white p-3 text-black [font-family:'Silkscreen',Helvetica]"
                        value={formData[field.id as keyof typeof formData]}
                        onChange={handleChange}
                      />
                    </div>
                  ))}
                </div>

                <div className="flex flex-col justify-between items-center pt-8">
                  <Button
                    type="submit"
                    disabled={loading}
                    className="w-[374px] h-[53px] bg-[#e3922a] rounded-md [font-family:'Silkscreen',Helvetica] font-bold text-black text-[24px] hover:bg-[#e3922a] transform transition-transform duration-300 hover:scale-105"
                  >
                    {loading ? "PROCESSANDO..." : "CADASTRAR"}
                  </Button>

                  <a
                    href="/login"
                    onClick={(e) => {
                      e.preventDefault();
                      navigate("/login");
                    }}
                    className="[font-family:'Silkscreen',Helvetica] font-normal mt-4 text-[#167dd2] text-base underline"
                  >
                    Já possui uma conta? Faça login
                  </a>
                </div>
              </form>
            </CardContent>
          </Card>
        </div>
      </div>
    </div>
  );
};
</file>

<file path="src/pages/auth/Login/Login.tsx">
import { useState } from "react";
import { useNavigate } from "react-router-dom";
import { Button } from "../../../components/ui/button";
import {
  Card,
  CardContent,
  CardHeader,
  CardTitle,
} from "../../../components/ui/card";
import { Input } from "../../../components/ui/input";
import { ArrowLeft, AlertCircle } from 'lucide-react';
import { ButtonHomeBack } from "@/components/ButtonHomeBack";
import { AudioControl } from "@/components/AudioControl";
import { useAuth } from "../../../contexts/AuthContext";

export const Login = () => {
  const navigate = useNavigate();
  const { login } = useAuth();
  const [username, setUsername] = useState("");
  const [password, setPassword] = useState("");
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");

  const handleForgotPassword = (e: React.MouseEvent) => {
    e.preventDefault();
    navigate("/forgot-password");
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    if (!username || !password) {
      setError("Por favor, preencha todos os campos");
      return;
    }

    setLoading(true);
    setError("");

    try {
      await login(username, password);
      navigate("/ranking");
    } catch (error: any) {
      console.error("Erro completo de login:", error);
      if (error.response && error.response.status === 401) {
        setError("Nome de usuário ou senha inválidos");
      } else if (error.response && error.response.data) {
        if (error.response.data.detail) {
          setError(error.response.data.detail);
        } else if (typeof error.response.data === 'object') {
          try {
            const errorMessages = Object.entries(error.response.data)
              .map(([key, value]) => Array.isArray(value) ? value.join(", ") : `${key}: ${value}`)
              .join("; ");
            setError(errorMessages);
          } catch (e) {
            setError("Falha ao realizar login. Verifique suas credenciais.");
          }
        } else {
          setError("Falha ao realizar login. Verifique suas credenciais.");
        }
      } else if (error.request) {
        setError("O servidor não respondeu. Verifique sua conexão.");
      } else {
        setError("Erro de conexão. Tente novamente mais tarde.");
      }
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="bg-white flex flex-row justify-center w-full">
      <div className="w-full min-h-screen [background:linear-gradient(180deg,rgba(32,2,89,1)_0%,rgba(121,70,213,1)_100%)] relative overflow-hidden">
        <img
          className="w-[375px] h-[147px] absolute top-[120px] left-[157px] object-cover animate-float-right"
          alt="Nuvem"
          src="/nuvemleft.png"
        />
        <img
          className="w-[436px] h-[170px] absolute bottom-[30px] right-[27px] object-cover animate-float-left opacity-75 scale-110"
          alt="Nuvem"
          src="/nuvemright.png"
        />

        <div className="absolute top-14 left-[33px]">
          <ButtonHomeBack onClick={() => navigate("/")}><ArrowLeft /></ButtonHomeBack>
        </div>

        <div className="absolute top-14 right-[33px]">
          <AudioControl />
        </div>

        <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2">
          <Card className="w-[700px] h-auto rounded-[18px] border-2 border-solid border-black bg-white">
            <CardHeader className="pb-0">
              <CardTitle className="text-[35px] text-center [font-family:'Silkscreen',Helvetica] font-bold">
                LOGIN
              </CardTitle>
            </CardHeader>
            <CardContent className="pt-1 px-[45px]">
              <form className="space-y-2" onSubmit={handleSubmit}>
                <div className="space-y-2">
                  <label
                    htmlFor="username"
                    className="block [font-family:'Silkscreen',Helvetica] font-bold text-black text-[25px]"
                  >
                    Usuário
                  </label>
                  <Input
                    id="username"
                    type="text"
                    className="h-[55px] rounded-xl border border-solid border-black [font-family:'Silkscreen',Helvetica] text-[20px]"
                    value={username}
                    onChange={(e) => setUsername(e.target.value)}
                  />
                </div>

                <div className="space-y-2">
                  <label
                    htmlFor="password"
                    className="block [font-family:'Silkscreen',Helvetica] font-bold text-black text-[25px]"
                  >
                    Senha
                  </label>
                  <Input
                    id="password"
                    type="password"
                    className="h-[55px] rounded-xl border border-solid border-black [font-family:'Silkscreen',Helvetica] text-[20px]"
                    value={password}
                    onChange={(e) => setPassword(e.target.value)}
                  />
                </div>

                {error && (
                  <div className="text-red-500 flex items-center gap-2 my-2">
                    <AlertCircle size={20} />
                    <span>{error}</span>
                  </div>
                )}

                <div className="flex justify-end">
                  <a
                    href="#"
                    onClick={handleForgotPassword}
                    className="[font-family:'Silkscreen',Helvetica] font-normal text-[#167dd2] underline text-[20px]"
                  >
                    Esqueci a senha
                  </a>
                </div>

                <div className="flex justify-between pt-4">
                  <Button
                    type="button"
                    onClick={() => navigate("/cadastro")}
                    className="w-[274px] h-[53px] bg-[#e3922a] rounded-md [font-family:'Silkscreen',Helvetica] font-bold text-black text-[25px] hover:bg-[#e3922a] transform transition-transform duration-300 hover:scale-105">
                    Cadastro
                  </Button>
                  <Button
                    type="submit"
                    disabled={loading}
                    className="w-[274px] h-[53px] bg-[#e3922a] rounded-md [font-family:'Silkscreen',Helvetica] font-bold text-black text-[25px] hover:bg-[#e3922a] transform transition-transform duration-300 hover:scale-105">
                    {loading ? "Carregando..." : "Login"}
                  </Button>
                </div>
              </form>
            </CardContent>
          </Card>
        </div>
      </div>
    </div>
  );
};
</file>

<file path="src/pages/Game-truck/GameMiniMap.tsx">
import React, { useEffect, useMemo, useRef } from 'react';
import { MapContainer, TileLayer, Polyline, Marker, useMap } from 'react-leaflet';
import 'leaflet/dist/leaflet.css';
import L from 'leaflet';
import { Vehicle } from '../../types/vehicle';
import { calculatePositionFromProgress, calculatePathFromProgress } from '../../utils/mapUtils';
// Configuração do ícone padrão do Leaflet
import defaultIcon from 'leaflet/dist/images/marker-icon.png';
import iconShadow from 'leaflet/dist/images/marker-shadow.png';

let DefaultIcon = L.icon({
  iconUrl: defaultIcon,
  shadowUrl: iconShadow,
  iconSize: [25, 41],
  iconAnchor: [12, 41],
  popupAnchor: [1, -34]
});
L.Marker.prototype.options.icon = DefaultIcon;

interface GameMiniMapProps {
  pathCoordinates: [number, number][];
  // currentPathIndex: number;
  // pathProgress: number; // 0-1 progresso dentro do segmento atual
  vehicle: Vehicle;
  progress: number; // Progresso total em porcentagem
  className?: string;
}

// Componente para atualizar a posição do caminhão
const TruckMarker: React.FC<{
  pathCoordinates: [number, number][];
  progress: number;
  vehicle: Vehicle;
}> = ({ pathCoordinates, progress, vehicle }) => {
  const markerRef = useRef<L.Marker>(null);

  const vehicleIcon = useMemo(() => {
    let imageUrl = vehicle.image;
    if (imageUrl.startsWith('/src/assets/')) {
      imageUrl = imageUrl.replace('/src/assets/', '/assets/');
    }
    if (!imageUrl.startsWith('/assets/') && !imageUrl.startsWith('http')) {
      imageUrl = `/assets/${imageUrl.split('/').pop()}`;
    }
    return L.icon({
      iconUrl: imageUrl,
      iconSize: [30, 30],
      iconAnchor: [15, 15],
      popupAnchor: [0, -15]
    });
  }, [vehicle.image]);

  // Apenas a nova lógica de cálculo deve existir aqui
  const currentPosition = useMemo(() => {
    return calculatePositionFromProgress(pathCoordinates, progress);
  }, [pathCoordinates, progress]);

  useEffect(() => {
    if (markerRef.current) {
      markerRef.current.setLatLng(currentPosition);
    }
  }, [currentPosition]);

  return (
    <Marker
      position={currentPosition}
      icon={vehicleIcon}
      ref={markerRef}
    />
  );
};

// Componente para mostrar a direção do caminhão
const TruckDirection: React.FC<{
  pathCoordinates: [number, number][];
  progress: number;
}> = ({ pathCoordinates, progress }) => {
    
  const directionPosition = useMemo(() => {
    if (!pathCoordinates || pathCoordinates.length < 2) {
      return null;
    }
    
    // Calcula a posição atual e uma posição um pouco à frente usando a mesma lógica
    const current = calculatePositionFromProgress(pathCoordinates, progress);
    const direction = calculatePositionFromProgress(pathCoordinates, Math.min(progress + 2, 100)); // 2% à frente

    return { current, direction };
  }, [pathCoordinates, progress]);

  if (!directionPosition) return null;

  return (
    <Polyline
      positions={[directionPosition.current, directionPosition.direction]}
      pathOptions={{
        color: '#ff6b35',
        weight: 3,
        opacity: 0.8,
        dashArray: '5,5'
      }}
    />
  );
};


// Componente para ajustar automaticamente o zoom do mapa
const MapViewAdjuster: React.FC<{ pathCoordinates: [number, number][] }> = ({ pathCoordinates }) => {
  const map = useMap();

  useEffect(() => {
    if (pathCoordinates && pathCoordinates.length > 1) {
      const bounds = L.latLngBounds(pathCoordinates);
      map.fitBounds(bounds, { padding: [10, 10] });
    }
  }, [map, pathCoordinates]);

  return null;
};

export const GameMiniMap: React.FC<GameMiniMapProps> = ({
  pathCoordinates,
  // currentPathIndex,
  // pathProgress,
  vehicle,
  progress,
  className = ""
}) => {
  const completedPath = useMemo(() => calculatePathFromProgress(pathCoordinates, progress), [pathCoordinates, progress]);
  // Se não há coordenadas da rota, não renderizar o mapa
  if (!pathCoordinates || pathCoordinates.length < 2) {
    return (
      <div className={`${className} flex items-center justify-center bg-gray-800 text-white text-sm`}>
        <div className="text-center">
          <div>📍 Mapa</div>
          <div>Indisponível</div>
        </div>
      </div>
    );
  }

  // Coordenadas de início e fim
  const startCoord = pathCoordinates[0];
  const endCoord = pathCoordinates[pathCoordinates.length - 1];

  return (
    <div className={className} style={{ position: 'relative' }}>

      <MapContainer
        center={startCoord}
        zoom={10}
        scrollWheelZoom={false}
        zoomControl={false}
        attributionControl={false}
        dragging={false}
        style={{ width: '100%', height: '100%', borderRadius: '50%' }}
      >
        <TileLayer
          url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
        />
        
        {/* Ajustar visualização automaticamente */}
        <MapViewAdjuster pathCoordinates={pathCoordinates} />
        
        {/* Desenhar a rota completa */}
        <Polyline
          positions={pathCoordinates}
          pathOptions={{
            color: '#0077cc',
            weight: 4,
            opacity: 0.7
          }}
        />
        
        {/* Parte da rota já percorrida */}
        {completedPath.length > 0 && (
        <Polyline
          positions={completedPath}
          pathOptions={{
            color: '#00cc66',
            weight: 5,
            opacity: 0.9
          }}
        />
      )}
        
        {/* Marcadores de início e fim */}
        <Marker
          position={startCoord}
          icon={L.icon({
            iconUrl: 'https://cdn-icons-png.flaticon.com/512/684/684908.png',
            iconSize: [20, 20],
            iconAnchor: [10, 10]
          })}
        />
        
        <Marker
          position={endCoord}
          icon={L.icon({
            iconUrl: 'https://cdn-icons-png.flaticon.com/512/684/684879.png',
            iconSize: [20, 20],
            iconAnchor: [10, 10]
          })}
        />
        
        {/* Caminhão na posição atual */}
        <TruckMarker
          pathCoordinates={pathCoordinates}
          progress={progress}
          vehicle={vehicle}
        />

        {/* Direção do caminhão */}
        <TruckDirection
          pathCoordinates={pathCoordinates}
          progress={progress}
        />
      </MapContainer>
    </div>
  );
};
</file>

<file path="src/pages/GameSelection/GameSelectionPage.tsx">
// arquivo: src/pages/GameSelection/GameSelectionPage.tsx

import React from 'react';
import { useNavigate } from "react-router-dom";
import { useQuery } from '@tanstack/react-query';
import GameCard from './components/GameCard';
import PixelHeading from './components/PixelHeading';
import Footer from './components/Footer';
import { ArrowLeft, ImageIcon, Loader, AlertTriangle } from 'lucide-react';
import { ButtonHomeBack } from '@/components/ButtonHomeBack';
import { AudioControl } from '@/components/AudioControl';
import { GameService } from '@/api/gameService';
import { Map as Desafio } from '@/types'; // O tipo Map representa um Desafio

// 1. DADOS ESTÁTICOS DOS JOGOS (mockado como você pediu)
const gamesData = [
  {
    id: 'entrega_eficiente', // ID para controle interno
    title: "ENTREGA EFICIENTE", // Título do JOGO que será exibido
    description: "GERENCIE SUA FROTA DE CAMINHÕES, ESCOLHA AS MELHORES ROTAS E FAÇA ENTREGAS COM EFICIÊNCIA.",
    borderColor: 'border-yellow-500',
    buttonBgColor: 'bg-yellow-500',
    buttonHoverColor: 'hover:bg-yellow-600',
    isActive: true,
  },
  {
    id: 'centro_distribuicao',
    title: "Centro de Distribuição",
    description: "Gerencie o fluxo de produtos em seu centro de distribuição, otimizando a logística e reduzindo custos.",
    borderColor: 'border-green-400',
    buttonBgColor: 'bg-green-300',
    buttonHoverColor: 'hover:bg-green-400',
    isActive: false,
  },
  {
    id: 'gestao_estoque',
    title: "Gestão de Estoque",
    description: "Gerencie o estoque de produtos, otimizando a distribuição e reduzindo custos.",
    borderColor: 'border-blue-400',
    buttonBgColor: 'bg-blue-300',
    buttonHoverColor: 'hover:bg-blue-400',
    isActive: false,
  },
];

const GameSelectionPage = () => {
  const navigate = useNavigate();

  // 2. A API continua buscando os DESAFIOS disponíveis nos bastidores.
  const { data: desafios, isLoading, isError } = useQuery<Desafio[]>({
    queryKey: ['mapas'],
    queryFn: GameService.getMaps,
  });

  // 3. Lógica de clique corrigida.
  const handleGameClick = (gameId: string) => {
    // Verifica se o jogo clicado é o 'entrega_eficiente'
    if (gameId === 'entrega_eficiente') {
      // Pega o primeiro (e único) desafio que veio da API
      if (desafios && desafios.length > 0) {
        const primeiroDesafio = desafios[0];
        // Navega para o tutorial passando o ID do DESAFIO vindo do backend
        navigate('/tutorial', { state: { mapaId: primeiroDesafio.id } });
      } else if (!isLoading) {
         alert("Nenhum desafio encontrado para este jogo. Verifique o backend.");
      }
    } else {
      // Para outros jogos, o comportamento é o mesmo
      const game = gamesData.find(g => g.id === gameId);
      alert(`O jogo "${game?.title}" ainda está em desenvolvimento!`);
    }
  };

  return (
    <div
      className="min-h-screen bg-gradient-to-b from-purple-900 to-indigo-800 flex flex-col items-center justify-between py-12 px-4"
      style={{ fontFamily: "'Press Start 2P', cursive" }}
    >
      <div className="flex gap-5 absolute top-14 left-[33px]">
        <ButtonHomeBack onClick={() => navigate(-1)}><ArrowLeft /></ButtonHomeBack>
      </div>
      
      <div className="absolute top-14 right-[33px]">
        <AudioControl />
      </div>

      <div className="w-full max-w-6xl flex flex-col items-center">
        <PixelHeading text="ESCOLHA SEU JOGO" className="mb-12 mt-8" />

        {isLoading && (
            <div className="text-white text-lg flex items-center">
                <Loader className="mr-2 animate-spin" /> Carregando desafios...
            </div>
        )}

        {isError && (
            <div className="text-red-400 text-lg flex items-center">
                <AlertTriangle className="mr-2" /> Erro ao carregar desafios.
            </div>
        )}

        {/* 4. A renderização volta a usar 'gamesData' (a lista estática) para exibir os cards. */}
        <div className="grid grid-cols-1 md:grid-cols-3 gap-8 w-full">
          {gamesData.map((game) => (
            <GameCard
              key={game.id}
              title={game.title}
              description={game.description}
              isActive={game.isActive}
              onClick={() => game.isActive && handleGameClick(game.id)}
              borderColor={game.borderColor}
              buttonBgColor={game.buttonBgColor}
              buttonHoverColor={game.buttonHoverColor}
              icon={<ImageIcon className="w-12 h-12" />}
            />
          ))}
        </div>
      </div>

      <Footer />
    </div>
  );
};

export default GameSelectionPage;
</file>

<file path="src/pages/mapaRota/constants.ts">
// Constantes e tipos compartilhados do sistema de rotas

// ==================== COORDENADAS DE REFERÊNCIA ====================

export const REFERENCE_COORDINATES = {
  JUAZEIRO: [-9.449771, -40.524226] as [number, number],
  SALVADOR: [-12.954121, -38.471283] as [number, number],
  RECIFE: [-8.058010135275913, -34.883122118554674] as [number, number],
  FORTALEZA: [-3.731862, -38.526669] as [number, number]
};

// Mapeamento de desafios para coordenadas de destino
export const CHALLENGE_DESTINATIONS = {
  salvador: REFERENCE_COORDINATES.SALVADOR,
  recife: REFERENCE_COORDINATES.RECIFE,
  fortaleza: REFERENCE_COORDINATES.FORTALEZA
} as const;

// ==================== TIPOS ====================

export type ChallengeId = 'salvador' | 'recife' | 'fortaleza';

// Interface para segmentos de estrada de terra
export interface DirtSegment {
  startKm: number;
  endKm: number;
  condition: 'leve' | 'moderada' | 'severa';
  eventChance: number;
  speedFactor: number;
  description?: string;
}

// Interface principal para rotas
export interface Route {
  routeId: number;
  challengeId: ChallengeId;
  name: string;
  distance: number;
  estimatedTime: string;
  estimatedTimeHours: number;
  cities: string[];
  roads: string[];
  startCoordinates: [number, number];
  endCoordinates: [number, number];
  waypoints?: [number, number][];
  
  // Informações de pedágios
  tollBooths?: {
    totalCost: number;
    location: string;
    costPerAxle: number;
    totalCostExample4Axles: number;
    coordinates: [number, number];
  }[];

  // Limites de velocidade
  speedLimits?: {
    road: string;
    limit: string;
    value?: number;
    coordinates?: [number, number];
  }[];

  // Informações de segurança
  safety?: {
    robberyRisk: 'Baixo' | 'Médio' | 'Alto';
    roadHazards: string;
  };

  // Condições da estrada
  dirtRoad?: boolean;
  dirtRoadDetails?: string;
  roadConditions?: 'Boa' | 'Regular' | 'Ruim';
  constructionZones?: string;

  // Pontos de interesse
  pois?: {
    type: 'construction' | 'danger' | 'rest' | 'gas';
    location: string;
    description: string;
    coordinates: [number, number];
  }[];

  restStops?: {
    location: string;
    description: string;
    coordinates: [number, number];
    type: 'rest' | 'construction' | 'gas' | 'toll' | 'danger';
  }[];

  // Postos de gasolina
  fuelStop?:{
    locationName: string;
    coordinates:[number, number]
  }[];

  // Custos e coordenadas do percurso
  fuelCostPerKm?: number;
  dangerZonesDetails?: string;
  pathCoordinates?: number[][];
  actualDistance?: number;
  actualDuration?: number;

  // Zonas de perigo
  dangerZones?: {
    location: string;
    startKm: number;
    description: string;
    coordinates: [number, number];
    riskLevel: 'Baixo' | 'Médio' | 'Alto';
  }[];

  dirtSegments?: DirtSegment[];
}

// ==================== UTILITÁRIOS ====================

// Função para converter string de tempo em horas decimais
export const parseEstimatedTime = (timeStr: string): number => {
  // Formato "7h30min" ou "7H30"
  const timeMatch = timeStr.match(/(\d+)[hH]?(\d+)?m?i?n?/);
  if (timeMatch) {
    const hours = parseInt(timeMatch[1], 10);
    const minutes = timeMatch[2] ? parseInt(timeMatch[2], 10) : 0;
    return hours + minutes / 60;
  }

  // Formato "7-8h" (range)
  const parts = timeStr.match(/(\d+)\s*-\s*(\d+)?h/i);
  if (parts) {
    const minHours = parseInt(parts[1], 10);
    const maxHours = parts[2] ? parseInt(parts[2], 10) : minHours;
    return (minHours + maxHours) / 2;
  }

  // Formato simples "7h"
  const singleHourMatch = timeStr.match(/(\d+)h/i);
  if (singleHourMatch) {
    return parseInt(singleHourMatch[1], 10);
  }

  return 0;
};
</file>

<file path="src/pages/Perfil/CriarEquipe.tsx">
import { useNavigate } from "react-router-dom";
import { useState } from "react";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { Button } from "../../components/ui/button";
import { Card, CardContent } from "../../components/ui/card";
import { ArrowLeft, Settings, Crown, UserPlus } from 'lucide-react';
import { TeamService } from "../../api/teamService";
import { useAuth } from "../../contexts/AuthContext";

export const CriarEquipePage = () => {
  const navigate = useNavigate();
  const queryClient = useQueryClient();
  const { user, refreshUser } = useAuth();

  const [teamName, setTeamName] = useState("");
  const [description, setDescription] = useState("");

  const handleNavigateBack = () => {
    navigate("/choose-team");
  };

  const createTeamMutation = useMutation({
    mutationFn: (data: { nome: string; descricao?: string }) =>
      TeamService.createTeam(data),
    onSuccess: async (novaEquipe) => {
      alert(`Equipe "${novaEquipe.nome}" criada com sucesso!`);
      await refreshUser();
      queryClient.invalidateQueries({ queryKey: ['teams'] });
      navigate("/game-selection");
    },
    onError: (error: any) => {
      const errorMessage = error.response?.data?.detail ||
        error.response?.data?.nome?.[0] ||
        "Erro ao criar equipe.";
      alert(`Erro: ${errorMessage}`);
    }
  });

  const handleCreateTeam = () => {
    if (!teamName.trim()) {
      alert("O nome da equipe é obrigatório.");
      return;
    }

    createTeamMutation.mutate({
      nome: teamName,
      descricao: description || undefined
    });
  };

  // Loading do contexto de autenticação
  if (!user) {
    return (
      <div className="bg-white flex flex-row justify-center w-full">
        <div className="w-full min-h-screen [background:linear-gradient(180deg,rgba(57,189,248,1)_0%,rgba(154,102,248,1)_100%)] relative overflow-hidden flex items-center justify-center">
          <Card className="border-2 border-solid border-black rounded-lg overflow-hidden bg-white shadow-[4px_4px_0px_0px_rgba(0,0,0,1)] p-8">
            <div className="text-center">
              <div className="animate-spin rounded-full h-8 w-8 border-2 border-blue-500 border-t-transparent mx-auto mb-4"></div>
              <p>Carregando...</p>
            </div>
          </Card>
        </div>
      </div>
    );
  }

  // Verificar se usuário já está em uma equipe
  if (user?.equipe) {
    return (
      <div className="bg-white flex flex-row justify-center w-full">
        <div className="w-full min-h-screen [background:linear-gradient(180deg,rgba(57,189,248,1)_0%,rgba(154,102,248,1)_100%)] relative overflow-hidden flex items-center justify-center">
          <Card className="border-2 border-solid border-black rounded-lg overflow-hidden bg-white shadow-[4px_4px_0px_0px_rgba(0,0,0,1)] p-8">
            <div className="text-center">
              <h2 className="text-xl font-bold mb-4">Você já faz parte de uma equipe!</h2>
              <p className="mb-6">Você não pode criar uma nova equipe enquanto estiver em outra.</p>
              <Button onClick={() => navigate("/perfil")} className="bg-blue-500 hover:bg-blue-600 text-white">
                Ir para Perfil
              </Button>
            </div>
          </Card>
        </div>
      </div>
    );
  }

  const silkscreenFont = "[font-family:'Silkscreen',Helvetica]";
  const inputStyle = `bg-white border-2 border-black rounded-md p-2 w-full ${silkscreenFont} text-sm focus:outline-none focus:ring-2 focus:ring-blue-400`;
  const labelStyle = `text-xs ${silkscreenFont} mb-1 block text-black font-bold`;
  const buttonBaseStyle = `${silkscreenFont} border-2 border-black rounded-md px-4 py-2 text-xs font-bold flex items-center justify-center transition-all`;

  return (
    <div className="bg-white flex flex-row justify-center w-full">
      <div className={`w-full min-h-screen [background:linear-gradient(180deg,rgba(57,189,248,1)_0%,rgba(154,102,248,1)_100%)] relative overflow-hidden ${silkscreenFont}`}>
        {/* Decorative clouds */}
        <img
          className="w-[375px] h-[147px] absolute top-[80px] left-[calc(50%_-_650px)] object-cover animate-float-right opacity-80"
          alt="Cloud decoration left"
          src="/nuvemleft.png"
        />
        <img
          className="w-[436px] h-[170px] absolute bottom-[30px] right-[calc(50%_-_700px)] object-cover animate-float-left opacity-75 scale-110"
          alt="Cloud decoration right"
          src="/nuvemright.png"
        />

        {/* Back button */}
        <div className="absolute top-4 left-4 z-20">
          <Button onClick={handleNavigateBack} variant="outline" className="p-2 bg-white border-2 border-black rounded-md hover:bg-gray-200">
            <ArrowLeft size={24} className="text-black" />
          </Button>
        </div>

        {/* Main content */}
        <div className="max-w-4xl mx-auto pt-16 pb-8 px-4 relative z-10">
          <Card className="border-2 border-solid border-black rounded-lg overflow-hidden bg-white shadow-[4px_4px_0px_0px_rgba(0,0,0,1)]">
            <CardContent className="p-6">
              {/* Header */}
              <div className="text-center mb-6">
                <h1 className={`${silkscreenFont} text-xl font-bold text-[#E3922A] border-2 border-black bg-gray-100 py-2 px-4 rounded-md inline-block`}>
                  CRIAR EQUIPE
                </h1>
              </div>

              {/* FORMULÁRIO PRINCIPAL */}
              <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                {/* Left column - Team info */}
                <div className="space-y-4">
                  {/* Team name */}
                  <div>
                    <label htmlFor="teamName" className={labelStyle}>
                      NOME DA EQUIPE
                    </label>
                    <input
                      type="text"
                      name="teamName"
                      id="teamName"
                      value={teamName}
                      onChange={(e) => setTeamName(e.target.value)}
                      placeholder="DIGITE O NOME DA EQUIPE"
                      className={inputStyle}
                      disabled={createTeamMutation.isPending}
                    />
                  </div>

                  {/* Description */}
                  <div>
                    <label htmlFor="description" className={labelStyle}>
                      DESCRIÇÃO (OPCIONAL)
                    </label>
                    <textarea
                      name="description"
                      id="description"
                      value={description}
                      onChange={(e) => setDescription(e.target.value)}
                      placeholder="DIGITE UMA DESCRIÇÃO PARA A EQUIPE"
                      className={`${inputStyle} h-20 resize-none`}
                      disabled={createTeamMutation.isPending}
                    />
                  </div>

                  {/* Invite code */}
                  <div>
                    <label htmlFor="inviteCode" className={labelStyle}>
                      CÓDIGO DE INVITE
                    </label>
                    <div className="flex gap-2">
                      <input
                        type="text"
                        name="inviteCode"
                        id="inviteCode"
                        value="Será gerado automaticamente"
                        readOnly
                        disabled
                        className={`${inputStyle} flex-1 bg-gray-100 text-gray-500`}
                      />
                    </div>
                    <p className={`text-xs text-gray-500 mt-1 ${silkscreenFont}`}>
                      O código será gerado automaticamente após a criação da equipe
                    </p>
                  </div>

                  {/* Team members */}
                  <div>
                    <label className={labelStyle}>
                      MEMBROS DA EQUIPE
                    </label>
                    <div className="space-y-2 max-h-60 overflow-y-auto">
                      <div className="flex items-center gap-3 bg-gray-50 border-2 border-black rounded-md p-3">
                        <img
                          src={"/mario.png"}
                          alt={`Avatar de ${user?.nickname || 'Usuário'}`}
                          className="w-12 h-12 rounded-full border-2 border-black object-cover"
                        />
                        <div className="flex-1">
                          <div className="flex items-center gap-2">
                            <Crown size={16} className="text-yellow-500" />
                            <span className={`${silkscreenFont} text-sm font-bold text-black`}>
                              {user?.nickname?.toUpperCase() || 'LÍDER'}
                            </span>
                          </div>
                          {/* Remover menção a nível e XP */}
                        </div>
                        <div className={`${silkscreenFont} text-xs text-yellow-600 font-bold`}>
                          LÍDER
                        </div>
                      </div>
                    </div>
                    <p className={`text-xs text-gray-500 mt-2 ${silkscreenFont}`}>
                      Você pode adicionar mais membros após criar a equipe
                    </p>
                  </div>
                </div>

                {/* Right column - Additional info */}
                <div className="space-y-4">
                  <div>
                    <label className={`${labelStyle} mb-3`}>
                      <UserPlus size={16} className="inline mr-2" />
                      INFORMAÇÕES ADICIONAIS
                    </label>

                    <div className="bg-gray-50 border-2 border-black rounded-md p-4">
                      <p className={`${silkscreenFont} text-sm text-black mb-4`}>
                        AO CRIAR UMA EQUIPE:
                      </p>

                      <ul className="space-y-3">
                        <li className="flex items-start gap-2">
                          <span className="text-green-500 font-bold">•</span>
                          <span className={`${silkscreenFont} text-xs text-gray-700`}>
                            VOCÊ SERÁ O LÍDER DA EQUIPE
                          </span>
                        </li>
                        <li className="flex items-start gap-2">
                          <span className="text-green-500 font-bold">•</span>
                          <span className={`${silkscreenFont} text-xs text-gray-700`}>
                            PODERÁ CONVIDAR OUTROS JOGADORES PARA PARTICIPAR
                          </span>
                        </li>
                        <li className="flex items-start gap-2">
                          <span className="text-green-500 font-bold">•</span>
                          <span className={`${silkscreenFont} text-xs text-gray-700`}>
                            COMPETIR EM RANKINGS E DESAFIOS EM GRUPO
                          </span>
                        </li>
                        <li className="flex items-start gap-2">
                          <span className="text-green-500 font-bold">•</span>
                          <span className={`${silkscreenFont} text-xs text-gray-700`}>
                            GANHAR RECOMPENSAS EXCLUSIVAS PARA EQUIPES
                          </span>
                        </li>
                      </ul>
                    </div>
                  </div>
                </div>
              </div>

              {/* Create button */}
              <div className="flex justify-center mt-8">
                <Button
                  onClick={handleCreateTeam}
                  disabled={!teamName.trim() || createTeamMutation.isPending}
                  className={`${buttonBaseStyle} px-8 py-3 bg-[#29D8FF] hover:bg-[#20B4D2] text-black shadow-[2px_2px_0px_0px_rgba(0,0,0,1)] hover:shadow-[1px_1px_0px_0px_rgba(0,0,0,1)] active:shadow-none active:translate-x-[2px] active:translate-y-[2px] disabled:opacity-50 disabled:cursor-not-allowed`}
                >
                  {createTeamMutation.isPending ? (
                    <>
                      <div className="animate-spin rounded-full h-4 w-4 border-2 border-black border-t-transparent mr-2"></div>
                      CRIANDO...
                    </>
                  ) : (
                    <>
                      <Settings size={18} className="mr-2" />
                      CRIAR EQUIPE
                    </>
                  )}
                </Button>
              </div>
            </CardContent>
          </Card>
        </div>
      </div>
    </div>
  );
};

export default CriarEquipePage;
</file>

<file path="src/pages/Perfil/EditarPerfil.tsx">
import { useNavigate } from "react-router-dom";
import { useState, useRef, useEffect } from "react";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { useAuth } from "../../contexts/AuthContext";
import AuthService from "../../api/authService";
import { TeamService } from "../../api/teamService";
import { Button } from "../../components/ui/button";
import {
  Card,
  CardContent,
} from "../../components/ui/card";
import {
  ArrowLeft,
  Camera,
  Trophy,
  Edit3,
  LogOut,
  Trash2,
  KeyRound,
  ChevronDown,
  Users,
} from 'lucide-react';

interface UserEditData {
  first_name: string;
  last_name: string;
  email: string;
  data_nascimento?: string;
}

export const EditarPerfilPage = () => {
  const navigate = useNavigate();
  const fileInputRef = useRef<HTMLInputElement>(null);
  const { user, refreshUser, logout } = useAuth();
  const queryClient = useQueryClient();

  // Estado para os dados editáveis
  const [userData, setUserData] = useState<UserEditData>({
    first_name: '',
    last_name: '',
    email: '',
    data_nascimento: ''
  });

  // Estado para avatar local (funcionalidade futura)
  const [localAvatar, setLocalAvatar] = useState<string>("/mario.png");

  // Carrega dados do usuário quando componente monta
  useEffect(() => {
    if (user) {
      // Converter data para formato YYYY-MM-DD se necessário
      let dataFormatada = '';
      if (user.data_nascimento) {
        // Se vier no formato DD/MM/YYYY, converter para YYYY-MM-DD
        if (user.data_nascimento.includes('/')) {
          const [dia, mes, ano] = user.data_nascimento.split('/');
          dataFormatada = `${ano}-${mes.padStart(2, '0')}-${dia.padStart(2, '0')}`;
        }
        // Se vier no formato YYYY-MM-DD, usar direto
        else if (user.data_nascimento.includes('-')) {
          dataFormatada = user.data_nascimento;
        }
        // Outros formatos
        else {
          dataFormatada = user.data_nascimento;
        }
      }

      setUserData({
        first_name: user.first_name || '',
        last_name: user.last_name || '',
        email: user.email || '',
        data_nascimento: dataFormatada
      });
    }
  }, [user]);

  // Mutation para atualizar perfil
  const updateProfileMutation = useMutation({
    mutationFn: (data: UserEditData) => {
      console.log('🌐 DEBUG - Enviando requisição PATCH para /auth/perfil/ com:', data);
      return AuthService.updateProfile(data);
    },
    onSuccess: async (response) => {
      console.log('✅ DEBUG - Resposta de sucesso do backend:', response.data);

      // Atualiza os dados no contexto
      await refreshUser();

      console.log('🔄 DEBUG - Usuário atualizado no contexto');

      // Invalida queries relacionadas
      queryClient.invalidateQueries({ queryKey: ['profile'] });

      // Mostra sucesso e navega
      alert("Alterações salvas com sucesso!");
      navigate("/perfil");
    },
    onError: (error: any) => {
      console.error("❌ DEBUG - Erro completo:", error);
      console.error("❌ DEBUG - Resposta do servidor:", error.response?.data);
      console.error("❌ DEBUG - Status do erro:", error.response?.status);

      const errorMessage = error.response?.data?.detail ||
        error.response?.data?.message ||
        JSON.stringify(error.response?.data) ||
        "Erro ao salvar alterações";
      alert(`Erro: ${errorMessage}`);
    }
  });

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement>) => {
    const { name, value } = e.target;
    setUserData(prev => ({ ...prev, [name]: value }));
  };

  const handlePhotoUpload = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (file && file.type.startsWith('image/')) {
      const reader = new FileReader();
      reader.onload = (e) => {
        const result = e.target?.result;
        if (typeof result === 'string') {
          setLocalAvatar(result);
        }
      };
      reader.readAsDataURL(file);
    } else {
      alert('Por favor, selecione apenas arquivos de imagem.');
    }
  };

  const handleClickUpload = () => {
    fileInputRef.current?.click();
  };

  const handleSalvarAlteracoes = () => {
    console.log('💾 DEBUG - Iniciando salvamento com dados:', userData);

    // Valida dados básicos
    if (!userData.email.trim()) {
      alert("Email é obrigatório!");
      return;
    }

    // Prepara dados para envio (remove campos vazios)
    const dataToSend: Partial<UserEditData> = {};

    if (userData.first_name.trim()) dataToSend.first_name = userData.first_name.trim();
    if (userData.last_name.trim()) dataToSend.last_name = userData.last_name.trim();
    if (userData.email.trim()) dataToSend.email = userData.email.trim();
    if (userData.data_nascimento?.trim()) dataToSend.data_nascimento = userData.data_nascimento.trim();

    console.log('📤 DEBUG - Dados que serão enviados para o backend:', dataToSend);

    updateProfileMutation.mutate(dataToSend as UserEditData);
  };

  const handleNavigateBack = () => {
    navigate(-1);
  };

  const handleTeamSettings = () => {
    navigate("/perfil/editar-equipe");
  };

  const handleSairDaEquipe = async () => {
    if (!user?.equipe) return;
    if (!window.confirm("Tem certeza que deseja sair da equipe?")) return;
    try {
      await TeamService.leaveTeam();
      await refreshUser();
      alert("Você saiu da equipe com sucesso!");
      navigate("/perfil");
    } catch (error) {
      alert("Erro ao sair da equipe. Tente novamente.");
    }
  };

  const handleExcluirEquipe = () => {
    navigate("/perfil/excluir-equipe");
  };

  const handleChangePassword = () => {
    navigate("/mudar-senha");
  };

  const handleLogout = () => {
    logout();
    navigate("/login");
  };

  // Se não há usuário logado, redireciona
  if (!user) {
    navigate("/login");
    return null;
  }

  const silkscreenFont = "[font-family:'Silkscreen',Helvetica]";
  const inputStyle = `bg-white border-2 border-black rounded-md p-2 w-full ${silkscreenFont} text-sm focus:outline-none focus:ring-2 focus:ring-yellow-400`;
  const labelStyle = `text-xs ${silkscreenFont} mb-1 block text-black`;
  const buttonBaseStyle = `${silkscreenFont} border-2 border-black rounded-md px-4 py-2 text-xs font-bold flex items-center justify-center`;

  return (
    <div className="bg-white flex flex-row justify-center w-full h-screen overflow-hidden">
      <div className={`w-full h-full [background:linear-gradient(180deg,rgba(57,189,248,1)_0%,rgba(154,102,248,1)_100%)] relative overflow-hidden ${silkscreenFont}`}>
        {/* Decorative clouds */}
        <img
          className="w-[375px] h-[147px] absolute top-[80px] left-[calc(50%_-_650px)] object-cover animate-float-right opacity-80"
          alt="Cloud decoration left"
          src="/nuvemleft.png"
        />
        <img
          className="w-[436px] h-[170px] absolute bottom-[30px] right-[calc(50%_-_700px)] object-cover animate-float-left opacity-75 scale-110"
          alt="Cloud decoration right"
          src="/nuvemright.png"
        />

        {/* Hidden file input */}
        <input
          type="file"
          ref={fileInputRef}
          onChange={handlePhotoUpload}
          accept="image/*"
          className="hidden"
        />

        {/* Back button */}
        <div className="absolute top-4 left-4 z-20">
          <Button onClick={handleNavigateBack} variant="outline" className="p-2 bg-white border-2 border-black rounded-md hover:bg-gray-200">
            <ArrowLeft size={24} className="text-black" />
          </Button>
        </div>

        {/* Main content */}
        <div className="h-full flex items-center justify-center px-4 py-4 relative z-10">
          <div className="w-full max-w-4xl h-full">
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6 h-full">

              {/* Left column - User profile */}
              <Card className="border-2 border-solid border-black rounded-lg overflow-hidden bg-white shadow-[4px_4px_0px_0px_rgba(0,0,0,1)] h-full">
                <CardContent className="p-4 md:p-5 h-full overflow-y-auto">
                  <div className="text-center mb-4">
                    {/* Avatar section */}
                    <div className="mt-1 flex justify-center">
                      <div className="relative">
                        <div className="w-28 h-28 rounded-full bg-[#00FFFF] border-2 border-black flex items-center justify-center overflow-hidden relative group">
                          {localAvatar === "/mario.png" && user.first_name ? (
                            <span className="text-5xl font-bold text-white select-none">
                              {user.first_name.charAt(0).toUpperCase()}
                            </span>
                          ) : (
                            <img
                              src={localAvatar}
                              alt="Avatar"
                              className="w-24 h-24 object-cover rounded-full"
                            />
                          )}
                          <div
                            className="absolute inset-0 bg-black bg-opacity-40 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity duration-200 cursor-pointer rounded-full"
                            onClick={handleClickUpload}
                          >
                            <Camera size={28} className="text-white" />
                          </div>
                        </div>
                      </div>
                    </div>

                    <h3 className={`${silkscreenFont} font-bold text-black text-lg mt-3`}>
                      {(user.nickname || user.username).toUpperCase()}
                    </h3>

                  </div>

                  {/* Form fields */}
                  <div className="space-y-3 mt-4">
                    <div>
                      <label htmlFor="first_name" className={labelStyle}>NOME</label>
                      <input
                        type="text"
                        name="first_name"
                        id="first_name"
                        value={userData.first_name}
                        onChange={handleInputChange}
                        className={inputStyle}
                        placeholder="Seu primeiro nome"
                      />
                    </div>
                    <div>
                      <label htmlFor="last_name" className={labelStyle}>SOBRENOME</label>
                      <input
                        type="text"
                        name="last_name"
                        id="last_name"
                        value={userData.last_name}
                        onChange={handleInputChange}
                        className={inputStyle}
                        placeholder="Seu sobrenome"
                      />
                    </div>
                    <div>
                      <label className={labelStyle}>USUÁRIO (não pode ser alterado)</label>
                      <input
                        type="text"
                        value={user.nickname || user.username}
                        className={`${inputStyle} bg-gray-200 cursor-not-allowed opacity-70`}
                        disabled
                        readOnly
                      />
                    </div>
                    <div>
                      <label htmlFor="email" className={labelStyle}>EMAIL</label>
                      <input
                        type="email"
                        name="email"
                        id="email"
                        value={userData.email}
                        onChange={handleInputChange}
                        className={inputStyle}
                        placeholder="seu@email.com"
                        required
                      />
                    </div>
                    <div>
                      <label htmlFor="data_nascimento" className={labelStyle}>DATA DE NASCIMENTO</label>
                      <input
                        type="date"
                        name="data_nascimento"
                        id="data_nascimento"
                        value={userData.data_nascimento}
                        onFocus={() => console.log('📅 DEBUG - Data atual no campo:', userData.data_nascimento)}
                        onChange={(e) => {
                          console.log('📅 DEBUG - Nova data selecionada:', e.target.value);
                          handleInputChange(e);
                        }}
                        className={inputStyle}
                      />
                    </div>
                  </div>

                  <div className="flex justify-center mt-6">
                    <Button
                      onClick={handleSalvarAlteracoes}
                      disabled={updateProfileMutation.isPending}
                      className={`${buttonBaseStyle} w-auto px-6 py-1.5 bg-[#29D8FF] hover:bg-[#20B4D2] text-black shadow-[2px_2px_0px_0px_rgba(0,0,0,1)] hover:shadow-[1px_1px_0px_0px_rgba(0,0,0,1)] active:shadow-none active:translate-x-[2px] active:translate-y-[2px] disabled:opacity-50`}
                    >
                      {updateProfileMutation.isPending ? 'SALVANDO...' : 'SALVAR ALTERAÇÕES'}
                    </Button>
                  </div>
                </CardContent>
              </Card>

              {/* Right column - Team and actions */}
              <div className="h-full flex flex-col space-y-5">
                <div className="flex-1 overflow-y-auto space-y-5">
                  <Card className="border-2 border-solid border-black rounded-lg overflow-hidden bg-white shadow-[4px_4px_0px_0px_rgba(0,0,0,1)]">
                    <CardContent className="p-4">
                      <div className="flex justify-between items-center mb-3">
                        <h3 className={`${silkscreenFont} text-base text-black`}>
                          EQUIPE : <span className="text-[#E3922A] font-bold">
                            {user.equipe ? 'FRUIT VALE' : 'SEM EQUIPE'}
                          </span>
                        </h3>
                        {/* Ícones de editar e excluir equipe */}
                        <div className="flex items-center space-x-2">
                          <Button variant="ghost" onClick={handleTeamSettings} className="p-1 hover:bg-gray-200 rounded">
                            <Edit3 size={18} className="text-black" />
                          </Button>
                          {user.equipe && (
                            <Button variant="ghost" onClick={handleExcluirEquipe} className="p-1 hover:bg-red-100 rounded">
                              <Trash2 size={18} className="text-red-500" />
                            </Button>
                          )}
                        </div>
                      </div>

                      {/* Team info box */}
                      <div className="bg-gray-100 border-2 border-black rounded-md p-3 mb-4">
                        <div className="flex items-center mb-3">
                          <div className="flex flex-col items-center mr-4">
                            <p className={`${silkscreenFont} text-black text-sm mb-1 text-center`}>
                              {user.equipe ? 'LÍDER' : 'SEM EQUIPE'}
                            </p>
                            <img
                              src="/avatar-placeholder.png"
                              alt="Team Leader Avatar"
                              className="w-12 h-12 rounded-sm bg-gray-300 border border-black"
                            />
                          </div>
                          <div className={`${silkscreenFont} text-black text-xs flex flex-col space-y-1`}>
                            <div className="flex items-center"><Trophy size={16} className="mr-1 text-yellow-500" /> 4</div>
                            <div className="flex items-center"><Users size={16} className="mr-1" /> 5</div>
                            <div className="flex items-center"><Trophy size={16} className="mr-1 text-orange-400" /> 9</div>
                          </div>
                        </div>

                        {user.equipe ? (
                          <div className="flex space-x-2">
                            <Button
                              onClick={handleSairDaEquipe}
                              className={`${buttonBaseStyle} flex-1 bg-white hover:bg-gray-100 text-black text-[10px] leading-tight shadow-[2px_2px_0px_0px_rgba(0,0,0,1)] hover:shadow-[1px_1px_0px_0px_rgba(0,0,0,1)]`}
                            >
                              <LogOut size={14} className="mr-1 md:mr-2" /> SAIR DA EQUIPE
                            </Button>
                            <Button
                              onClick={handleExcluirEquipe}
                              className={`${buttonBaseStyle} flex-1 bg-red-500 hover:bg-red-600 text-white text-[10px] leading-tight shadow-[2px_2px_0px_0px_rgba(0,0,0,1)] hover:shadow-[1px_1px_0px_0px_rgba(0,0,0,1)]`}
                            >
                              <Trash2 size={14} className="mr-1 md:mr-2" /> EXCLUIR EQUIPE
                            </Button>
                          </div>
                        ) : (
                          <div className="text-center">
                            <Button
                              onClick={() => navigate('/equipes')}
                              className={`${buttonBaseStyle} bg-green-500 hover:bg-green-600 text-white text-sm`}
                            >
                              ENTRAR EM UMA EQUIPE
                            </Button>
                          </div>
                        )}
                      </div>

                      {/* Team role selector */}
                      {user.equipe && (
                        <div>
                          <label htmlFor="funcaoEquipe" className={`${labelStyle} mb-1`}>FUNÇÃO</label>
                          <div className="relative">
                            <select
                              name="funcaoEquipe"
                              id="funcaoEquipe"
                              value="MEMBRO" // Assuming a default role for now
                              onChange={() => { }} // TODO: Implementar mudança de função
                              className={`${inputStyle} appearance-none pr-8`}
                              disabled
                            >
                              <option value="COORDENADOR">COORDENADOR</option>
                              <option value="MEMBRO">MEMBRO</option>
                              <option value="VICE-LIDER">VICE-LIDER</option>
                            </select>
                            <ChevronDown size={20} className="absolute right-2 top-1/2 -translate-y-1/2 text-black pointer-events-none" />
                          </div>
                        </div>
                      )}
                    </CardContent>
                  </Card>

                  {/* Action buttons */}
                  <div className="space-y-3">
                    <Button
                      onClick={handleChangePassword}
                      className={`${buttonBaseStyle} w-full bg-white hover:bg-gray-100 text-black shadow-[2px_2px_0px_0px_rgba(0,0,0,1)] hover:shadow-[1px_1px_0px_0px_rgba(0,0,0,1)] active:shadow-none active:translate-x-[2px] active:translate-y-[2px]`}
                    >
                      <KeyRound size={18} className="mr-2" /> ALTERAR SENHA
                    </Button>
                    <Button
                      onClick={handleLogout}
                      className={`${buttonBaseStyle} w-full bg-white hover:bg-gray-100 text-black shadow-[2px_2px_0px_0px_rgba(0,0,0,1)] hover:shadow-[1px_1px_0px_0px_rgba(0,0,0,1)] active:shadow-none active:translate-x-[2px] active:translate-y-[2px]`}
                    >
                      <LogOut size={18} className="mr-2" /> SAIR
                    </Button>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

export default EditarPerfilPage;
</file>

<file path="src/pages/Perfil/EntrarEquipe.tsx">
import { useNavigate } from "react-router-dom";
import { useState } from "react";
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { Button } from "../../components/ui/button";
import {
  Card,
  CardContent,
} from "../../components/ui/card";
import {
  ArrowLeft,
  Users,
  Lock,
  AlertCircle,
  CheckCircle,
} from 'lucide-react';
import { TeamService } from "../../api/teamService";
import { useAuth } from "../../contexts/AuthContext";

export const EntrarEquipePage = () => {
  const navigate = useNavigate();
  const queryClient = useQueryClient();
  const { refreshUser } = useAuth();
  const [teamCode, setTeamCode] = useState("");
  const [errorMessage, setErrorMessage] = useState("");
  const [successMessage, setSuccessMessage] = useState("");

  const handleNavigateBack = () => {
    navigate(-1);
  };

  const joinTeamMutation = useMutation({
    mutationFn: (code: string) => TeamService.joinTeam(code),
    onSuccess: async (data) => {
      // Atualizar dados do usuário
      await refreshUser();
      
      // Invalidar queries relacionadas
      queryClient.invalidateQueries({ queryKey: ['user'] });
      queryClient.invalidateQueries({ queryKey: ['teams'] });
      queryClient.invalidateQueries({ queryKey: ['teamDetails'] });
      
      // Mostrar mensagem de sucesso
      const message = data?.detail || "Você entrou na equipe com sucesso!";
      setSuccessMessage(message);
      setErrorMessage("");
      
      // Aguardar um pouco para mostrar a mensagem e depois navegar
      setTimeout(() => {
        navigate("/game-selection");
      }, 2000);
    },
    onError: (error: any) => {
      const errorMessage = error.response?.data?.detail ||
        error.response?.data?.codigo?.[0] ||
        error.response?.data?.message ||
        "Erro ao entrar na equipe. Verifique o código e tente novamente.";
      
      setErrorMessage(errorMessage);
      setSuccessMessage("");
    },
  });

  const handleJoinTeam = () => {
    // Limpar mensagens anteriores
    setErrorMessage("");
    setSuccessMessage("");

    // Validar código
    if (!teamCode.trim()) {
      setErrorMessage("Por favor, digite o código da equipe.");
      return;
    }

    // Validar tamanho mínimo do código
    if (teamCode.trim().length < 3) {
      setErrorMessage("O código deve ter pelo menos 3 caracteres.");
      return;
    }

    joinTeamMutation.mutate(teamCode.trim());
  };

  const handleCodeChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value.toUpperCase();
    setTeamCode(value);
    
    // Limpar mensagens quando o usuário começar a digitar
    if (errorMessage || successMessage) {
      setErrorMessage("");
      setSuccessMessage("");
    }
  };

  // Função para lidar com Enter no input
  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !joinTeamMutation.isPending) {
      handleJoinTeam();
    }
  };

  const silkscreenFont = "[font-family:'Silkscreen',Helvetica]";
  const inputStyle = `bg-white border-2 border-black rounded-md p-3 w-full ${silkscreenFont} text-sm focus:outline-none focus:ring-2 focus:ring-blue-400 text-center tracking-wider`;
  const labelStyle = `text-xs ${silkscreenFont} mb-2 block text-black font-bold`;
  const buttonBaseStyle = `${silkscreenFont} border-2 border-black rounded-md px-6 py-3 text-sm font-bold flex items-center justify-center transition-all`;

  return (
    <div className="bg-white flex flex-row justify-center w-full">
      <div className={`w-full min-h-screen [background:linear-gradient(180deg,rgba(57,189,248,1)_0%,rgba(154,102,248,1)_100%)] relative overflow-hidden ${silkscreenFont}`}>
        {/* Nuvens decorativas */}
        <img
          className="w-[375px] h-[147px] absolute top-[80px] left-[calc(50%_-_650px)] object-cover animate-float-right opacity-80"
          alt="Cloud decoration left"
          src="/nuvemleft.png"
        />
        <img
          className="w-[436px] h-[170px] absolute bottom-[30px] right-[calc(50%_-_700px)] object-cover animate-float-left opacity-75 scale-110"
          alt="Cloud decoration right"
          src="/nuvemright.png"
        />

        {/* Botão de voltar */}
        <div className="absolute top-4 left-4 z-20">
          <Button 
            onClick={handleNavigateBack} 
            variant="outline" 
            className="p-2 bg-white border-2 border-black rounded-md hover:bg-gray-200"
          >
            <ArrowLeft size={24} className="text-black" />
          </Button>
        </div>

        {/* Conteúdo principal */}
        <div className="max-w-md mx-auto pt-16 pb-8 px-4 relative z-10">
          <Card className="border-2 border-solid border-black rounded-lg overflow-hidden bg-white shadow-[4px_4px_0px_0px_rgba(0,0,0,1)]">
            <CardContent className="p-4">
              {/* Header */}
              <div className="text-center mb-4">
                <div className="mb-3">
                  <Users size={40} className="text-[#E3922A] mx-auto mb-2" />
                </div>
                <h1 className={`${silkscreenFont} text-lg font-bold text-[#E3922A] border-2 border-black bg-gray-100 py-1 px-3 rounded-md inline-block`}>
                  ENTRAR NA EQUIPE
                </h1>
              </div>

              {/* Instruções */}
              <div className="mb-4">
                <div className="bg-blue-50 border-2 border-blue-300 rounded-md p-3">
                  <div className="flex items-start gap-2">
                    <Lock size={14} className="text-blue-600 mt-0.5" />
                    <div>
                      <p className={`${silkscreenFont} text-xs font-bold text-blue-800 mb-1`}>
                        COMO ENTRAR:
                      </p>
                      <ul className="space-y-0.5">
                        <li className={`${silkscreenFont} text-xs text-blue-700`}>
                          • PEÇA O CÓDIGO PARA O LÍDER
                        </li>
                        <li className={`${silkscreenFont} text-xs text-blue-700`}>
                          • DIGITE O CÓDIGO ABAIXO
                        </li>
                        <li className={`${silkscreenFont} text-xs text-blue-700`}>
                          • PRESSIONE ENTER OU CLIQUE EM ENTRAR
                        </li>
                      </ul>
                    </div>
                  </div>
                </div>
              </div>

              {/* Formulário */}
              <div className="space-y-3">
                <div>
                  <label htmlFor="teamCode" className={labelStyle}>
                    CÓDIGO DA EQUIPE
                  </label>
                  <input
                    type="text"
                    name="teamCode"
                    id="teamCode"
                    value={teamCode}
                    onChange={handleCodeChange}
                    onKeyPress={handleKeyPress}
                    placeholder="DIGITE O CÓDIGO AQUI"
                    className={inputStyle}
                    disabled={joinTeamMutation.isPending}
                    maxLength={20}
                    autoFocus
                  />
                </div>

                {/* Mensagem de erro */}
                {errorMessage && (
                  <div className="bg-red-50 border-2 border-red-300 rounded-md p-2">
                    <div className="flex items-start gap-2">
                      <AlertCircle size={14} className="text-red-600 mt-0.5" />
                      <p className={`${silkscreenFont} text-xs text-red-700`}>
                        {errorMessage}
                      </p>
                    </div>
                  </div>
                )}

                {/* Mensagem de sucesso */}
                {successMessage && (
                  <div className="bg-green-50 border-2 border-green-300 rounded-md p-2">
                    <div className="flex items-start gap-2">
                      <CheckCircle size={14} className="text-green-600 mt-0.5" />
                      <div>
                        <p className={`${silkscreenFont} text-xs text-green-700 mb-1`}>
                          {successMessage}
                        </p>
                        <p className={`${silkscreenFont} text-xs text-green-600`}>
                          Redirecionando para seleção de jogos...
                        </p>
                      </div>
                    </div>
                  </div>
                )}

                {/* Botão de entrar */}
                <div className="pt-1">
                  <Button
                    onClick={handleJoinTeam}
                    disabled={!teamCode.trim() || joinTeamMutation.isPending}
                    className={`${buttonBaseStyle} w-full bg-[#29D8FF] hover:bg-[#20B4D2] text-black shadow-[2px_2px_0px_0px_rgba(0,0,0,1)] hover:shadow-[1px_1px_0px_0px_rgba(0,0,0,1)] active:shadow-none active:translate-x-[2px] active:translate-y-[2px] disabled:opacity-50 disabled:cursor-not-allowed`}
                  >
                    {joinTeamMutation.isPending ? (
                      <>
                        <div className="animate-spin rounded-full h-4 w-4 border-2 border-black border-t-transparent mr-2"></div>
                        ENTRANDO...
                      </>
                    ) : (
                      <>
                        <Users size={16} className="mr-2" />
                        ENTRAR NA EQUIPE
                      </>
                    )}
                  </Button>
                </div>
              </div>

              {/* Seção de criar equipe */}
              <div className="mt-4 pt-3 border-t-2 border-gray-200">
                <div className="bg-yellow-50 border border-yellow-300 rounded-md p-2">
                  <p className={`${silkscreenFont} text-xs text-yellow-800 text-center mb-2`}>
                    💡 AINDA NÃO TEM EQUIPE?
                  </p>
                  <Button
                    onClick={() => navigate("/create-team")}
                    disabled={joinTeamMutation.isPending}
                    className={`${buttonBaseStyle} w-full bg-green-500 hover:bg-green-600 text-white shadow-[2px_2px_0px_0px_rgba(0,0,0,1)] hover:shadow-[1px_1px_0px_0px_rgba(0,0,0,1)] disabled:opacity-50`}
                  >
                    CRIAR NOVA EQUIPE
                  </Button>
                </div>
              </div>

              {/* Link para voltar à escolha de equipe */}
              <div className="mt-3 text-center">
                <button
                  onClick={() => navigate("/choose-team")}
                  disabled={joinTeamMutation.isPending}
                  className={`${silkscreenFont} text-xs text-blue-600 hover:text-blue-800 underline disabled:opacity-50`}
                >
                  ← VOLTAR PARA ESCOLHA DE EQUIPE
                </button>
              </div>
            </CardContent>
          </Card>
        </div>
      </div>
    </div>
  );
};

export default EntrarEquipePage;
</file>

<file path="src/pages/Tutorial/TutorialPage.tsx">
// src/pages/Tutorial/TutorialPage.tsx

import { useState, useEffect } from "react";
import { Button } from "../../components/ui/button";
import { ArrowLeft, Home } from 'lucide-react'; 
import { ButtonHomeBack } from "@/components/ButtonHomeBack";
import { AudioControl } from "@/components/AudioControl";
import { useNavigate } from "react-router-dom";

export const TutorialPage = () => {
  const navigate = useNavigate();
  const [isLoggedIn, setIsLoggedIn] = useState(false);
  
  useEffect(() => {
    const token = localStorage.getItem('token');
    setIsLoggedIn(!!token);
  }, []);

  const tutorialSteps = [
    {
      number: "1)",
      title: "ESCOLHA UM NOME PARA SUA EQUIPE.",
      description: "DEFINA OS MEMBROS E ATRIBUA FUNÇÕES ESTRATÉGICAS."
    },
    {
      number: "2)",
      title: "ESCOLHA O TIPO E QUANTIDADE DE CAMINHÕES.",
      description: "DEFINA A MELHOR ROTA CONSIDERANDO CUSTO E TEMPO. RESERVE UM ORÇAMENTO PARA EMERGÊNCIAS."
    },
    {
      number: "3)",
      title: "O JOGO SIMULA O TRANSPORTE EM TEMPO REAL.",
      description: "EVENTOS ALEATÓRIOS PODEM IMPACTAR A VIAGEM! VOCÊ PODE TOMAR DECISÕES PARA MINIMIZAR ATRASOS E CUSTOS."
    },
    {
      number: "4)",
      title: "VOCÊ SERÁ AVALIADO COM BASE EM:",
      description: (
        <div className="flex flex-col">
          <div className="flex items-start">
            <div className="w-5 h-5 bg-green-500 mr-2 mt-1"></div>
            <span>EFICIÊNCIA DE CUSTOS.</span>
          </div>
          <div className="flex items-start">
            <div className="w-5 h-5 bg-blue-500 mr-2 mt-1"></div>
            <span>CUMPRIMENTO DO PRAZO.</span>
          </div>
          <div className="flex items-start">
            <div className="w-5 h-5 bg-orange-500 mr-2 mt-1"></div>
            <span>CRIATIVIDADE NA RESOLUÇÃO DE PROBLEMAS.</span>
          </div>
        </div>
      )
    }
  ];

  return (
    <div className="bg-white flex flex-row justify-center w-full">
      <div className="w-full min-h-screen [background:linear-gradient(180deg,rgba(32,2,89,1)_0%,rgba(121,70,213,1)_100%)] relative overflow-hidden">
        <img
          className="w-[375px] h-[147px] absolute top-[120px] left-[157px] object-cover animate-float-right"
          alt="Cloud decoration"
          src="/nuvemleft.png"
        />
        <img
          className="w-[436px] h-[170px] absolute bottom-[30px] right-[27px] object-cover animate-float-left opacity-75 scale-110"
          alt="Cloud decoration"
          src="/nuvemright.png"
        />

        <div className="flex gap-5 absolute top-14 left-[33px]">
          <ButtonHomeBack onClick={() => navigate(-1)}><ArrowLeft/></ButtonHomeBack>
          <ButtonHomeBack onClick={() => navigate("/perfil")}><Home/></ButtonHomeBack>
        </div>

        <div className="absolute top-14 right-[33px]">
          <AudioControl />
        </div>

        <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-[70%] max-w-[750px]">
          <div className="bg-white rounded-[18px] border-2 border-solid border-black p-6">
            <h1 className="text-center text-[35px] [font-family:'Silkscreen',Helvetica] font-bold mb-6">
              TUTORIAL
            </h1>
            <p className="text-center [font-family:'Silkscreen',Helvetica] text-[14px] mb-6">
              NESTE JOGO, VOCÊ ASSUMIRÁ O PAPEL DE UMA EMPRESA DE LOGÍSTICA E PRECISARÁ PLANEJAR E
              EXECUTAR A ENTREGA DE MERCADORIAS DA FORMA MAIS EFICIENTE POSSÍVEL.
            </p>
            <div className="grid grid-cols-2 gap-6 mb-6">
              {tutorialSteps.map((step, index) => (
                <div key={index} className="flex">
                  <div className="mr-3">
                    <div className="text-[24px] [font-family:'Silkscreen',Helvetica] font-bold text-[#e3922a]">
                      {step.number}
                    </div>
                  </div>
                  <div>
                    <h3 className="[font-family:'Silkscreen',Helvetica] font-bold text-[14px]">
                      {step.title}
                    </h3>
                    <div className="[font-family:'Silkscreen',Helvetica] text-[12px] mt-1">
                      {step.description}
                    </div>
                  </div>
                </div>
              ))}
            </div>
            <p className="text-center [font-family:'Silkscreen',Helvetica] text-[12px] mb-6">
              AGORA QUE VOCÊ CONHECE AS REGRAS, ESTÁ PRONTO PARA O DESAFIO BOA SORTE!
            </p>
            <div className="flex justify-center">
              {/* ✅ BOTÃO CORRIGIDO: Navega para a rota estática /desafio */}
              <Button 
                onClick={() => navigate("/desafio")}
                className="w-[230px] px-36 h-[45px] bg-[#e3922a] rounded-md [font-family:'Silkscreen',Helvetica] font-bold text-black text-[26px] hover:bg-[#e3922a] transform transition-transform duration-300 hover:scale-105"
              >
                INICIAR JOGO
              </Button>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};
</file>

<file path="src/services/challengeService.ts">
// Serviço para buscar dados dos desafios do backend
import api from '../api/config';
import AuthService from '../api/authService';

// Interface para os dados do backend
export interface BackendMapa {
  id: number;
  nome: string;
  descricao: string;
  objetivo: string;
  ferramentas: Array<{
    tipo: string;
    descricao: string;
  }>;
  dificuldade: string;
  tempo_limite: string;
  min_jogadores: number;
  max_jogadores: number;
  imagem: string;
  rotas: BackendRota[];
}

export interface BackendRota {
  id: number;
  mapa: number;
  nome: string;
  descricao: string;
  distancia_km: number;
  tempo_estimado_horas: number;
  tipo_estrada: 'asfalto' | 'terra' | 'mista';
  risco_eventos_positivos: number;
  risco_eventos_negativos: number;
  velocidade_media_kmh: number;
  danger_zones_data: Array<{
    location: string;
    startKm: number;
    description: string;
    coordinates: [number, number];
    riskLevel: string;
  }>;
  dirt_segments_data: Array<{
    startKm: number;
    endKm: number;
    condition: string;
    eventChance: number;
    speedFactor: number;
    description: string;
  }>;
}

// Interface para o formato usado no frontend
export interface FrontendChallenge {
  id: string;
  backendId?: number; // ID real do backend
  name: string;
  description: string;
  destination: string;
  destinationCoordinates: [number, number];
  routes: FrontendRoute[];
  difficulty: 'Fácil' | 'Médio' | 'Difícil';
  estimatedDuration: string;
  objective?: string;
  tools?: Array<{
    type: string;
    description: string;
  }>;
}

export interface FrontendRoute {
  routeId: number;
  challengeId: string;
  name: string;
  distance: number;
  estimatedTime: string;
  estimatedTimeHours: number;
  cities: string[];
  roads: string[];
  startCoordinates: [number, number];
  endCoordinates: [number, number];
  pathCoordinates?: [number, number][];
  safety: {
    robberyRisk: string;
    roadHazards: string;
  };
  dirtRoad: boolean;
  dirtRoadDetails?: string;
  roadConditions: string;
  tollBooths?: Array<{
    location: string;
    costPerAxle: number;
    totalCostExample4Axles: number;
    coordinates: [number, number];
    totalCost: number;
  }>;
  speedLimits?: Array<{
    road: string;
    limit: string;
    value: number;
    coordinates: [number, number];
  }>;
  dangerZones?: Array<{
    location: string;
    startKm: number;
    description: string;
    coordinates: [number, number];
    riskLevel: string;
  }>;
  dirtSegments?: Array<{
    startKm: number;
    endKm: number;
    condition: string;
    eventChance: number;
    speedFactor: number;
    description: string;
  }>;
  fuelCostPerKm?: number;
  dangerZonesDetails?: string;
}

// Coordenadas de referência
const REFERENCE_COORDINATES = {
  JUAZEIRO: [-9.4111, -40.4969] as [number, number],
  SALVADOR: [-12.9714, -38.5014] as [number, number],
  RECIFE: [-8.0476, -34.8770] as [number, number],
  FORTALEZA: [-3.7319, -38.5267] as [number, number],
};

// Função para mapear dificuldade do backend para frontend
const mapDifficulty = (backendDifficulty: string): 'Fácil' | 'Médio' | 'Difícil' => {
  switch (backendDifficulty.toUpperCase()) {
    case 'FÁCIL':
    case 'FACIL':
      return 'Fácil';
    case 'MÉDIO':
    case 'MEDIO':
      return 'Médio';
    case 'DIFÍCIL':
    case 'DIFICIL':
      return 'Difícil';
    default:
      return 'Médio';
  }
};

// Função para determinar o destino baseado no nome do desafio
const getDestinationFromName = (nome: string): { destination: string; coordinates: [number, number] } => {
  const nomeUpper = nome.toUpperCase();
  
  if (nomeUpper.includes('SALVADOR')) {
    return { destination: 'Salvador, BA', coordinates: REFERENCE_COORDINATES.SALVADOR };
  } else if (nomeUpper.includes('RECIFE')) {
    return { destination: 'Recife, PE', coordinates: REFERENCE_COORDINATES.RECIFE };
  } else if (nomeUpper.includes('FORTALEZA')) {
    return { destination: 'Fortaleza, CE', coordinates: REFERENCE_COORDINATES.FORTALEZA };
  }
  
  // Default para Salvador se não conseguir identificar
  return { destination: 'Salvador, BA', coordinates: REFERENCE_COORDINATES.SALVADOR };
};

// Função para gerar ID do desafio baseado no destino
const getChallengeId = (nome: string): string => {
  const nomeUpper = nome.toUpperCase();
  
  if (nomeUpper.includes('SALVADOR')) {
    return 'salvador';
  } else if (nomeUpper.includes('RECIFE')) {
    return 'recife';
  } else if (nomeUpper.includes('FORTALEZA')) {
    return 'fortaleza';
  }
  
  return 'salvador'; // Default
};

// Função para converter dados do backend para o formato do frontend
const convertBackendToFrontend = (backendMapa: BackendMapa): FrontendChallenge => {
  const { destination, coordinates } = getDestinationFromName(backendMapa.nome);
  const challengeId = getChallengeId(backendMapa.nome);
  
  const routes: FrontendRoute[] = backendMapa.rotas.map((rota, index) => ({
    routeId: index + 1,
    challengeId,
    name: rota.nome,
    distance: rota.distancia_km,
    estimatedTime: `${Math.floor(rota.tempo_estimado_horas)}h${Math.round((rota.tempo_estimado_horas % 1) * 60).toString().padStart(2, '0')}min`,
    estimatedTimeHours: rota.tempo_estimado_horas,
    cities: [], // Será preenchido com dados estáticos se necessário
    roads: [], // Será preenchido com dados estáticos se necessário
    startCoordinates: REFERENCE_COORDINATES.JUAZEIRO,
    endCoordinates: coordinates,
    safety: {
      robberyRisk: rota.danger_zones_data.length > 2 ? 'Alto' : rota.danger_zones_data.length > 0 ? 'Médio' : 'Baixo',
      roadHazards: rota.tipo_estrada === 'terra' ? 'Estradas de terra, condições precárias' : 
                   rota.tipo_estrada === 'mista' ? 'Condições variáveis, alguns trechos ruins' : 
                   'Condições boas, tráfego normal'
    },
    dirtRoad: rota.tipo_estrada === 'terra' || rota.dirt_segments_data.length > 0,
    dirtRoadDetails: rota.dirt_segments_data.length > 0 ? 
      `${rota.dirt_segments_data.length} trecho(s) de terra identificado(s)` : undefined,
    roadConditions: rota.tipo_estrada === 'asfalto' ? 'Boa' : 
                   rota.tipo_estrada === 'mista' ? 'Regular' : 'Ruim',
    dangerZones: rota.danger_zones_data,
    dirtSegments: rota.dirt_segments_data,
    fuelCostPerKm: 4.50 + (rota.tipo_estrada === 'terra' ? 1.0 : rota.tipo_estrada === 'mista' ? 0.5 : 0),
    dangerZonesDetails: rota.danger_zones_data.length > 0 ? 
      `${rota.danger_zones_data.length} zona(s) de risco identificada(s)` : undefined
  }));

  return {
    id: challengeId,
    backendId: backendMapa.id, // Adiciona o ID real do backend
    name: backendMapa.nome,
    description: backendMapa.descricao,
    destination,
    destinationCoordinates: coordinates,
    routes,
    difficulty: mapDifficulty(backendMapa.dificuldade),
    estimatedDuration: backendMapa.tempo_limite,
    objective: backendMapa.objetivo,
    tools: backendMapa.ferramentas
  };
};

// Função para testar conectividade com o backend
export const testBackendConnection = async (): Promise<boolean> => {
  try {
    // Usa a instância api que já tem interceptors configurados
    const response = await api.get('/jogo1/veiculos/', { timeout: 5000 });
    console.log('✅ Conexão com backend OK');
    return response.status === 200;
  } catch (error) {
    console.error('❌ Erro ao testar conexão com backend:', error);
    return false;
  }
};

// Função principal para buscar desafios do backend
export const fetchChallengesFromBackend = async (): Promise<FrontendChallenge[]> => {
  try {
    console.log('🔍 Verificando autenticação...');
    
    // Verificar se o usuário está autenticado
    if (!AuthService.isAuthenticated()) {
      console.warn('⚠️ Usuário não autenticado');
      throw new Error('Usuário não autenticado. Faça login para acessar os desafios.');
    }

    console.log('🔍 Fazendo requisição para buscar mapas...');
    
    // Usar a instância api que já tem interceptors configurados
    const response = await api.get('/jogo1/mapas/', { timeout: 10000 });

    console.log('✅ Resposta recebida!');
    console.log('🔍 Status:', response.status);
    console.log('🔍 Dados:', response.data);

    if (!response.data) {
      console.error('❌ Resposta vazia do backend');
      return [];
    }

    if (!Array.isArray(response.data)) {
      console.error('❌ Resposta não é um array:', typeof response.data, response.data);
      return [];
    }

    if (response.data.length === 0) {
      console.warn('⚠️ Array vazio - nenhum mapa encontrado no backend');
      return [];
    }

    console.log(`✅ ${response.data.length} mapa(s) encontrado(s)`);

    const challenges: FrontendChallenge[] = response.data.map((mapa, index) => {
      console.log(`🔄 Convertendo mapa ${index + 1}:`, mapa.nome);
      try {
        return convertBackendToFrontend(mapa);
      } catch (conversionError) {
        console.error(`❌ Erro ao converter mapa ${index + 1}:`, conversionError, mapa);
        throw conversionError;
      }
    });
    
    console.log('🎯 Desafios convertidos:', challenges);
    
    return challenges;

  } catch (error: any) {
    console.error('❌ Erro ao buscar desafios:', error);
    
    // Se for erro de autenticação, propagar a mensagem
    if (error.response?.status === 401) {
      throw new Error('Sessão expirada. Faça login novamente.');
    }
    
    if (error.message?.includes('não autenticado')) {
      throw error;
    }
    
    if (error.code === 'ECONNREFUSED') {
      throw new Error('Não foi possível conectar ao servidor. Verifique se o backend está rodando.');
    }
    
    throw new Error('Erro ao carregar desafios. Tente novamente.');
  }
};

// Função para buscar um desafio específico por ID
export const fetchChallengeById = async (challengeId: string): Promise<FrontendChallenge | null> => {
  try {
    const challenges = await fetchChallengesFromBackend();
    return challenges.find(challenge => challenge.id === challengeId) || null;
  } catch (error) {
    console.error('❌ Erro ao buscar desafio específico:', error);
    throw error;
  }
};
</file>

<file path="src/types/index.ts">
// src/types/index.ts

export interface TeamHistory {
  id: string;
  name: string;
  stats: {
    people: number;
    trophy: number;
    tasks?: number;
  };
  color: string;
}

export interface Team {
  id: number;
  nome: string;
  stats: {
    people: number;
    trophy: number;
    trucks?: number;
    tasks?: number;
  };

  eficiencia_media?: number;

  color?: string;
  selected?: boolean;
  history?: TeamHistory[];
}

export interface Map {
  id: number;
  nome: string;
  descricao: string;
  rotas: any[]; // Pode ser tipado como Rota[] se necessário
}

// NOVAS INTERFACES PARA EQUIPES
export interface TeamCreationData {
  nome: string;
  descricao?: string;
}

export interface TeamMember {
  id: number;
  nickname: string;
  username?: string;
  first_name?: string;
  last_name?: string;
  level?: number;
  xp?: number;
  avatar?: string;
}

export interface TeamDetails {
  id: number;
  nome: string;
  codigo: string;
  descricao?: string;
  lider: TeamMember;
  membros: TeamMember[];
  created_at: string;
  updated_at?: string;
}
</file>

<file path="src/api/config.ts">
// src/api/config.ts - Configuração centralizada da API (TIPOS CORRIGIDOS)

import axios, { AxiosInstance, AxiosResponse, InternalAxiosRequestConfig } from 'axios';

// Configuração base da API
const baseURL = import.meta.env.VITE_API_URL || 'http://localhost:8000';

// Criar instância do axios com configurações padrão
const api: AxiosInstance = axios.create({
  baseURL,
  timeout: 30000, // 30 segundos
  headers: {
    'Content-Type': 'application/json',
  },
});

// ✅ INTERCEPTOR DE REQUEST: Adiciona token automaticamente (TIPOS CORRIGIDOS)
api.interceptors.request.use(
  (config: InternalAxiosRequestConfig) => {
    // Buscar token do localStorage
    const token = localStorage.getItem('token');

    if (token) {
      // Garantir que headers existe
      if (!config.headers) {
        config.headers = {} as any;
      }
      config.headers.Authorization = `Bearer ${token}`;
      console.log('🔑 Token adicionado à requisição:', config.url);
    }

    // Log da requisição para debug
    console.log(`📤 ${config.method?.toUpperCase()} ${config.url}`, config.data ? config.data : '');

    return config;
  },
  (error) => {
    console.error('❌ Erro no interceptor de request:', error);
    return Promise.reject(error);
  }
);

// ✅ INTERCEPTOR DE RESPONSE: Trata respostas e erros globalmente
api.interceptors.response.use(
  (response: AxiosResponse) => {
    // Log da resposta para debug
    console.log(`📥 ${response.status} ${response.config.url}`, response.data);
    return response;
  },
  (error) => {
    // Log detalhado do erro
    if (error.response) {
      // Erro HTTP (4xx, 5xx)
      console.error(`❌ ${error.response.status} ${error.config?.url}:`, error.response.data);

      // Tratar erro 401 (não autorizado) globalmente
      if (error.response.status === 401) {
        console.warn('🚫 Token expirado ou inválido, redirecionando para login...');

        // Limpar tokens
        localStorage.removeItem('authToken');
        localStorage.removeItem('access_token');
        localStorage.removeItem('refresh_token');

        // Redirecionar para login (se estiver no browser)
        if (typeof window !== 'undefined') {
          window.location.href = '/login';
        }
      }

      // Tratar erro 403 (acesso negado)
      if (error.response.status === 403) {
        console.warn('🚫 Acesso negado para:', error.config?.url);
      }

      // Tratar erro 404 (não encontrado)
      if (error.response.status === 404) {
        console.warn('🔍 Recurso não encontrado:', error.config?.url);
      }

      // Tratar erros de servidor (5xx)
      if (error.response.status >= 500) {
        console.error('🔥 Erro interno do servidor:', error.response.status);
      }

    } else if (error.request) {
      // Erro de rede (sem resposta)
      console.error('🌐 Erro de rede ou timeout:', error.message);
    } else {
      // Erro de configuração
      console.error('⚙️ Erro de configuração:', error.message);
    }

    return Promise.reject(error);
  }
);

// ✅ FUNÇÃO AUXILIAR: Para fazer requisições com retry automático
export const apiWithRetry = async <T>(
  requestFn: () => Promise<AxiosResponse<T>>,
  maxRetries: number = 3,
  delay: number = 1000
): Promise<AxiosResponse<T>> => {
  let lastError: any;

  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await requestFn();
    } catch (error: any) {
      lastError = error;

      // Não tentar novamente em erros 4xx (client errors)
      if (error.response?.status >= 400 && error.response?.status < 500) {
        throw error;
      }

      // Se não for a última tentativa, aguarda e tenta novamente
      if (attempt < maxRetries) {
        console.log(`🔄 Tentativa ${attempt}/${maxRetries} falhou, tentando novamente em ${delay}ms...`);
        await new Promise(resolve => setTimeout(resolve, delay));
        delay *= 2; // Backoff exponencial
      }
    }
  }

  throw lastError;
};

// ✅ FUNÇÃO AUXILIAR: Para verificar se a API está online
export const checkApiHealth = async (): Promise<boolean> => {
  try {
    const response = await api.get('/health/', { timeout: 5000 });
    return response.status === 200;
  } catch (error) {
    console.error('❌ API não está respondendo:', error);
    return false;
  }
};

// ✅ FUNÇÃO AUXILIAR: Para obter informações da API
export const getApiInfo = () => {
  return {
    baseURL,
    timeout: api.defaults.timeout,
    hasToken: !!(localStorage.getItem('authToken') || localStorage.getItem('access_token'))
  };
};

export default api;
</file>

<file path="src/hooks/useRanking.ts">
// src/hooks/useRanking.ts

import { useQuery } from '@tanstack/react-query';
import { TeamData, RankingApiResponse } from '../types/ranking';
import api from '../api/config';
import { useAuth } from '../contexts/AuthContext'; // ✅ IMPORTAÇÃO ADICIONADA

export const useRanking = () => {
  // ✅ HOOK DO AUTH PARA VERIFICAR ESTADO DE CARREGAMENTO
  const { user, loading: authLoading } = useAuth();

  // Busca os dados brutos da API usando react-query
  const {
    data,
    isLoading,
    isError,
    error,
    refetch
  } = useQuery<RankingApiResponse>({
    queryKey: ['ranking'],
    queryFn: async () => {
      const response = await api.get('/jogo1/ranking/');
      return response.data;
    },
    initialData: [],
    // ✅ Atualização automática e agressiva para manter o ranking fresco
    refetchOnMount: 'always',
    refetchOnWindowFocus: 'always',
    refetchOnReconnect: 'always',
    // ✅ Polling periódico (15s) mesmo em background para telas abertas
    refetchInterval: 15_000,
    refetchIntervalInBackground: true,
    // ✅ Dados ficam "stale" rapidamente para permitir refetch em foco
    staleTime: 10_000,
    retry: 2,
    // ✅ Só busca dados quando o auth terminou de carregar E o usuário existe
    enabled: !authLoading && !!user,
  });

  // Garantir que data é sempre um array de TeamData
  const teamData: TeamData[] = Array.isArray(data) ? data : [];

  // Função para encontrar a posição de uma equipe pelo nome
  const getUserPosition = (teamName: string): number | null => {
    const index = teamData.findIndex((team: TeamData) => team.nome === teamName);
    return index !== -1 ? index + 1 : null;
  };

  // Função para obter os dados completos de uma equipe pelo nome
  const getUserTeamData = (teamName: string): TeamData | null => {
    return teamData.find((team: TeamData) => team.nome === teamName) || null;
  };

  return {
    teamData,
    // ✅ O loading agora reflete o estado real: auth loading OU query loading
    loading: authLoading || isLoading,
    error: isError ? (error as Error).message : null,
    refetch,
    getUserPosition,
    getUserTeamData,
  };
};
</file>

<file path="src/pages/fuel/FuelPage.tsx">
import React, { useState } from 'react';
import { Vehicle } from '../../types/vehicle';
import { useLocation, useNavigate } from 'react-router-dom';
import { ArrowLeft } from 'lucide-react';
import { AudioControl } from '../../components/AudioControl';

export const FuelPage: React.FC = () => {
  const location = useLocation();
  const navigate = useNavigate();

  // Dados recebidos da tela anterior
  const receivedVehicle = location.state?.selectedVehicle || location.state?.vehicle || { id: 'carreta', name: 'Carreta', capacity: 60, consumption: { asphalt: 2, dirt: 1.5 }, image: '/carreta.png', maxCapacity: 495, currentFuel: 0, cost: 4500 };

  // Garantir que o veículo sempre comece com tanque vazio na página de combustível
  const vehicle = {
    ...receivedVehicle,
    currentFuel: 0 // Tanque sempre vazio para forçar decisão do usuário
  };

  const availableMoney = location.state?.availableMoney || 5500;
  const selectedRoute = location.state?.selectedRoute;
  const selectedChallenge = location.state?.selectedChallenge;
  const challengeId = location.state?.challengeId;

  // Debug dos dados recebidos
  console.log("=== DEBUG FUEL PAGE ===");
  console.log("Location state:", location.state);
  console.log("Vehicle received:", vehicle);
  console.log("Available money:", availableMoney);
  console.log("Selected route:", selectedRoute);
  console.log("======================");

  const [selectedVehicle] = useState<Vehicle>({ ...vehicle });
  const [fuelAmount, setFuelAmount] = useState<'full' | 'half' | 'quarter'>('full');
  const [availableBalance] = useState(availableMoney);
  const [previewFuel, setPreviewFuel] = useState<number>(vehicle.maxCapacity); // Preview inicia com a opção 'full' selecionada

  const fuelCostPerLiter = 5.5;

  const calculateFuelCost = (option: 'full' | 'half' | 'quarter') => {
    const maxCapacity = selectedVehicle.maxCapacity;
    let fuelToAdd = 0;

    // Como o tanque sempre começa vazio, calculamos a quantidade total desejada
    switch (option) {
      case 'full':
        fuelToAdd = maxCapacity;
        break;
      case 'half':
        fuelToAdd = maxCapacity / 2;
        break;
      case 'quarter':
        fuelToAdd = maxCapacity / 4;
        break;
    }

    return fuelToAdd * fuelCostPerLiter;
  };

  const handleRefuel = () => {
    const cost = calculateFuelCost(fuelAmount);

    if (cost <= availableBalance) {
      // Calcular o novo combustível baseado na opção selecionada
      const newCurrentFuel = fuelAmount === 'full'
        ? selectedVehicle.maxCapacity
        : fuelAmount === 'half'
          ? selectedVehicle.maxCapacity / 2
          : selectedVehicle.maxCapacity / 4;

      const updatedVehicle = {
        ...selectedVehicle,
        currentFuel: newCurrentFuel
      };

      const newBalance = availableMoney - cost;

      // ATUALIZADO: Passar dados completos incluindo selectedRoute para a GameScene
      navigate('/game', {
        state: {
          selectedVehicle: updatedVehicle,
          availableMoney: newBalance,
          selectedRoute: selectedRoute,  // GARANTIR QUE ESTE DADO SEJA PASSADO
          selectedChallenge,
          challengeId
        }
      });
    } else {
      alert('Saldo insuficiente para abastecer!');
    }
  };

  const handleSkipFuel = () => {
    // ATUALIZADO: Navegar para o jogo 2D sem abastecer, mas passando dados completos
    navigate('/game', {
      state: {
        selectedVehicle: selectedVehicle,
        availableMoney: availableBalance,
        selectedRoute: selectedRoute,  // GARANTIR QUE ESTE DADO SEJA PASSADO
        selectedChallenge,
        challengeId
      }
    });
  };

  const calculatePreviewFuel = (option: 'full' | 'half' | 'quarter'): number => {
    const max = selectedVehicle.maxCapacity;

    switch (option) {
      case 'full':
        return max;
      case 'half':
        return max / 2;
      case 'quarter':
        return max / 4;
      default:
        return 0; // Tanque vazio por padrão
    }
  };

  const goBack = () => {
    navigate('/routes');
  };

  // VALIDAÇÃO: Verificar se temos todos os dados necessários
  if (!selectedRoute) {
    console.error("ERRO: selectedRoute não encontrada! Redirecionando para seleção de rotas.");
    navigate('/routes');
    return null;
  }

  return (
    <div className="min-h-screen bg-gradient-to-br from-[#200259] to-[#300369] font-['Silkscreen']">
      {/* Header compacto */}
      <div className="bg-[#200259] border-b-4 border-[#E3922A] px-3 py-2 shadow-lg">
        <div className="flex items-center justify-between max-w-7xl mx-auto">
          <button
            className="flex items-center gap-1 px-3 py-1.5 bg-[#E3922A] text-black font-bold text-sm rounded-md shadow-lg
                     hover:bg-[#FFC06F] transition-all duration-200 border-2 border-black"
            onClick={goBack}
          >
            <ArrowLeft size={16} /> VOLTAR
          </button>

          <h1 className="text-lg lg:text-xl font-bold text-[#E3922A] text-center flex items-center gap-2">
            ⛽ ABASTECIMENTO
          </h1>

          <div className="flex items-center gap-2">
            <AudioControl />
            <div className="bg-gradient-to-r from-[#E3922A] to-[#FFC06F] text-black text-sm lg:text-base font-bold px-3 py-1.5 rounded-md shadow-lg border-2 border-black">
              R$ {availableBalance.toFixed(2)}
            </div>
          </div>
        </div>
      </div>

      {/* Conteúdo principal */}
      <div className="h-[calc(100vh-60px)] max-h-[calc(100vh-60px)] overflow-hidden p-2">
        <div className="bg-gradient-to-br from-gray-900 to-gray-800 rounded-lg shadow-2xl border-2 border-[#E3922A] w-full h-full p-3 backdrop-blur-sm flex flex-col">

          {/* Debug Info - mostrar rota selecionada */}
          <div className="bg-blue-500 bg-opacity-20 p-2 rounded-lg mb-2 border border-blue-600">
            <h4 className="font-['Silkscreen'] text-sm font-bold text-blue-100 mb-1">🗺️ ROTA SELECIONADA</h4>
            <p className="text-xs text-blue-200">{selectedRoute?.name || 'Rota não identificada'}</p>
            <p className="text-xs text-blue-200">ID: {selectedRoute?.routeId || 'N/A'} | Distância: {selectedRoute?.distance || 'N/A'}km</p>
          </div>

          {/* Header compacto da seção */}
          <div className="bg-gradient-to-r from-[#E3922A] to-[#FFC06F] text-black p-2 rounded-lg mb-2 border border-black flex-shrink-0">
            <div className="flex items-center justify-between">
              <h2 className="text-sm font-['Silkscreen'] font-bold flex items-center gap-1">
                🚛 ABASTECER VEÍCULO?
              </h2>
              <p className="font-['Silkscreen'] text-xs font-bold flex items-center gap-1">
                💰 Saldo final: <span className="text-green-800">R$ {(availableBalance - calculateFuelCost(fuelAmount)).toFixed(2)}</span>
              </p>
            </div>
          </div>

          {/* Layout otimizado sem scroll */}
          <div className="flex-1 min-h-0 flex flex-col">
            {/* Seção principal em uma linha */}
            <div className="flex flex-col lg:flex-row gap-4 flex-1 min-h-0">

              {/* Card do veículo elegante */}
              <div className="lg:w-3/5 bg-gradient-to-br from-[#FFC06F] via-[#FFD700] to-[#FFA500] p-4 rounded-xl shadow-xl border-2 border-[#E3922A]">
                <div className="bg-black bg-opacity-10 rounded-lg p-3 h-full flex flex-col">

                  {/* Header do veículo */}
                  <div className="flex items-center justify-center mb-3">
                    <h3 className="text-lg font-['Silkscreen'] font-bold text-black bg-white bg-opacity-80 px-4 py-2 rounded-full border-2 border-black shadow-md">
                      🚛 {selectedVehicle.name.toUpperCase()}
                    </h3>
                  </div>

                  {/* Layout horizontal com imagem e informações */}
                  <div className="flex gap-4 flex-1">
                    {/* Imagem do veículo */}
                    <div className="w-2/5 flex items-center justify-center bg-white bg-opacity-30 rounded-lg p-3 shadow-inner">
                      <img
                        src={selectedVehicle.image}
                        alt={selectedVehicle.name}
                        className="max-h-20 lg:max-h-24 object-contain filter drop-shadow-lg"
                      />
                    </div>

                    {/* Informações técnicas */}
                    <div className="w-3/5 space-y-3">
                      <div className="grid grid-cols-2 gap-3">
                        {/* Consumo */}
                        <div className="bg-green-500 bg-opacity-20 p-2 rounded-lg border border-green-600">
                          <h4 className="font-['Silkscreen'] text-sm font-bold text-green-900 mb-1 text-center">⛽ CONSUMO</h4>
                          <p className="text-xs text-green-800 text-center">🛣️ {selectedVehicle.consumption.asphalt} KM/L</p>
                          <p className="text-xs text-green-800 text-center">🌄 {selectedVehicle.consumption.dirt} KM/L</p>
                        </div>

                        {/* Capacidade */}
                        <div className="bg-blue-500 bg-opacity-20 p-2 rounded-lg border border-blue-600">
                          <h4 className="font-['Silkscreen'] text-sm font-bold text-blue-900 mb-1 text-center">🗜️ TANQUE</h4>
                          <p className="text-xs text-blue-800 text-center">📊 0L</p>
                          <p className="text-xs text-blue-800 text-center">🏁 {selectedVehicle.maxCapacity}L</p>
                        </div>
                      </div>

                      {/* Barra de combustível melhorada */}
                      <div className="bg-white bg-opacity-40 p-2 rounded-lg">
                        <div className="flex justify-between items-center mb-2">
                          <p className="font-['Silkscreen'] text-black text-sm font-bold">⛽ NÍVEL DO TANQUE</p>
                          <p className="text-sm font-bold text-black">0L → {previewFuel.toFixed(0)}L / {selectedVehicle.maxCapacity}L</p>
                        </div>

                        <div className="w-full bg-gray-200 rounded-full h-5 border-2 border-black relative overflow-hidden shadow-inner">
                          {/* Barra vazia (fundo branco quando não há combustível) */}
                          <div className="w-full h-full bg-white rounded-full"></div>

                          {/* Barra de preview - quantidade que será abastecida (verde) */}
                          <div
                            className="bg-gradient-to-r from-green-400 via-green-500 to-green-600 h-full absolute top-0 left-0 transition-all duration-700 ease-out"
                            style={{ width: `${(previewFuel / selectedVehicle.maxCapacity) * 100}%` }}
                          ></div>

                          {/* Marcadores de divisão */}
                          <div className="absolute inset-0 flex justify-between items-center px-2">
                            <div className="w-0.5 h-3 bg-gray-600 opacity-50"></div>
                            <div className="w-0.5 h-3 bg-gray-600 opacity-50"></div>
                            <div className="w-0.5 h-3 bg-gray-600 opacity-50"></div>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>

              {/* Painel de abastecimento */}
              <div className="lg:w-2/5 bg-gradient-to-br from-orange-400 via-orange-500 to-red-500 p-4 rounded-xl shadow-xl border-2 border-orange-600">
                <div className="bg-white bg-opacity-10 rounded-lg p-3 h-full flex flex-col">

                  {/* Header */}
                  <div className="text-center mb-3">
                    <h4 className="font-['Silkscreen'] text-lg font-bold text-white bg-black bg-opacity-30 px-3 py-2 rounded-lg border border-white">
                      ⛽ POSTO DE COMBUSTÍVEL
                    </h4>
                  </div>

                  {/* Preço em destaque */}
                  <div className="bg-red-600 text-white p-3 rounded-lg mb-3 text-center border-2 border-red-800 shadow-md">
                    <p className="font-['Silkscreen'] text-sm font-bold">
                      💵 DIESEL: R$ {fuelCostPerLiter.toFixed(2)}/LITRO
                    </p>
                  </div>

                  {/* Opções de abastecimento */}
                  <div className="space-y-2 mb-3">
                    <p className="font-['Silkscreen'] text-white text-sm font-bold text-center">ESCOLHA A QUANTIDADE:</p>
                    <div className="grid grid-cols-3 gap-2">
                      <button
                        onClick={() => {
                          const newPreview = calculatePreviewFuel('quarter');
                          setFuelAmount('quarter');
                          setPreviewFuel(newPreview);
                        }}
                        className={`py-2 px-2 border-2 rounded-lg font-bold text-sm transition-all duration-200 ${fuelAmount === 'quarter'
                          ? 'bg-[#E3922A] text-black border-black shadow-lg transform scale-105'
                          : 'bg-white text-gray-800 border-gray-300 hover:bg-gray-100'
                          }`}
                      >
                        1/4 TANQUE
                      </button>
                      <button
                        onClick={() => {
                          const newPreview = calculatePreviewFuel('half');
                          setFuelAmount('half');
                          setPreviewFuel(newPreview);
                        }}
                        className={`py-2 px-2 border-2 rounded-lg font-bold text-sm transition-all duration-200 ${fuelAmount === 'half'
                          ? 'bg-[#E3922A] text-black border-black shadow-lg transform scale-105'
                          : 'bg-white text-gray-800 border-gray-300 hover:bg-gray-100'
                          }`}
                      >
                        1/2 TANQUE
                      </button>
                      <button
                        onClick={() => {
                          const newPreview = calculatePreviewFuel('full');
                          setFuelAmount('full');
                          setPreviewFuel(newPreview);
                        }}
                        className={`py-2 px-2 border-2 rounded-lg font-bold text-sm transition-all duration-200 ${fuelAmount === 'full'
                          ? 'bg-[#E3922A] text-black border-black shadow-lg transform scale-105'
                          : 'bg-white text-gray-800 border-gray-300 hover:bg-gray-100'
                          }`}
                      >
                        TANQUE CHEIO
                      </button>
                    </div>
                  </div>

                  {/* Custo total em destaque */}
                  <div className="bg-green-600 text-white p-3 rounded-lg text-center border-2 border-green-800 shadow-md mt-auto">
                    <p className="font-['Silkscreen'] text-lg font-bold">
                      💰 TOTAL: R$ {calculateFuelCost(fuelAmount).toFixed(2)}
                    </p>
                  </div>
                </div>
              </div>
            </div>

            {/* Botões de ação elegantes */}
            <div className="flex justify-center gap-4 mt-4 flex-shrink-0">
              <button
                onClick={handleSkipFuel}
                className="bg-gradient-to-r from-gray-700 via-gray-800 to-gray-900 text-white font-bold py-3 px-8 rounded-xl shadow-xl border-2 border-gray-600 
                         hover:from-gray-600 hover:via-gray-700 hover:to-gray-800 transition-all duration-200 transform hover:scale-105 flex items-center gap-2"
              >
                ⏭️ PULAR ABASTECIMENTO
              </button>
              <button
                onClick={handleRefuel}
                disabled={calculateFuelCost(fuelAmount) > availableBalance}
                className={`font-bold py-3 px-8 rounded-xl shadow-xl border-2 transition-all duration-200 transform hover:scale-105 flex items-center gap-2 ${calculateFuelCost(fuelAmount) > availableBalance
                  ? 'bg-gray-400 text-gray-600 cursor-not-allowed border-gray-500'
                  : 'bg-gradient-to-r from-[#E3922A] via-[#FFC06F] to-[#FFD700] text-black border-[#E3922A] hover:from-[#FFC06F] hover:via-[#FFD700] hover:to-[#FFED4E]'
                  }`}
              >
                ⛽ ABASTECER AGORA
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};
</file>

<file path="src/pages/Perfil/EditarEquipe.tsx">
import { useNavigate } from "react-router-dom";
import { useState, useEffect } from "react";
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { Button } from "../../components/ui/button";
import {
  Card,
  CardContent,
} from "../../components/ui/card";
import {
  ArrowLeft,
  Copy,
  Settings,
  Crown,
  User,
} from 'lucide-react';
import { TeamService } from "../../api/teamService";
import { useAuth } from "../../contexts/AuthContext";

export const EditarEquipePage = () => {
  const navigate = useNavigate();
  const queryClient = useQueryClient();
  const { user } = useAuth();
  const teamId = user?.equipe;

  const [teamName, setTeamName] = useState("");

  const handleNavigateBack = () => {
    navigate(-1);
  };

  // Query para buscar dados da equipe
  const { data: teamData, isLoading, error } = useQuery({
    queryKey: ['teamDetails', teamId],
    queryFn: () => TeamService.getTeamDetails(teamId!),
    enabled: !!teamId,
  });

  // Sincronizar nome da equipe com os dados carregados
  useEffect(() => {
    if (teamData) {
      setTeamName(teamData.nome);
    }
  }, [teamData]);

  // Mutação para atualizar nome
  const updateTeamMutation = useMutation({
    mutationFn: (newName: string) =>
      TeamService.updateTeam(teamId!, { nome: newName }),
    onSuccess: () => {
      alert("Nome da equipe atualizado com sucesso!");
      queryClient.invalidateQueries({ queryKey: ['teamDetails', teamId] });
    },
    onError: (error: any) => {
      const errorMessage = error.response?.data?.detail ||
        error.response?.data?.nome?.[0] ||
        "Erro ao atualizar equipe.";
      alert(`Erro: ${errorMessage}`);
    },
  });

  // Mutação para regenerar código
  const regenerateCodeMutation = useMutation({
    mutationFn: () => TeamService.regenerateCode(teamId!),
    onSuccess: () => {
      alert("Novo código gerado com sucesso!");
      queryClient.invalidateQueries({ queryKey: ['teamDetails', teamId] });
    },
    onError: (error: any) => {
      const errorMessage = error.response?.data?.detail ||
        "Erro ao gerar novo código.";
      alert(`Erro: ${errorMessage}`);
    },
  });

  const handleSaveChanges = () => {
    if (!teamName.trim()) {
      alert("O nome da equipe não pode estar vazio.");
      return;
    }
    updateTeamMutation.mutate(teamName);
  };

  const handleGenerateNewCode = () => {
    if (confirm("Tem certeza que deseja gerar um novo código? O código atual ficará inválido.")) {
      regenerateCodeMutation.mutate();
    }
  };

  const handleCopyInviteCode = () => {
    if (teamData?.codigo) {
      navigator.clipboard.writeText(teamData.codigo);
      alert("Código copiado para a área de transferência!");
    }
  };

  // Estados de loading e erro
  if (isLoading) {
    return (
      <div className="bg-white flex flex-row justify-center w-full">
        <div className="w-full min-h-screen [background:linear-gradient(180deg,rgba(57,189,248,1)_0%,rgba(154,102,248,1)_100%)] relative overflow-hidden flex items-center justify-center">
          <Card className="border-2 border-solid border-black rounded-lg overflow-hidden bg-white shadow-[4px_4px_0px_0px_rgba(0,0,0,1)] p-8">
            <div className="text-center">
              <div className="animate-spin rounded-full h-8 w-8 border-2 border-blue-500 border-t-transparent mx-auto mb-4"></div>
              <p>Carregando dados da equipe...</p>
            </div>
          </Card>
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="bg-white flex flex-row justify-center w-full">
        <div className="w-full min-h-screen [background:linear-gradient(180deg,rgba(57,189,248,1)_0%,rgba(154,102,248,1)_100%)] relative overflow-hidden flex items-center justify-center">
          <Card className="border-2 border-solid border-black rounded-lg overflow-hidden bg-white shadow-[4px_4px_0px_0px_rgba(0,0,0,1)] p-8">
            <div className="text-center text-red-500">
              <p className="mb-4">Erro ao carregar dados da equipe.</p>
              <Button onClick={() => navigate("/perfil")} className="bg-blue-500 hover:bg-blue-600 text-white">
                Voltar ao Perfil
              </Button>
            </div>
          </Card>
        </div>
      </div>
    );
  }

  if (!teamData) {
    return (
      <div className="bg-white flex flex-row justify-center w-full">
        <div className="w-full min-h-screen [background:linear-gradient(180deg,rgba(57,189,248,1)_0%,rgba(154,102,248,1)_100%)] relative overflow-hidden flex items-center justify-center">
          <Card className="border-2 border-solid border-black rounded-lg overflow-hidden bg-white shadow-[4px_4px_0px_0px_rgba(0,0,0,1)] p-8">
            <div className="text-center">
              <p className="mb-4">Equipe não encontrada.</p>
              <Button onClick={() => navigate("/perfil")} className="bg-blue-500 hover:bg-blue-600 text-white">
                Voltar ao Perfil
              </Button>
            </div>
          </Card>
        </div>
      </div>
    );
  }

  // Verificar se é o líder (só após carregar os dados)
  const isLeader = teamData && user && teamData.lider.id === user.id;
  if (teamData && user && !isLeader) {
    return (
      <div className="bg-white flex flex-row justify-center w-full">
        <div className="w-full min-h-screen [background:linear-gradient(180deg,rgba(57,189,248,1)_0%,rgba(154,102,248,1)_100%)] relative overflow-hidden flex items-center justify-center">
          <Card className="border-2 border-solid border-black rounded-lg overflow-hidden bg-white shadow-[4px_4px_0px_0px_rgba(0,0,0,1)] p-8">
            <div className="text-center">
              <p className="mb-4">Apenas o líder da equipe pode editar estas informações.</p>
              <Button onClick={() => navigate("/perfil")} className="bg-blue-500 hover:bg-blue-600 text-white">
                Voltar ao Perfil
              </Button>
            </div>
          </Card>
        </div>
      </div>
    );
  }

  const getRoleIcon = (isLider: boolean) => {
    if (isLider) {
      return <Crown size={16} className="text-yellow-500" />;
    }
    return <User size={16} className="text-gray-500" />;
  };

  const getRoleColor = (isLider: boolean) => {
    if (isLider) {
      return 'text-yellow-600';
    }
    return 'text-gray-600';
  };

  const getRoleText = (isLider: boolean) => {
    return isLider ? 'LÍDER' : 'MEMBRO';
  };

  const silkscreenFont = "[font-family:'Silkscreen',Helvetica]";
  const inputStyle = `bg-white border-2 border-black rounded-md p-2 w-full ${silkscreenFont} text-sm focus:outline-none focus:ring-2 focus:ring-blue-400`;
  const labelStyle = `text-xs ${silkscreenFont} mb-1 block text-black font-bold`;
  const buttonBaseStyle = `${silkscreenFont} border-2 border-black rounded-md px-4 py-2 text-xs font-bold flex items-center justify-center transition-all`;

  return (
    <div className="bg-white flex flex-row justify-center w-full">
      <div className={`w-full min-h-screen [background:linear-gradient(180deg,rgba(57,189,248,1)_0%,rgba(154,102,248,1)_100%)] relative overflow-hidden ${silkscreenFont}`}>
        {/* Decorative clouds */}
        <img
          className="w-[375px] h-[147px] absolute top-[80px] left-[calc(50%_-_650px)] object-cover animate-float-right opacity-80"
          alt="Cloud decoration left"
          src="/nuvemleft.png"
        />
        <img
          className="w-[436px] h-[170px] absolute bottom-[30px] right-[calc(50%_-_700px)] object-cover animate-float-left opacity-75 scale-110"
          alt="Cloud decoration right"
          src="/nuvemright.png"
        />

        {/* Back button */}
        <div className="absolute top-4 left-4 z-20">
          <Button onClick={handleNavigateBack} variant="outline" className="p-2 bg-white border-2 border-black rounded-md hover:bg-gray-200">
            <ArrowLeft size={24} className="text-black" />
          </Button>
        </div>

        {/* Main content */}
        <div className="max-w-4xl mx-auto pt-16 pb-8 px-4 relative z-10">
          <Card className="border-2 border-solid border-black rounded-lg overflow-hidden bg-white shadow-[4px_4px_0px_0px_rgba(0,0,0,1)]">
            <CardContent className="p-6">
              {/* Header */}
              <div className="text-center mb-6">
                <h1 className={`${silkscreenFont} text-xl font-bold text-[#E3922A] border-2 border-black bg-gray-100 py-2 px-4 rounded-md inline-block`}>
                  EDITAR EQUIPE
                </h1>
              </div>

              <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                {/* Left column - Team info */}
                <div className="space-y-4">
                  {/* Team name */}
                  <div>
                    <label htmlFor="teamName" className={labelStyle}>
                      NOME DA EQUIPE
                    </label>
                    <input
                      type="text"
                      name="teamName"
                      id="teamName"
                      value={teamName}
                      onChange={(e) => setTeamName(e.target.value)}
                      className={inputStyle}
                      disabled={updateTeamMutation.isPending}
                    />
                  </div>

                  {/* Invite code */}
                  <div>
                    <label htmlFor="inviteCode" className={labelStyle}>
                      CÓDIGO DE INVITE
                    </label>
                    <div className="flex gap-2">
                      <input
                        type="text"
                        name="inviteCode"
                        id="inviteCode"
                        value={teamData.codigo}
                        readOnly
                        className={`${inputStyle} flex-1`}
                      />
                      <Button
                        onClick={handleCopyInviteCode}
                        className={`${buttonBaseStyle} bg-green-500 hover:bg-green-600 text-white shadow-[2px_2px_0px_0px_rgba(0,0,0,1)] hover:shadow-[1px_1px_0px_0px_rgba(0,0,0,1)]`}
                      >
                        <Copy size={14} />
                      </Button>
                      <Button
                        onClick={handleGenerateNewCode}
                        disabled={regenerateCodeMutation.isPending}
                        className={`${buttonBaseStyle} bg-red-500 hover:bg-red-600 text-white shadow-[2px_2px_0px_0px_rgba(0,0,0,1)] hover:shadow-[1px_1px_0px_0px_rgba(0,0,0,1)] disabled:opacity-50`}
                      >
                        {regenerateCodeMutation.isPending ? "..." : "GERAR NOVO"}
                      </Button>
                    </div>
                  </div>

                  {/* Team members */}
                  <div>
                    <label className={labelStyle}>
                      MEMBROS DA EQUIPE ({teamData.membros.length})
                    </label>
                    <div className="space-y-2 max-h-60 overflow-y-auto">
                      {teamData.membros.map((member) => {
                        const isLider = member.id === teamData.lider.id;
                        return (
                          <div key={member.id} className="flex items-center gap-3 bg-gray-50 border-2 border-black rounded-md p-3">
                            <img
                              src={member.avatar || "/mario.png"}
                              alt={`Avatar de ${member.nickname}`}
                              className="w-12 h-12 rounded-full border-2 border-black object-cover"
                            />
                            <div className="flex-1">
                              <div className="flex items-center gap-2">
                                {getRoleIcon(isLider)}
                                <span className={`${silkscreenFont} text-sm font-bold text-black`}>
                                  {member.nickname.toUpperCase()}
                                </span>
                              </div>
                              <div className={`${silkscreenFont} text-xs text-gray-600`}>
                                @{member.username || member.nickname}
                              </div>
                            </div>
                            <div className={`${silkscreenFont} text-xs ${getRoleColor(isLider)} font-bold`}>
                              {getRoleText(isLider)}
                            </div>
                          </div>
                        );
                      })}
                    </div>
                  </div>
                </div>

                {/* Right column - Instructions */}
                <div className="space-y-4">
                  <div>
                    <label className={`${labelStyle} mb-3`}>
                      COMO ADICIONAR MEMBROS
                    </label>

                    <div className="bg-gray-50 border-2 border-black rounded-md p-4">
                      <p className={`${silkscreenFont} text-sm text-black mb-4`}>
                        PARA ADICIONAR NOVOS MEMBROS:
                      </p>

                      <ol className="space-y-3">
                        <li className="flex items-start gap-2">
                          <span className="text-blue-500 font-bold">1.</span>
                          <span className={`${silkscreenFont} text-xs text-gray-700`}>
                            COMPARTILHE O CÓDIGO DE CONVITE COM OS JOGADORES
                          </span>
                        </li>
                        <li className="flex items-start gap-2">
                          <span className="text-blue-500 font-bold">2.</span>
                          <span className={`${silkscreenFont} text-xs text-gray-700`}>
                            ELES DEVEM USAR O CÓDIGO NA TELA "ENTRAR EM EQUIPE"
                          </span>
                        </li>
                        <li className="flex items-start gap-2">
                          <span className="text-blue-500 font-bold">3.</span>
                          <span className={`${silkscreenFont} text-xs text-gray-700`}>
                            OS NOVOS MEMBROS APARECERÃO AUTOMATICAMENTE AQUI
                          </span>
                        </li>
                      </ol>

                      <div className="mt-4 p-3 bg-yellow-50 border border-yellow-300 rounded">
                        <p className={`${silkscreenFont} text-xs text-yellow-800`}>
                          💡 DICA: CLIQUE EM "COPIAR" PARA FACILITAR O COMPARTILHAMENTO
                        </p>
                      </div>
                    </div>
                  </div>
                </div>
              </div>

              {/* Save button */}
              <div className="flex flex-col md:flex-row justify-center items-center gap-4 mt-8">
                <Button
                  onClick={handleSaveChanges}
                  disabled={!teamName.trim() || updateTeamMutation.isPending}
                  className={`${buttonBaseStyle} px-8 py-3 bg-[#29D8FF] hover:bg-[#20B4D2] text-black shadow-[2px_2px_0px_0px_rgba(0,0,0,1)] hover:shadow-[1px_1px_0px_0px_rgba(0,0,0,1)] active:shadow-none active:translate-x-[2px] active:translate-y-[2px] disabled:opacity-50 disabled:cursor-not-allowed`}
                >
                  {updateTeamMutation.isPending ? (
                    <>
                      <div className="animate-spin rounded-full h-4 w-4 border-2 border-black border-t-transparent mr-2"></div>
                      SALVANDO...
                    </>
                  ) : (
                    <>
                      <Settings size={18} className="mr-2" />
                      SALVAR ALTERAÇÕES
                    </>
                  )}
                </Button>
                {isLeader && (
                  <Button
                    variant="destructive"
                    className="px-6 py-3 border-2 border-black bg-red-600 text-white hover:bg-red-700"
                    onClick={() => navigate('/perfil/excluir-equipe')}
                  >
                    EXCLUIR EQUIPE
                  </Button>
                )}
                <Button
                  variant="outline"
                  className="px-6 py-3 border-2 border-black bg-gray-200 text-black hover:bg-gray-300"
                  onClick={async () => {
                    if (confirm('Tem certeza que deseja sair da equipe?')) {
                      try {
                        await TeamService.leaveTeam();
                        if (typeof window !== 'undefined' && window.location) {
                          // Força refresh do usuário e redireciona
                          await queryClient.invalidateQueries({ queryKey: ['teamDetails', teamId] });
                          if (typeof window !== 'undefined') {
                            window.location.href = '/perfil';
                          }
                        }
                      } catch (error) {
                        alert('Erro ao sair da equipe. Tente novamente.');
                      }
                    }
                  }}
                >
                  SAIR DA EQUIPE
                </Button>
              </div>
            </CardContent>
          </Card>
        </div>
      </div>
    </div>
  );
};

export default EditarEquipePage;
</file>

<file path="src/App.tsx">
import { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom';
import { AuthProvider } from './contexts/AuthContext';
import { AudioProvider } from './contexts/AudioContext';
import { AudioManager } from './components/AudioManager';
import { HomePage } from './pages/Home';
import { VehicleSelectionPage } from './pages/escolherVeiculo';
import { RoutesPage } from './pages/RoutesPage/RoutesPage';
import { FuelPage } from './pages/fuel/FuelPage';
import { MapComponent } from './pages/mapaRota/MapComponent';
import { GameScene } from './pages/Game-truck/game';
import { LoginPage } from './pages/auth/LoginPage';
import { ApresentacaoDesafioPage } from './pages/Desafio/ApresentacaoDesafio';
import './App.css';

function App() {
  return (
    <AudioProvider>
      <AuthProvider>
        <BrowserRouter>
          <AudioManager />
          <Routes>
            <Route path="/" element={<HomePage />} />
            <Route path="/login" element={<LoginPage />} />
            <Route path="/desafios" element={<ApresentacaoDesafioPage />} />
            <Route path="/select-vehicle" element={<VehicleSelectionPage />} />
            <Route path="/routes" element={<RoutesPage />} />
            <Route path="/fuel" element={<FuelPage />} />
            <Route path="/map" element={<MapComponent />} />
            <Route path="/mapa-rota" element={<MapComponent />} />
            <Route path="/game" element={<GameScene />} />
            {/* Redirecionar para a página inicial por padrão */}
            <Route path="*" element={<Navigate to="/" replace />} />
          </Routes>
        </BrowserRouter>
      </AuthProvider>
    </AudioProvider>
  );
}
/*commit*/

export default App;
</file>

<file path="src/pages/ChooseTeam/ChooseTeam.tsx">
import { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { TeamService } from '../../api/teamService';
import { Team } from '../../types';
import { useAuth } from '../../contexts/AuthContext';
import TeamCard from '../../components/TeamCard';
import CreateTeamButton from '../../components/CreateTeamButton';
import SelectTeamButton from '../../components/SelectTeamButton';
import { ButtonHomeBack } from '@/components/ButtonHomeBack';
import { AudioControl } from '@/components/AudioControl';
import { ArrowLeft, House, LogIn } from 'lucide-react';

export const ChooseTeam = () => {
    const navigate = useNavigate();
    const queryClient = useQueryClient();
    const { user, loading } = useAuth();
    const [selectedTeamId, setSelectedTeamId] = useState<number | null>(null);
    const [inviteCode, setInviteCode] = useState('');

    // Se ainda está carregando o contexto de autenticação
    if (loading) {
        return <div className="text-white text-center">Carregando...</div>;
    }

    // Se não está logado, redireciona para login
    if (!user) {
        navigate('/login');
        return null;
    }

    // Se já está em uma equipe, redireciona para o perfil
    if (user.equipe) {
        navigate('/game-selection');
        return null;
    }

    // Busca as equipes da API
    const { data: teams, isLoading, isError } = useQuery<Team[]>({
        queryKey: ['teams'],
        queryFn: TeamService.getTeams,
    });

    // Mutação para entrar em uma equipe
    const joinTeamMutation = useMutation({
        mutationFn: (code: string) => TeamService.joinTeam(code),
        onSuccess: async () => {
            queryClient.invalidateQueries({ queryKey: ['teams'] });
            alert("Você entrou na equipe com sucesso!");
            navigate("/game-selection");
        },
        onError: (err: any) => {
            const errorMessage = err.response?.data?.detail ||
                err.response?.data?.codigo?.[0] ||
                "Código inválido ou você já está em uma equipe.";
            alert(`Erro: ${errorMessage}`);
        },
    });

    // Função para lidar com o clique no botão "ENTRAR"
    const handleJoinWithCode = () => {
        if (!inviteCode.trim()) {
            alert("Por favor, digite um código de convite.");
            return;
        }
        joinTeamMutation.mutate(inviteCode.trim());
    };

    // Função para lidar com Enter no input
    const handleKeyPress = (e: React.KeyboardEvent) => {
        if (e.key === 'Enter') {
            handleJoinWithCode();
        }
    };

    const handleTeamClick = (id: number) => {
        setSelectedTeamId(id);
    };

    const handleCreateTeam = () => {
        navigate("/create-team");
    };

    const handleSelectTeam = () => {
        if (selectedTeamId) {
            // Redireciona para a tela de entrada de código
            navigate("/perfil/entrar-equipe");
        } else {
            alert("Por favor, selecione uma equipe primeiro.");
        }
    };

    if (isLoading) return <div className="text-white text-center">Carregando equipes...</div>;
    if (isError) return <div className="text-red-500 text-center">Erro ao carregar equipes.</div>;

    return (
        <div className="h-screen bg-gradient-to-b from-indigo-900 to-purple-700 font-pixel relative overflow-hidden flex flex-col">
            <img className="w-[375px] h-[147px] absolute top-[120px] left-[157px] object-cover animate-float-right z-0" alt="Nuvem" src="/nuvemleft.png" />
            <img className="w-[436px] h-[170px] absolute bottom-[30px] right-[27px] object-cover animate-float-left opacity-75 scale-110 z-0" alt="Nuvem" src="/nuvemright.png" />

            <div className="relative z-10 flex flex-col flex-1 overflow-y-auto">
                <div className="flex gap-5 mt-14 ml-8">
                    <ButtonHomeBack onClick={() => navigate(-1)}>
                        <ArrowLeft />
                    </ButtonHomeBack>
                    <ButtonHomeBack onClick={() => navigate("/perfil")}>
                        <House />
                    </ButtonHomeBack>
                </div>

                <div className="absolute top-14 right-8">
                    <AudioControl />
                </div>

                <div className="flex-1 md:pt-20 overflow-auto container mx-auto px-4 py-4">
                    <h1 className="text-2xl md:text-2xl text-yellow-300 font-bold text-center mt-2 mb-8 tracking-wide"
                        style={{ textShadow: '2px 3px 2px black' }}>
                        ESCOLHA SUA EQUIPE
                    </h1>

                    {/* Seção de Criar/Entrar na Equipe */}
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-8">
                        {/* Bloco de Criar Equipe */}
                        <div className="bg-white/5 backdrop-blur-sm border-2 border-white/20 rounded-lg p-4">
                            <CreateTeamButton onClick={handleCreateTeam} />
                        </div>

                        {/* Bloco de Entrar com Código */}
                        <div className="bg-white/5 backdrop-blur-sm border-2 border-white/20 rounded-lg p-4 flex flex-col items-center justify-center">
                            <h3 className="font-pixel text-cyan-400 text-center mb-4">ENTRAR COM CÓDIGO</h3>
                            <div className="flex w-full gap-2">
                                <input
                                    type="text"
                                    placeholder="DIGITE O CÓDIGO"
                                    value={inviteCode}
                                    onChange={(e) => setInviteCode(e.target.value.toUpperCase())}
                                    onKeyPress={handleKeyPress}
                                    maxLength={10}
                                    className="flex-grow bg-white text-black font-bold p-2 border-2 border-black text-center text-xl tracking-widest uppercase"
                                    disabled={joinTeamMutation.isPending}
                                />
                                <button
                                    onClick={handleJoinWithCode}
                                    disabled={joinTeamMutation.isPending || !inviteCode.trim()}
                                    className="bg-green-500 text-black font-bold p-3 border-2 border-black
                           hover:shadow-[4px_4px_0px_0px_rgba(0,0,0,1)] transition-all 
                           hover:-translate-x-[2px] hover:-translate-y-[2px] 
                           disabled:opacity-50 disabled:cursor-not-allowed"
                                >
                                    {joinTeamMutation.isPending ? '...' : <LogIn size={24} />}
                                </button>
                            </div>
                            {joinTeamMutation.isPending && (
                                <p className="text-yellow-300 text-sm mt-2">Entrando na equipe...</p>
                            )}
                        </div>
                    </div>

                    {/* Lista de Equipes */}
                    <div className="mb-6">
                        <h2 className="text-2xl text-center text-yellow-300 font-bold mb-4 z-10"
                            style={{ textShadow: '2px 3px 2px black' }}>
                            OU ESCOLHA UMA EQUIPE DA LISTA
                        </h2>
                        <div className="space-y-4 overflow-y-auto max-h-60 lg:max-h-[500px] px-1">
                            {teams?.map(team => (
                                <TeamCard
                                    key={team.id}
                                    team={team}
                                    onClick={() => handleTeamClick(team.id)}
                                    selected={team.id === selectedTeamId}
                                />
                            ))}
                        </div>
                    </div>

                    <div className="justify-center flex">
                        <SelectTeamButton onClick={handleSelectTeam} />
                    </div>
                </div>
            </div>
        </div>
    );
};
</file>

<file path="src/pages/Perfil/ExcluirEquipe.tsx">
import { useNavigate } from "react-router-dom";
import { useState } from "react";
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { Button } from "../../components/ui/button";
import {
  Card,
  CardContent,
} from "../../components/ui/card";
import {
  ArrowLeft,
  Trash2,
  AlertTriangle,
  Users,
} from 'lucide-react';
import { TeamService } from "../../api/teamService";
import { useAuth } from "../../contexts/AuthContext";

export const ExcluirEquipePage = () => {
  const navigate = useNavigate();
  const queryClient = useQueryClient();
  const { user, refreshUser } = useAuth();
  const teamId = user?.equipe;

  const [confirmationText, setConfirmationText] = useState("");

  const handleNavigateBack = () => {
    navigate(-1);
  };

  // Query para buscar dados da equipe
  const { data: teamData, isLoading } = useQuery({
    queryKey: ['teamDetails', teamId],
    queryFn: () => TeamService.getTeamDetails(teamId!),
    enabled: !!teamId,
  });

  // Mutação para excluir equipe
  const deleteTeamMutation = useMutation({
    mutationFn: () => TeamService.deleteTeam(teamId!),
    onSuccess: async () => {
      alert("Equipe excluída com sucesso!");
      await refreshUser(); // CRUCIAL: atualizar dados do usuário
      queryClient.clear(); // Limpar todas as queries
      navigate("/perfil");
    },
    onError: (error: any) => {
      const errorMessage = error.response?.data?.detail ||
        "Erro ao excluir equipe.";
      alert(`Erro: ${errorMessage}`);
    },
  });

  const handleConfirmDelete = () => {
    if (!teamData) return;

    if (confirmationText.trim().toUpperCase() !== teamData.nome.toUpperCase()) {
      alert("O nome da equipe não confere. Digite exatamente como mostrado.");
      return;
    }

    if (confirm("Esta ação não pode ser desfeita. Tem certeza absoluta?")) {
      deleteTeamMutation.mutate();
    }
  };

  const handleCancel = () => {
    navigate("/perfil/editar-equipe");
  };

  // Estados de loading
  if (isLoading) {
    return (
      <div className="bg-white flex flex-row justify-center w-full">
        <div className="w-full min-h-screen [background:linear-gradient(180deg,rgba(220,53,69,1)_0%,rgba(108,117,125,1)_100%)] relative overflow-hidden flex items-center justify-center">
          <Card className="border-2 border-solid border-black rounded-lg overflow-hidden bg-white shadow-[4px_4px_0px_0px_rgba(0,0,0,1)] p-8">
            <div className="text-center">
              <div className="animate-spin rounded-full h-8 w-8 border-2 border-red-500 border-t-transparent mx-auto mb-4"></div>
              <p>Carregando dados da equipe...</p>
            </div>
          </Card>
        </div>
      </div>
    );
  }

  if (!teamData) {
    return (
      <div className="bg-white flex flex-row justify-center w-full">
        <div className="w-full min-h-screen [background:linear-gradient(180deg,rgba(220,53,69,1)_0%,rgba(108,117,125,1)_100%)] relative overflow-hidden flex items-center justify-center">
          <Card className="border-2 border-solid border-black rounded-lg overflow-hidden bg-white shadow-[4px_4px_0px_0px_rgba(0,0,0,1)] p-8">
            <div className="text-center">
              <p className="mb-4">Equipe não encontrada ou você não está em uma equipe.</p>
              <Button onClick={() => navigate("/perfil")} className="bg-blue-500 hover:bg-blue-600 text-white">
                Voltar ao Perfil
              </Button>
            </div>
          </Card>
        </div>
      </div>
    );
  }

  // Verificar se é o líder (só após carregar os dados)
  const isLeader = teamData && user && teamData.lider.id === user.id;
  if (teamData && user && !isLeader) {
    return (
      <div className="bg-white flex flex-row justify-center w-full">
        <div className="w-full min-h-screen [background:linear-gradient(180deg,rgba(220,53,69,1)_0%,rgba(108,117,125,1)_100%)] relative overflow-hidden flex items-center justify-center">
          <Card className="border-2 border-solid border-black rounded-lg overflow-hidden bg-white shadow-[4px_4px_0px_0px_rgba(0,0,0,1)] p-8">
            <div className="text-center">
              <p className="mb-4">Apenas o líder da equipe pode excluí-la.</p>
              <Button onClick={() => navigate("/perfil")} className="bg-blue-500 hover:bg-blue-600 text-white">
                Voltar ao Perfil
              </Button>
            </div>
          </Card>
        </div>
      </div>
    );
  }

  const silkscreenFont = "[font-family:'Silkscreen',Helvetica]";
  const inputStyle = `bg-white border-2 border-black rounded-md p-3 w-full ${silkscreenFont} text-sm focus:outline-none focus:ring-2 focus:ring-red-400`;
  const labelStyle = `text-sm ${silkscreenFont} mb-2 block text-black font-bold`;
  const buttonBaseStyle = `${silkscreenFont} border-2 border-black rounded-md px-6 py-3 text-sm font-bold flex items-center justify-center transition-all`;

  const isConfirmationValid = confirmationText.trim().toUpperCase() === teamData.nome.toUpperCase();

  return (
    <div className="bg-white flex flex-row justify-center w-full">
      <div className={`w-full min-h-screen [background:linear-gradient(180deg,rgba(220,53,69,1)_0%,rgba(108,117,125,1)_100%)] relative overflow-hidden ${silkscreenFont}`}>
        {/* Decorative clouds */}
        <img
          className="w-[375px] h-[147px] absolute top-[80px] left-[calc(50%_-_650px)] object-cover animate-float-right opacity-60"
          alt="Cloud decoration left"
          src="/nuvemleft.png"
        />
        <img
          className="w-[436px] h-[170px] absolute bottom-[30px] right-[calc(50%_-_700px)] object-cover animate-float-left opacity-55 scale-110"
          alt="Cloud decoration right"
          src="/nuvemright.png"
        />

        {/* Back button */}
        <div className="absolute top-4 left-4 z-20">
          <Button onClick={handleNavigateBack} variant="outline" className="p-2 bg-white border-2 border-black rounded-md hover:bg-gray-200">
            <ArrowLeft size={24} className="text-black" />
          </Button>
        </div>

        {/* Main content */}
        <div className="max-w-2xl mx-auto pt-16 pb-8 px-4 relative z-10">
          <Card className="border-2 border-solid border-black rounded-lg overflow-hidden bg-white shadow-[4px_4px_0px_0px_rgba(0,0,0,1)]">
            <CardContent className="p-6">
              {/* Header */}
              <div className="text-center mb-6">
                <div className="flex justify-center mb-4">
                  <div className="w-20 h-20 rounded-full bg-red-100 border-2 border-red-500 flex items-center justify-center">
                    <AlertTriangle size={40} className="text-red-500" />
                  </div>
                </div>
                <h1 className={`${silkscreenFont} text-2xl font-bold text-red-600 mb-2`}>
                  EXCLUIR EQUIPE
                </h1>
                <p className={`${silkscreenFont} text-sm text-gray-700`}>
                  ESTA AÇÃO NÃO PODE SER DESFEITA
                </p>
              </div>

              {/* Team info */}
              <div className="bg-gray-50 border-2 border-black rounded-md p-4 mb-6">
                <h3 className={`${silkscreenFont} text-lg font-bold text-black mb-3 text-center`}>
                  EQUIPE: <span className="text-red-600">{teamData.nome}</span>
                </h3>

                <div className="grid grid-cols-2 gap-4 text-center">
                  <div className="flex flex-col items-center">
                    <Users size={24} className="text-gray-600 mb-1" />
                    <span className={`${silkscreenFont} text-xs text-gray-600`}>MEMBROS</span>
                    <span className={`${silkscreenFont} text-lg font-bold text-black`}>{teamData.membros.length}</span>
                  </div>
                  <div className="flex flex-col items-center">
                    <span className="text-2xl mb-1">📅</span>
                    <span className={`${silkscreenFont} text-xs text-gray-600`}>CRIADA EM</span>
                    <span className={`${silkscreenFont} text-sm font-bold text-black`}>
                      {new Date(teamData.created_at).toLocaleDateString('pt-BR')}
                    </span>
                  </div>
                </div>

                {/* Members list */}
                <div className="mt-4">
                  <p className={`${silkscreenFont} text-xs text-gray-600 mb-2`}>MEMBROS QUE SERÃO REMOVIDOS:</p>
                  <div className="space-y-1 max-h-24 overflow-y-auto">
                    {teamData.membros.map((member) => (
                      <div key={member.id} className="flex items-center gap-2 text-xs">
                        <span className="text-red-500">•</span>
                        <span className={`${silkscreenFont}`}>
                          {member.nickname} {member.id === teamData.lider.id ? '(LÍDER)' : ''}
                        </span>
                      </div>
                    ))}
                  </div>
                </div>
              </div>

              {/* Warning */}
              <div className="bg-red-50 border-2 border-red-300 rounded-md p-4 mb-6">
                <div className="flex items-start">
                  <AlertTriangle size={20} className="text-red-500 mr-3 mt-1 flex-shrink-0" />
                  <div>
                    <h4 className={`${silkscreenFont} text-sm font-bold text-red-700 mb-2`}>
                      ATENÇÃO: AO EXCLUIR A EQUIPE
                    </h4>
                    <ul className={`${silkscreenFont} text-xs text-red-600 space-y-1`}>
                      <li>• TODOS OS MEMBROS SERÃO REMOVIDOS</li>
                      <li>• TODO O PROGRESSO SERÁ PERDIDO</li>
                      <li>• OS DADOS DA EQUIPE SERÃO APAGADOS</li>
                      <li>• ESTA AÇÃO NÃO PODE SER REVERTIDA</li>
                    </ul>
                  </div>
                </div>
              </div>

              {/* Confirmation input */}
              <div className="mb-6">
                <label htmlFor="confirmationText" className={labelStyle}>
                  PARA CONFIRMAR, DIGITE O NOME DA EQUIPE:
                </label>
                <div className="mb-2">
                  <span className={`${silkscreenFont} text-sm text-gray-600 bg-gray-100 px-2 py-1 rounded border`}>
                    {teamData.nome}
                  </span>
                </div>
                <input
                  type="text"
                  name="confirmationText"
                  id="confirmationText"
                  value={confirmationText}
                  onChange={(e) => setConfirmationText(e.target.value)}
                  className={inputStyle}
                  placeholder="DIGITE O NOME DA EQUIPE AQUI"
                  disabled={deleteTeamMutation.isPending}
                />
                {confirmationText && !isConfirmationValid && (
                  <p className={`${silkscreenFont} text-xs text-red-500 mt-1`}>
                    O nome não confere
                  </p>
                )}
              </div>

              {/* Action buttons */}
              <div className="flex flex-col sm:flex-row gap-3">
                <Button
                  onClick={handleCancel}
                  disabled={deleteTeamMutation.isPending}
                  className={`${buttonBaseStyle} flex-1 bg-gray-200 hover:bg-gray-300 text-black shadow-[2px_2px_0px_0px_rgba(0,0,0,1)] hover:shadow-[1px_1px_0px_0px_rgba(0,0,0,1)] active:shadow-none active:translate-x-[2px] active:translate-y-[2px] disabled:opacity-50 disabled:cursor-not-allowed`}
                >
                  CANCELAR
                </Button>
                <Button
                  onClick={handleConfirmDelete}
                  disabled={!isConfirmationValid || deleteTeamMutation.isPending}
                  className={`${buttonBaseStyle} flex-1 bg-red-500 hover:bg-red-600 text-white shadow-[2px_2px_0px_0px_rgba(0,0,0,1)] hover:shadow-[1px_1px_0px_0px_rgba(0,0,0,1)] active:shadow-none active:translate-x-[2px] active:translate-y-[2px] disabled:opacity-50 disabled:cursor-not-allowed disabled:shadow-none`}
                >
                  {deleteTeamMutation.isPending ? (
                    <>
                      <div className="animate-spin rounded-full h-4 w-4 border-2 border-white border-t-transparent mr-2"></div>
                      EXCLUINDO...
                    </>
                  ) : (
                    <>
                      <Trash2 size={18} className="mr-2" />
                      EXCLUIR EQUIPE
                    </>
                  )}
                </Button>
              </div>
            </CardContent>
          </Card>
        </div>
      </div>
    </div>
  );
};

export default ExcluirEquipePage;
</file>

<file path="src/main.tsx">
import { StrictMode } from "react";
import { BrowserRouter, Route, Routes } from "react-router-dom";
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { ReactQueryDevtools } from '@tanstack/react-query-devtools';
import { HomePage } from "./pages/Home/HomePage";
import { VehicleSelectionPage } from './pages/escolherVeiculo';
import { Login } from "./pages/auth/Login/Login";
import { Cadastro } from "./pages/auth/Cadastro/Cadastro";
import { ForgotPassword } from "./pages/auth/ForgotPassword/ForgotPassword";
import { ChangePassword } from "./pages/Perfil/ChangePassword";
import { TutorialPage } from "./pages/Tutorial/TutorialPage";
import { PerfilPage } from "./pages/Perfil/PerfilPage";
import { AuthProvider } from "./contexts/AuthContext";
import { AudioProvider } from "./contexts/AudioContext";
import { AudioManager } from "./components/AudioManager";
import { ProtectedRoute } from "./components/ProtectedRoute";
import { EditarPerfilPage } from "./pages/Perfil/EditarPerfil";
import { ExcluirEquipePage } from "./pages/Perfil/ExcluirEquipe";
import { MapComponent } from "./pages/mapaRota/MapComponent";
import { EditarEquipePage } from "./pages/Perfil/EditarEquipe";
import { EntrarEquipePage } from "./pages/Perfil/EntrarEquipe";
import { CriarEquipePage } from "./pages/Perfil/CriarEquipe";
import { createRoot } from "react-dom/client";
import GameSelectionPage from "./pages/GameSelection/GameSelectionPage";
import { ApresentacaoDesafioPage } from "./pages/Desafio/ApresentacaoDesafio";
import { RankingPage } from "./pages/Ranking/RankingPage";
import { ChooseTeam } from "./pages/ChooseTeam/ChooseTeam";
import { GameScene } from "./pages/Game-truck/game";
import { FuelPage } from "./pages/fuel/FuelPage";
import { RoutesPage } from "./pages/RoutesPage/RoutesPage";

import { PauseMenu } from "./pages/PauseMenu/PauseMenu.tsx";


// Criar instância do QueryClient
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 1000 * 60 * 5, // 5 minutos
      retry: 1,
    },
  },
});

createRoot(document.getElementById("app") as HTMLElement).render(
  <StrictMode>
    <QueryClientProvider client={queryClient}>
      <AudioProvider>
        <AuthProvider>
          <BrowserRouter>
            <AudioManager />
            <Routes>
            {/* Rotas públicas */}
            <Route path="/" element={<HomePage />} />
            {/* <Route path="/select-vehicle" element={<HomePage />} />
            <Route path="/mapa-rota" element={<MapComponent />} /> */}

            <Route path="/game" element={<GameScene />} />
            <Route path="/login" element={<Login />} />
            <Route path="/cadastro" element={<Cadastro />} />
            <Route path="/forgot-password" element={<ForgotPassword />} />
            <Route path="/reset-password/:uidb64/:token" element={<ForgotPassword />} />
            <Route path="/tutorial" element={<TutorialPage />} />

            {/* Rotas protegidas */}

            <Route path="/perfil" element={
              <ProtectedRoute>
                <PerfilPage />
              </ProtectedRoute>
            } />
            <Route path="/perfil/editar" element={
              <ProtectedRoute>
                <EditarPerfilPage />
              </ProtectedRoute>
            } />
            <Route path="/perfil/excluir-equipe" element={
              <ProtectedRoute>
                <ExcluirEquipePage />
              </ProtectedRoute>
            } />
            <Route path="/perfil/editar-equipe" element={
              <ProtectedRoute>
                <EditarEquipePage />
              </ProtectedRoute>
            } />
            <Route path="/perfil/entrar-equipe" element={
              <ProtectedRoute>
                <EntrarEquipePage />
              </ProtectedRoute>
            } />
            <Route path="/mudar-senha" element={
              <ProtectedRoute>
                <ChangePassword />
              </ProtectedRoute>
            } />
            <Route path="/ranking" element={
              <ProtectedRoute>
                <RankingPage />
              </ProtectedRoute>
            } />
            <Route path="/game" element={
              <ProtectedRoute>
                <HomePage />
              </ProtectedRoute>
            } />
            <Route path="/games" element={
              <ProtectedRoute>
                <HomePage />
              </ProtectedRoute>
            } />
            <Route path="/select-vehicle" element={
              <ProtectedRoute>
                <VehicleSelectionPage />
              </ProtectedRoute>
            } />
            <Route path="/mapa-rota" element={
              <ProtectedRoute>
                <MapComponent />
              </ProtectedRoute>
            } />
            <Route path="/mapa" element={
              <ProtectedRoute>
                <MapComponent />
              </ProtectedRoute>
            } />
            <Route path="/choose-team" element={
              <ProtectedRoute>
                <ChooseTeam />
              </ProtectedRoute>
            } />
            <Route path="/create-team" element={
              <ProtectedRoute>
                <CriarEquipePage />
              </ProtectedRoute>
            } />
            <Route path="/join-team" element={
              <ProtectedRoute>
                <EntrarEquipePage />
              </ProtectedRoute>
            } />
            <Route path="/desafio" element={
              <ProtectedRoute>
                <ApresentacaoDesafioPage />
              </ProtectedRoute>
            } />
            <Route path="/game-selection" element={
              <ProtectedRoute>
                <GameSelectionPage />
              </ProtectedRoute>
            } />

            {/* Rota para o PauseMenu para testes */}
            <Route path="/pause-menu" element={
              <ProtectedRoute>
                <PauseMenu
                  isVisible={true}
                  onResume={() => console.log('Resume')}
                  onGoToProfile={() => console.log('Go to Profile')}
                  onRestart={() => console.log('Restart')}
                />
              </ProtectedRoute>
            } />

            <Route path="/routes" element={<RoutesPage />} />
            <Route path="/fuel" element={<FuelPage />} />
            <Route path="/map" element={<MapComponent />} />

            </Routes>
          </BrowserRouter>
        </AuthProvider>
      </AudioProvider>
      {/* DevTools apenas em desenvolvimento */}
      {import.meta.env.DEV && <ReactQueryDevtools initialIsOpen={false} />}
    </QueryClientProvider>
  </StrictMode>
);
</file>

<file path="src/pages/Ranking/RankingPage.tsx">
// src/pages/Ranking/RankingPage.tsx

import { useNavigate, useLocation } from "react-router-dom";
import { useState, useMemo } from "react";
import { Button } from "../../components/ui/button";
import { Card, CardContent } from "../../components/ui/card";
import {
  ArrowLeft,
  Trophy,
  TrendingUp,
  Package,
  Target,
  Loader2,
  RefreshCw
} from 'lucide-react';
import { useAuth } from '../../contexts/AuthContext';
import { useRanking } from '../../hooks/useRanking';
import { AudioControl } from "../../components/AudioControl";
import { TeamRanking, UserStats, RankingTab, TeamData } from "../../types/ranking";

export const RankingPage = () => {
  const navigate = useNavigate();
  const location = useLocation();
  const { user } = useAuth();

  // Hook do ranking
  const { teamData, loading, error, refetch, getUserPosition, getUserTeamData } = useRanking();

  const [activeTab, setActiveTab] = useState<RankingTab>('EFICIENCIA');
  const cameFromProfile = location.state?.from === 'profile';

  // Converte dados da API para o formato que a UI precisa
  const teamRankings = useMemo((): TeamRanking[] => {
    return teamData.map((team: TeamData, index: number) => ({
      position: index + 1,
      name: team.nome,
      points: Math.round(team.eficiencia_media * 10),
      victories: team.stats.vitorias,
      efficiency: Math.round(team.eficiencia_media * 100) / 100,
    }));
  }, [teamData]);

  // Calcula as estatísticas da equipe do usuário logado
  const userStats = useMemo((): UserStats | null => {
    // Pegamos o ID da equipe do usuário logado
    const userTeamId = user?.equipe;
    if (!userTeamId) return null;

    // Encontramos o objeto completo da equipe nos dados do ranking
    const userTeamObject = teamData.find((team: TeamData) => team.id === userTeamId);
    if (!userTeamObject) return null;

    // Usamos o nome do objeto para buscar a posição
    const position = getUserPosition(userTeamObject.nome);
    if (!position) return null;

    return {
      position,
      points: Math.round(userTeamObject.eficiencia_media * 10),
      victories: userTeamObject.stats.vitorias,
      efficiency: Math.round(userTeamObject.eficiencia_media * 100) / 100,
    };
  }, [user, teamData, getUserPosition]);

  // Funções de navegação corrigidas
  const handleNavigateBack = () => {
    if (cameFromProfile) {
      navigate("/perfil");
    } else {
      navigate(-1);
    }
  };

  const handleOkClick = () => {
    if (cameFromProfile) {
      navigate("/perfil");
    } else {
      if (user?.equipe) {
        navigate("/game-selection");
      } else {
        navigate("/choose-team");
      }
    }
  };

  const getPositionIcon = (position: number): string => {
    if (position <= 3) {
      const icons = ['🏆', '🥈', '🥉'];
      return icons[position - 1];
    }
    return `${position}°`;
  };

  const getRowColor = (position: number): string => {
    if (position === 1) return "bg-yellow-100 border-yellow-300";
    if (position === 2) return "bg-gray-100 border-gray-300";
    if (position === 3) return "bg-orange-100 border-orange-300";
    return "bg-white border-gray-200";
  };

  const sortedData = useMemo(() => {
    const data = [...teamRankings];
    switch (activeTab) {
      case 'VITORIAS':
        return data.sort((a, b) => b.victories - a.victories);
      case 'PONTOS':
        return data.sort((a, b) => b.points - a.points);
      case 'EFICIENCIA':
      default:
        return data; // A API já envia ordenado por eficiência
    }
  }, [activeTab, teamRankings]);

  // ESTADOS DE CARREGAMENTO E ERRO
  if (loading) {
    return (
      <div className="h-screen flex items-center justify-center font-['Silkscreen'] bg-gradient-to-b from-blue-400 to-purple-500">
        <div className="text-center">
          <Loader2 className="animate-spin mx-auto mb-4 text-white" size={32} />
          <p className="text-white text-xl">Carregando Ranking...</p>
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="h-screen flex items-center justify-center font-['Silkscreen'] bg-gradient-to-b from-blue-400 to-purple-500">
        <div className="text-center">
          <div className="bg-white p-6 rounded-lg border-2 border-black shadow-lg">
            <p className="text-red-600 text-lg mb-4">Erro ao carregar ranking</p>
            <p className="text-gray-600 text-sm mb-4">{error}</p>
            <Button onClick={() => refetch()} className="bg-blue-500 text-white">
              <RefreshCw className="mr-2" size={16} />
              Tentar Novamente
            </Button>
          </div>
        </div>
      </div>
    );
  }

  const silkscreenFont = "[font-family:'Silkscreen',Helvetica]";
  const buttonBaseStyle = `${silkscreenFont} border-2 border-black rounded-md px-4 py-2 text-xs font-bold flex items-center justify-center transition-all`;

  return (
    <div className="bg-white w-full h-screen overflow-hidden">
      <div className={`w-full h-full [background:linear-gradient(180deg,rgba(57,189,248,1)_0%,rgba(154,102,248,1)_100%)] relative overflow-hidden ${silkscreenFont}`}>
        {/* Botões de navegação */}
        <div className="absolute top-4 left-4 z-20">
          <Button
            onClick={handleNavigateBack}
            variant="outline"
            className="p-2 bg-white border-2 border-black rounded-md hover:bg-gray-200"
          >
            <ArrowLeft size={24} className="text-black" />
          </Button>
        </div>
        <div className="absolute top-4 right-4 z-20 flex gap-2">
          <AudioControl />
          <Button
            onClick={() => refetch()}
            disabled={loading}
            variant="outline"
            className="p-2 bg-white border-2 border-black rounded-md hover:bg-gray-200"
          >
            {loading ? <Loader2 className="animate-spin" size={20} /> : <RefreshCw size={20} />}
          </Button>
        </div>

        <div className="h-full flex items-center justify-center px-4 relative z-10">
          <div className="max-w-4xl w-full">
            <Card className="border-2 border-solid border-black rounded-lg overflow-hidden bg-white shadow-[4px_4px_0px_0px_rgba(0,0,0,1)]">
              <CardContent className="p-4">
                <div className="text-center mb-4">
                  <h1
                    className={`${silkscreenFont} text-xl font-bold text-[#E3922A]`}
                    style={{ textShadow: "2px 3px 0.6px #000" }}
                  >
                    RANKING DE EFICIÊNCIA
                  </h1>
                  <p className={`${silkscreenFont} text-xs text-gray-600 mt-1`}>
                    Baseado na média de desempenho logístico
                  </p>
                </div>

                {userStats ? (
                  // Se userStats existir, renderiza o card completo
                  <div className="mb-4">
                    <Card className="bg-yellow-50 border-2 border-yellow-400 rounded-lg">
                      <CardContent className="p-3">
                        <div className="flex items-center justify-between">
                          <div className="flex items-center gap-3">
                            <div className="w-10 h-10 bg-yellow-400 border-2 border-black rounded-full flex items-center justify-center">
                              <Trophy size={20} className="text-black" />
                            </div>
                            <div>
                              <p className={`${silkscreenFont} text-xs text-gray-600 mb-1`}>SUA POSIÇÃO</p>
                              <p className={`${silkscreenFont} text-lg font-bold text-black`}>{userStats.position}°</p>
                            </div>
                          </div>
                          <div className="grid grid-cols-3 gap-3 text-center">
                            <div>
                              <p className={`${silkscreenFont} text-xs text-gray-600 mb-1`}>PONTOS</p>
                              <p className={`${silkscreenFont} text-sm font-bold`}>{userStats.points}</p>
                            </div>
                            <div>
                              <p className={`${silkscreenFont} text-xs text-gray-600 mb-1`}>VITÓRIAS</p>
                              <p className={`${silkscreenFont} text-sm font-bold`}>{userStats.victories}</p>
                            </div>
                            <div>
                              <p className={`${silkscreenFont} text-xs text-gray-600 mb-1`}>EFICIÊNCIA</p>
                              <p className={`${silkscreenFont} text-sm font-bold`}>{userStats.efficiency}%</p>
                            </div>
                          </div>
                        </div>
                      </CardContent>
                    </Card>
                  </div>
                ) : (
                  // Se userStats for nulo, renderiza a mensagem de fallback
                  <div className="mb-4">
                    <Card className="bg-gray-50 border-2 border-gray-300 rounded-lg">
                      <CardContent className="p-4">
                        <div className="text-center">
                          <p className={`${silkscreenFont} text-sm text-gray-700`}>
                            Sua equipe ainda não está no ranking.
                          </p>
                          <p className={`${silkscreenFont} text-xs text-gray-500 mt-1`}>
                            Complete uma partida para ver suas estatísticas aqui!
                          </p>
                        </div>
                      </CardContent>
                    </Card>
                  </div>
                )}

                {/* Tabs */}
                <div className="flex justify-center mb-4">
                  <div className="flex border-2 border-black rounded-md overflow-hidden">
                    <Button
                      onClick={() => setActiveTab('EFICIENCIA')}
                      className={`${buttonBaseStyle} rounded-none ${activeTab === 'EFICIENCIA' ? 'bg-blue-500 text-white' : 'bg-white text-black'
                        }`}
                    >
                      <Target size={12} className="mr-1" />
                      EFICIÊNCIA
                    </Button>
                    <Button
                      onClick={() => setActiveTab('PONTOS')}
                      className={`${buttonBaseStyle} rounded-none border-x-2 border-black ${activeTab === 'PONTOS' ? 'bg-blue-500 text-white' : 'bg-white text-black'
                        }`}
                    >
                      <TrendingUp size={12} className="mr-1" />
                      PONTOS
                    </Button>
                    <Button
                      onClick={() => setActiveTab('VITORIAS')}
                      className={`${buttonBaseStyle} rounded-none ${activeTab === 'VITORIAS' ? 'bg-blue-500 text-white' : 'bg-white text-black'
                        }`}
                    >
                      <Package size={12} className="mr-1" />
                      VITÓRIAS
                    </Button>
                  </div>
                </div>

                {/* Info sobre o sistema de eficiência */}
                <div className="mb-4 p-3 bg-blue-50 border-2 border-blue-300 rounded-lg">
                  <p className={`${silkscreenFont} text-xs text-blue-800 text-center`}>
                    📊 Eficiência = Carga Entregue (50%) + Tempo (30%) + Economia (20%)
                  </p>
                </div>

                {/* Tabela de ranking */}
                <div className="overflow-hidden border-2 border-black rounded-lg mb-4">
                  <div className="grid grid-cols-4 bg-gray-200 border-b-2 border-black">
                    <div className={`${silkscreenFont} p-2 text-center border-r-2 border-black text-xs font-bold`}>#</div>
                    <div className={`${silkscreenFont} p-2 text-center border-r-2 border-black text-xs font-bold`}>EQUIPE</div>
                    <div className={`${silkscreenFont} p-2 text-center border-r-2 border-black text-xs font-bold`}>
                      {activeTab}
                    </div>
                    <div className={`${silkscreenFont} p-2 text-center text-xs font-bold`}>
                      {activeTab === 'PONTOS' ? 'VITÓRIAS' : activeTab === 'VITORIAS' ? 'EFICIÊNCIA' : 'PONTOS'}
                    </div>
                  </div>

                  {sortedData.map((team) => (
                    <div
                      key={team.name}
                      className={`grid grid-cols-4 border-b last:border-b-0 ${getRowColor(team.position)} ${user?.equipe && teamData.find(t => t.id === user.equipe)?.nome === team.name
                        ? 'ring-2 ring-yellow-400 ring-inset'
                        : ''
                        }`}
                    >
                      <div className={`${silkscreenFont} p-2 text-center border-r flex items-center justify-center`}>
                        <span className="text-lg">{getPositionIcon(team.position)}</span>
                      </div>
                      <div className={`${silkscreenFont} p-2 border-r flex items-center`}>
                        {team.name}
                        {user?.equipe && teamData.find(t => t.id === user.equipe)?.nome === team.name && ' 👤'}
                      </div>
                      <div className={`${silkscreenFont} p-2 text-center border-r flex items-center justify-center`}>
                        {activeTab === 'PONTOS' ? team.points :
                          activeTab === 'VITORIAS' ? team.victories :
                            `${team.efficiency}%`}
                      </div>
                      <div className={`${silkscreenFont} p-2 text-center flex items-center justify-center`}>
                        {activeTab === 'PONTOS' ? team.victories :
                          activeTab === 'VITORIAS' ? `${team.efficiency}%` :
                            team.points}
                      </div>
                    </div>
                  ))}
                </div>

                <div className="flex justify-center">
                  <Button
                    onClick={handleOkClick}
                    className={`${buttonBaseStyle} px-6 py-2 bg-[#E3922A] text-white hover:bg-[#D4821A] shadow-[2px_2px_0px_0px_rgba(0,0,0,1)] hover:shadow-[1px_1px_0px_0px_rgba(0,0,0,1)] active:shadow-none active:translate-x-[2px] active:translate-y-[2px]`}
                  >
                    OK
                  </Button>
                </div>
              </CardContent>
            </Card>
          </div>
        </div>
      </div>
    </div>
  );
};
</file>

<file path="src/api/authService.ts">
import api from './config';

// --- INTERFACES CORRETAS ---
interface LoginCredentials {
  username: string;
  password: string;
}

// Interface que corresponde à resposta do backend (simple-jwt)
interface TokenResponse {
  access: string;
  refresh: string;
}

// Interface para os dados do usuário que vêm da API
interface UserProfileResponse {
  id: number;
  username: string;
  email: string;
  nickname: string;
  first_name?: string;
  last_name?: string;
  data_nascimento?: string;
  equipe?: number;
}

// Interface para atualização de perfil
interface UpdateProfileData {
  email?: string;
  first_name?: string;
  last_name?: string;
  data_nascimento?: string;
}

// Interface para dados de registro
interface RegisterData {
  username: string;
  password: string;
  password_confirm: string;
  email: string;
  first_name: string;
  last_name?: string;
  nickname: string;
  data_nascimento?: string;
}

// --- CLASSE DE SERVIÇO COM URLS E LÓGICA CORRIGIDAS ---

class AuthServiceClass {
  private tokenKey = 'token';
  private refreshTokenKey = 'refreshToken';

  /**
   * Realiza login do usuário.
   */
  async login(credentials: LoginCredentials): Promise<TokenResponse> {
    try {
      console.log('🔐 Tentando login com a URL correta...');

      // ✅ CORREÇÃO APLICADA: URL correta para obter o token
      const response = await api.post<TokenResponse>('/auth/token/', credentials);

      const { access, refresh } = response.data;

      if (access) {
        localStorage.setItem(this.tokenKey, access);
      }
      if (refresh) {
        localStorage.setItem(this.refreshTokenKey, refresh);
      }

      console.log('✅ Login bem-sucedido. Tokens armazenados.');
      return response.data;

    } catch (error: any) {
      console.error('❌ Erro no login:', error);
      this.logout(); // Limpa tokens em caso de falha
      if (error.response?.status === 401) {
        throw new Error('Usuário ou senha incorretos.');
      }
      throw new Error('Falha ao realizar login. Tente novamente mais tarde.');
    }
  }

// async register(userData: RegistrationData): Promise<any> {
//     try {
//       console.log('📝 Tentando registrar novo usuário...');
//       const response = await api.post('/auth/registro/', userData);
//       console.log('✅ Registro bem-sucedido:', response.data);
//       return response.data;
//     } catch (error: any) {
//       console.error('❌ Erro no registro:', error.response?.data || error.message);
//       throw error;
//     }
//   }

  /**
   * Obtém o perfil do usuário logado.
   */
  async getProfile(): Promise<{ data: UserProfileResponse }> {
    try {
      console.log('👤 Buscando perfil com a URL correta...');

      // ✅ CORREÇÃO APLICADA: URL correta para o perfil do usuário
      const response = await api.get<UserProfileResponse>('/auth/perfil/');

      console.log('✅ Perfil obtido com sucesso:', response.data.username);
      return { data: response.data };

    } catch (error: any) {
      console.error('❌ Erro ao obter perfil:', error);
      if (error.response?.status === 401) {
        this.logout();
      }
      throw error;
    }
  }

  /**
   * Registra um novo usuário.
   */
  async register(userData: RegisterData): Promise<any> {
    try {
      console.log('📝 Tentando registrar novo usuário...');

      const response = await api.post('/auth/registro/', userData);

      console.log('✅ Usuário registrado com sucesso');
      return response.data;

    } catch (error: any) {
      console.error('❌ Erro no registro:', error);
      if (error.response?.status === 400) {
        throw error; // Propaga o erro para o componente tratar
      }
      throw new Error('Falha ao realizar cadastro. Tente novamente mais tarde.');
    }
  }

  /**
   * Atualiza o perfil do usuário.
   */
  async updateProfile(userData: UpdateProfileData) {
    // ✅ URL CORRETA JÁ ESTAVA SENDO USADA
    return await api.patch('/auth/perfil/', userData);
  }

  /**
   * Faz logout do usuário, limpando os tokens.
   */
  logout(): void {
    console.log('👋 Fazendo logout e limpando tokens...');
    localStorage.removeItem(this.tokenKey);
    localStorage.removeItem(this.refreshTokenKey);
  }

  /**
   * Verifica se há um token de acesso armazenado.
   */
  isAuthenticated(): boolean {
    return !!localStorage.getItem(this.tokenKey);
  }

  /**
   * Retorna o token de acesso.
   */
  getToken(): string | null {
    return localStorage.getItem(this.tokenKey);
  }
}

// Exporta uma única instância da classe (Singleton Pattern)
const AuthService = new AuthServiceClass();
export default AuthService;
</file>

<file path="src/pages/Desafio/ApresentacaoDesafio.tsx">
import { useState, useEffect } from "react";
import { useNavigate } from "react-router-dom";
import { Button } from "../../components/ui/button";
import { ArrowLeft, Home, Trophy, Clock, Users, Truck, Car, ChevronLeft, ChevronRight, Loader2 } from 'lucide-react';
import { ButtonHomeBack } from "@/components/ButtonHomeBack";
import { AudioControl } from "@/components/AudioControl";
import { fetchChallengesFromBackend, FrontendChallenge } from "../../services/challengeService";

export const ApresentacaoDesafioPage = () => {
  const navigate = useNavigate();

  // Estados para gerenciar os desafios do backend
  const [availableChallenges, setAvailableChallenges] = useState<FrontendChallenge[]>([]);
  const [currentChallengeIndex, setCurrentChallengeIndex] = useState(0);
  const [carregando, setCarregando] = useState(false);
  const [carregandoDesafios, setCarregandoDesafios] = useState(true);
  const [erro, setErro] = useState<string | null>(null);

  const currentChallenge = availableChallenges[currentChallengeIndex];

  // Carregar desafios do backend ao montar o componente
  useEffect(() => {
    const loadChallenges = async () => {
      try {
        setCarregandoDesafios(true);
        setErro(null);
        
        console.log("🔍 Iniciando carregamento de desafios...");
        
        const challenges = await fetchChallengesFromBackend();
        
        console.log("🔍 Challenges recebidos:", challenges);
        
        if (challenges.length === 0) {
          setErro("Nenhum desafio encontrado no backend. Verifique se as seeds foram executadas.");
          return;
        }
        
        setAvailableChallenges(challenges);
        console.log("🎯 Desafios carregados com sucesso:", challenges);
      } catch (error) {
        console.error("❌ Erro ao carregar desafios:", error);
        
        const errorMessage = error instanceof Error ? error.message : 'Erro desconhecido';
        
        // Se for erro de autenticação, redirecionar para login
        if (errorMessage.includes('não autenticado') || errorMessage.includes('Sessão expirada')) {
          navigate('/login', { 
            state: { from: { pathname: '/desafios' } },
            replace: true 
          });
          return;
        }
        
        setErro(errorMessage);
      } finally {
        setCarregandoDesafios(false);
      }
    };

    loadChallenges();
  }, []);

  const handlePreviousChallenge = () => {
    setCurrentChallengeIndex((prev) => 
      prev === 0 ? availableChallenges.length - 1 : prev - 1
    );
  };

  const handleNextChallenge = () => {
    setCurrentChallengeIndex((prev) => 
      prev === availableChallenges.length - 1 ? 0 : prev + 1
    );
  };

  const handleAceitarDesafio = () => {
    if (!currentChallenge) return;

    console.log("🎯 DEBUG ApresentacaoDesafio - Desafio selecionado:", currentChallenge.id);
    console.log("🎯 DEBUG ApresentacaoDesafio - Backend ID:", currentChallenge.backendId);
    console.log("🎯 DEBUG ApresentacaoDesafio - Dados enviados:", {
      desafio: currentChallenge,
      challengeId: currentChallenge.backendId || currentChallenge.id
    });

    setCarregando(true);
    setTimeout(() => {
      setCarregando(false);
      // Passa o desafio selecionado para a próxima tela
      navigate("/select-vehicle", { state: { 
        desafio: currentChallenge,
        challengeId: currentChallenge.backendId || currentChallenge.id 
      } });
    }, 1500);
  };

  const getChallengeImage = (challengeId: string) => {
    // Usando a mesma imagem de fundo, mas poderia ser personalizada por desafio
    return "/desafio.png";
  };

  // Tela de carregamento
  if (carregandoDesafios) {
    return (
      <div className="flex h-screen items-center justify-center bg-gradient-to-b from-purple-600 to-blue-600 text-center p-4">
        <div className="bg-white rounded-lg p-8 shadow-lg">
          <Loader2 className="animate-spin h-12 w-12 text-purple-600 mx-auto mb-4" />
          <h1 className="[font-family:'Silkscreen',Helvetica] text-purple-600 text-xl mb-2">
            Carregando Desafios...
          </h1>
          <p className="[font-family:'Silkscreen',Helvetica] text-gray-600 text-sm">
            Buscando dados do servidor
          </p>
        </div>
      </div>
    );
  }

  // Tela de erro
  if (erro || !currentChallenge) {
    return (
      <div className="flex h-screen items-center justify-center bg-gradient-to-b from-red-400 to-red-600 text-center p-4">
        <div className="bg-white rounded-lg p-8 shadow-lg">
          <h1 className="[font-family:'Silkscreen',Helvetica] text-red-600 text-xl mb-4">
            {erro || "Nenhum desafio disponível."}
          </h1>
          <div className="space-y-2">
            <Button 
              onClick={() => window.location.reload()} 
              className="bg-red-600 text-white mr-2"
            >
              Tentar Novamente
            </Button>
            <Button 
              onClick={() => navigate('/game-selection')} 
              className="bg-gray-600 text-white"
            >
              Voltar para Seleção de Jogos
            </Button>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="bg-white flex flex-row justify-center w-full">
      <div className="w-full min-h-screen [background:linear-gradient(180deg,rgba(32,2,89,1)_0%,rgba(121,70,213,1)_100%)] relative overflow-hidden z-10">
        <div className="flex gap-5 absolute top-4 left-4 z-10">
          <ButtonHomeBack onClick={() => navigate(-1)}><ArrowLeft/></ButtonHomeBack>
          <ButtonHomeBack onClick={() => navigate("/perfil")}><Home/></ButtonHomeBack>
        </div>

        <div className="absolute top-4 right-4 z-10">
          <AudioControl />
        </div>

        <div className="pt-16 pb-8 px-4 flex justify-center items-center min-h-screen z-10">
          <div className="bg-white rounded-[18px] border-2 border-solid border-black shadow-[4px_4px_0px_0px_rgba(0,0,0,1)] w-full max-w-[1000px] max-h-[85vh] overflow-hidden flex flex-col">
            
            {/* Header com navegação do carrossel */}
            <div className="p-4 border-b-2 border-black bg-gray-50 flex items-center justify-between">
              <Button
                onClick={handlePreviousChallenge}
                className="p-2 bg-[#e3922a] border-2 border-black rounded-md hover:bg-[#d4831f] transition-colors"
                disabled={availableChallenges.length <= 1}
              >
                <ChevronLeft size={20} className="text-white" />
              </Button>
              
              <div className="text-center flex-1">
                <h1 className="text-[22px] [font-family:'Silkscreen',Helvetica] font-bold text-[#e3922a]">
                  {currentChallenge.name}
                </h1>
                <p className="text-[12px] [font-family:'Silkscreen',Helvetica] text-gray-600 mt-1">
                  {currentChallengeIndex + 1} de {availableChallenges.length}
                </p>
              </div>
              
              <Button
                onClick={handleNextChallenge}
                className="p-2 bg-[#e3922a] border-2 border-black rounded-md hover:bg-[#d4831f] transition-colors"
                disabled={availableChallenges.length <= 1}
              >
                <ChevronRight size={20} className="text-white" />
              </Button>
            </div>
            
            <div className="overflow-y-auto p-4 flex-1">
              {/* Imagem do desafio */}
              <div className="border-2 border-black rounded-lg overflow-hidden h-[200px] mb-4 relative">
                <img 
                  src={getChallengeImage(currentChallenge.id)} 
                  alt={`Desafio ${currentChallenge.name}`} 
                  className="w-full h-full object-cover" 
                />
                <div className="absolute inset-0 bg-gradient-to-r from-blue-500/20 to-purple-500/20 flex items-center justify-center">
                  <div className="text-center text-white">
                    <h2 className="text-2xl [font-family:'Silkscreen',Helvetica] font-bold mb-2   ">
                      JUAZEIRO → {currentChallenge.destination.split(',')[0].toUpperCase()}
                    </h2>
                    <p className="text-sm [font-family:'Silkscreen',Helvetica]">
                      {currentChallenge.routes.length} rota{currentChallenge.routes.length > 1 ? 's' : ''} disponível{currentChallenge.routes.length > 1 ? 'is' : ''}
                    </p>
                  </div>
                </div>
              </div>

              {/* Descrição */}
              <div className="border-2 border-black rounded-lg p-3 bg-gray-50 mb-4">
                <h3 className="[font-family:'Silkscreen',Helvetica] font-bold text-[14px] mb-2">DESCRIÇÃO:</h3>
                <p className="[font-family:'Silkscreen',Helvetica] text-[12px]">{currentChallenge.description}</p>
              </div>

              {/* Detalhes */}
              <div className="border-2 border-black rounded-lg p-3 bg-gray-50 mb-4">
                <h3 className="[font-family:'Silkscreen',Helvetica] font-bold text-[14px] mb-2">DETALHES:</h3>
                <div className="grid grid-cols-2 gap-2">
                  <div className="flex items-center">
                    <Trophy size={16} className="text-[#e3922a] mr-2 flex-shrink-0" />
                    <span className="[font-family:'Silkscreen',Helvetica] text-[11px]">DIFICULDADE: {currentChallenge.difficulty}</span>
                  </div>
                  <div className="flex items-center">
                    <Clock size={16} className="text-[#e3922a] mr-2 flex-shrink-0" />
                    <span className="[font-family:'Silkscreen',Helvetica] text-[11px]">TEMPO: {currentChallenge.estimatedDuration}</span>
                  </div>
                  <div className="flex items-center col-span-2">
                    <Truck size={16} className="text-[#e3922a] mr-2 flex-shrink-0" />
                    <span className="[font-family:'Silkscreen',Helvetica] text-[11px]">DESTINO: {currentChallenge.destination}</span>
                  </div>
                </div>
              </div>

              {/* Objetivo */}
              <div className="border-2 border-black rounded-lg p-3 bg-gray-50 mb-4">
                <h3 className="[font-family:'Silkscreen',Helvetica] font-bold text-[14px] mb-2 text-green-600">OBJETIVO:</h3>
                <p className="[font-family:'Silkscreen',Helvetica] text-[12px] font-bold text-green-600">
                  {currentChallenge.objective || `Transportar carga de Juazeiro para ${currentChallenge.destination} escolhendo a melhor rota considerando custos, tempo e segurança.`}
                </p>
              </div>

              {/* Ferramentas (se disponível) */}
              {currentChallenge.tools && currentChallenge.tools.length > 0 && (
                <div className="border-2 border-black rounded-lg p-3 bg-blue-50 mb-4">
                  <h3 className="[font-family:'Silkscreen',Helvetica] font-bold text-[14px] mb-2 text-blue-600">FERRAMENTAS DISPONÍVEIS:</h3>
                  <div className="space-y-2">
                    {currentChallenge.tools.map((tool, index) => (
                      <div key={index} className="flex items-start">
                        <Car size={14} className="text-blue-600 mr-2 flex-shrink-0 mt-1" />
                        <div>
                          <span className="[font-family:'Silkscreen',Helvetica] text-[11px] font-bold block text-blue-600">
                            {tool.type}
                          </span>
                          <span className="[font-family:'Silkscreen',Helvetica] text-[10px] text-gray-700">
                            {tool.description}
                          </span>
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
              )}

              {/* Rotas disponíveis */}
              <div className="border-2 border-dashed border-[#e3922a] rounded-lg p-3 bg-yellow-50 mb-4">
                <h3 className="[font-family:'Silkscreen',Helvetica] font-bold text-[14px] mb-2">ROTAS DISPONÍVEIS:</h3>
                <div className="space-y-2">
                  {currentChallenge.routes.slice(0, 3).map((route, index) => (
                    <div key={route.routeId} className="flex items-start">
                      <Truck size={14} className="text-[#e3922a] mr-2 flex-shrink-0 mt-1" />
                      <div>
                        <span className="[font-family:'Silkscreen',Helvetica] text-[11px] font-bold block">
                          Rota {route.routeId}: {route.distance}km
                        </span>
                        <span className="[font-family:'Silkscreen',Helvetica] text-[10px] text-gray-700">
                          {route.estimatedTime} - {route.roadConditions} - {route.safety.robberyRisk} risco
                        </span>
                      </div>
                    </div>
                  ))}
                  {currentChallenge.routes.length > 3 && (
                    <p className="[font-family:'Silkscreen',Helvetica] text-[10px] text-gray-600 text-center">
                      +{currentChallenge.routes.length - 3} rota{currentChallenge.routes.length - 3 > 1 ? 's' : ''} adicional{currentChallenge.routes.length - 3 > 1 ? 'is' : ''}
                    </p>
                  )}
                </div>
              </div>
            </div>
            
            <div className="p-4 border-t-2 flex justify-center border-black bg-gray-50">
              <Button 
                onClick={handleAceitarDesafio}
                disabled={carregando}
                className="w-1/2 py-3 bg-[#29D8FF] border-2 border-black rounded-md [font-family:'Silkscreen',Helvetica] font-bold text-black text-[16px] hover:bg-[#20B4D2] transform transition-transform duration-300 hover:scale-105 disabled:opacity-70 disabled:cursor-not-allowed flex items-center justify-center"
              >
                {carregando ? (
                  <>
                    <div className="animate-spin rounded-full h-5 w-5 border-4 border-white border-t-black mr-2"></div>
                    CARREGANDO...
                  </>
                ) : (
                  <>
                    <Trophy className="mr-2" size={20} />
                    ACEITAR DESAFIO
                  </>
                )}
              </Button>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

export default ApresentacaoDesafioPage;
</file>

<file path="src/pages/Perfil/PerfilPage.tsx">
import { useNavigate } from "react-router-dom";
import { useState } from "react";
import { useQuery } from "@tanstack/react-query";
import { useAuth } from "../../contexts/AuthContext";
import { TeamService } from "../../api/teamService";
import { Button } from "../../components/ui/button";
import {
  Card,
  CardContent,
} from "../../components/ui/card";
import { AudioControl } from "../../components/AudioControl";
import { PlayIcon, Trophy, TruckIcon, MapPin, DollarSign, X } from 'lucide-react';

interface UserStats {
  deliveries: number;
  distance: number;
  earnings: number;
  victories: number;
}

export const PerfilPage = () => {
  const navigate = useNavigate();
  // Removido o useRef para o input de arquivo
  const { user, logout, refreshUser } = useAuth();

  // Buscar dados da equipe se o usuário estiver em uma
  const { data: teamData } = useQuery({
    queryKey: ['teamDetails', user?.equipe],
    queryFn: () => TeamService.getTeamDetails(user!.equipe!),
    enabled: !!user?.equipe, // Só busca se o usuário estiver em uma equipe
  });

  // Stats ainda estáticos (podem ser implementados depois)
  const [userStats] = useState<UserStats>({
    deliveries: 12,
    distance: 12,
    earnings: 12,
    victories: 12
  });

  // Lista de avatares predefinidos
  const presetAvatars = [
    "/assets/avatars/perfil_caminhao.png",
    "/assets/avatars/perfil_volante.png",
    "/assets/avatars/perfil1.png",
    "/assets/avatars/perfil2.png",
    "/assets/avatars/perfil3.png",
    "/assets/avatars/perfil4.png",
    "/assets/avatars/perfil5.png",
  ];

  // Estado para controlar a visibilidade do seletor de avatares
  const [showAvatarPicker, setShowAvatarPicker] = useState(false);
  // Estado para o avatar local, inicializado com o primeiro da lista de presets
  const [localAvatar, setLocalAvatar] = useState<string>(presetAvatars[0]);

  // Função para lidar com a seleção de um avatar predefinido
  const handleSelectAvatar = (avatarUrl: string) => {
    setLocalAvatar(avatarUrl);
    setShowAvatarPicker(false); // Fecha o seletor após a escolha
  };

  const handlePlayNow = () => {
    navigate("/desafio");
  };

  const handleContinueGame = () => {
    const savedProgress = localStorage.getItem('savedGameProgress');

    if (savedProgress) {
      try {
        const gameProgress = JSON.parse(savedProgress);
        console.log('Carregando progresso salvo:', gameProgress);

        navigate('/game', {
          state: {
            selectedVehicle: gameProgress.vehicle,
            availableMoney: gameProgress.money,
            selectedRoute: gameProgress.selectedRoute,
            savedProgress: {
              currentFuel: gameProgress.currentFuel,
              progress: gameProgress.progress,
              currentPathIndex: gameProgress.currentPathIndex,
              pathProgress: gameProgress.pathProgress,
              gameTime: gameProgress.gameTime,
              activeGameId: gameProgress.activeGameId
            }
          }
        });
      } catch (error) {
        console.error('Erro ao carregar progresso:', error);
        alert('Erro ao carregar o jogo salvo. Iniciando novo jogo...');
        navigate("/select-vehicle");
      }
    } else {
      const startNewGame = window.confirm('Não há jogo salvo. Deseja iniciar um novo jogo?');
      if (startNewGame) {
        navigate("/desafio");
      }
    }
  };

  const handleCheckRanking = () => {
    navigate("/ranking", { state: { from: 'profile' } });
  };

  const handleEditProfile = () => {
    navigate("/perfil/editar");
  };

  const handleChangePassword = () => {
    navigate("/mudar-senha");
  };

  const handleGetOutTeam = async () => {
    if (!user?.equipe) return;
    try {
      await TeamService.leaveTeam();
      await refreshUser();
      alert("Você saiu da equipe com sucesso!");
    } catch (error) {
      alert("Erro ao sair da equipe. Tente novamente.");
    }
  };

  const handleLogout = () => {
    logout();
    navigate("/login");
  };

  const handleManageTeam = () => {
    if (user?.equipe) {
      navigate("/perfil/editar-equipe");
    } else {
      navigate("/choose-team");
    }
  };

  if (!user) {
    navigate("/login");
    return null;
  }

  const displayName = user.first_name && user.last_name
    ? `${user.first_name} ${user.last_name}`
    : user.nickname || user.username;

  const teamDisplayName = teamData?.nome || "SEM EQUIPE";

  const titleStyle = {
    color: "#E3922A",
    textShadow: "2px 3px 0.6px #000"
  };

  return (
    <div className="bg-white flex flex-row justify-center w-full">
      <div className="w-full min-h-screen [background:linear-gradient(180deg,rgba(57,189,248,1)_0%,rgba(154,102,248,1)_100%)] relative overflow-hidden">
        {/* Nuvens decorativas */}
        <img
          className="w-[375px] h-[147px] absolute top-[120px] left-[157px] object-cover animate-float-right"
          alt="Cloud decoration"
          src="/nuvemleft.png"
        />
        <img
          className="w-[436px] h-[170px] absolute bottom-[30px] right-[27px] object-cover animate-float-left opacity-75 scale-110"
          alt="Cloud decoration"
          src="/nuvemright.png"
        />

        {/* Modal de seleção de avatar - Adicionado para substituir o upload */}
        {showAvatarPicker && (
          <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70">
            <Card className="p-6 w-11/12 md:w-1/2 lg:w-1/3 border-2 border-black">
              <div className="flex justify-between items-center mb-4 border-b-2 border-black pb-2">
                <h3 className="[font-family:'Silkscreen',Helvetica] font-bold text-xl" style={titleStyle}>
                  ESCOLHA SEU AVATAR
                </h3>
                <Button variant="ghost" onClick={() => setShowAvatarPicker(false)} className="text-white hover:text-gray-300 p-1">
                  <X size={24} />
                </Button>
              </div>
              <div className="grid grid-cols-4 gap-4 mt-4">
                {presetAvatars.map((avatar, index) => (
                  <img
                    key={index}
                    src={avatar}
                    alt={`Avatar ${index + 1}`}
                    // CORREÇÃO: Adicionada a classe object-cover aqui
                    className={`w-16 h-16 rounded-full cursor-pointer transition-transform duration-200 transform hover:scale-110 border-2 object-cover ${localAvatar === avatar ? 'border-orange-500 shadow-lg' : 'border-black'}`}
                    onClick={() => handleSelectAvatar(avatar)}
                  />
                ))}
              </div>
            </Card>
          </div>
        )}

        {/* Controle de áudio */}
        <div className="absolute top-14 right-8 z-20">
          <AudioControl />
        </div>

        {/* Conteúdo principal */}
        <div className="max-w-5xl mx-auto pt-20 px-4 relative z-10">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">

            {/* Coluna esquerda - Informações do perfil */}
            <div className="space-y-4">
              <Card className="border-2 border-solid border-black rounded-lg overflow-hidden">
                <CardContent className="p-4">
                  <div className="text-center">
                    <h2 className="[font-family:'Silkscreen',Helvetica] font-bold text-2xl pb-1 border-b-2 border-black" style={titleStyle}>
                      SEU PERFIL
                    </h2>

                    {/* Seção do avatar - Agora clica para abrir o seletor */}
                    <div className="mt-3 flex justify-center">
                      <div className="relative">
                        <div
                          className="w-24 h-24 rounded-full bg-teal-100 border-4 border-teal-500 flex items-center justify-center overflow-hidden relative group cursor-pointer"
                          onClick={() => setShowAvatarPicker(true)}
                        >
                          <img
                            src={localAvatar}
                            alt="Avatar"
                            className="w-20 h-20 object-cover rounded-full"
                          />
                        </div>
                      </div>
                    </div>

                    {/* Nome do usuário - usando dados reais */}
                    <h3 className="[font-family:'Silkscreen',Helvetica] font-bold text-center text-xl mt-2">
                      {displayName.toUpperCase()}
                    </h3>

                    {/* Informações da equipe - usando dados reais do backend */}
                    <div
                      className="mt-4 [font-family:'Silkscreen',Helvetica] cursor-pointer hover:bg-gray-100 p-2 rounded transition-colors flex items-center gap-2"
                      onClick={handleManageTeam}
                    >
                      <span className="font-bold">EQUIPE: </span>
                      <span className={`font-bold ${user.equipe ? 'text-orange-500' : 'text-gray-500'}`}>
                        {teamDisplayName}
                      </span>
                      {user.equipe && (
                        <>
                          <Button
                            size="sm"
                            variant="destructive"
                            className="ml-2 px-2 py-1 text-xs border-2 border-black"
                            onClick={e => { e.stopPropagation(); handleGetOutTeam(); }}
                          >
                            SAIR
                          </Button>

                        </>
                      )}
                      <div className="text-xs text-gray-600 mt-1">
                        {user.equipe ? 'Clique para gerenciar' : 'Clique para entrar em uma equipe'}
                      </div>
                    </div>

                    {/* Botões de ação */}
                    <div className="grid grid-cols-3 gap-2 mt-3">
                      <Button
                        variant="outline"
                        className="flex flex-col items-center justify-center h-16 border-2 border-black"
                        onClick={handleEditProfile}
                      >
                        <span className="text-2xl">👤</span>
                        <span className="text-xs [font-family:'Silkscreen',Helvetica]">EDITAR PERFIL</span>
                      </Button>
                      <Button
                        variant="outline"
                        className="flex flex-col items-center justify-center h-16 border-2 border-black"
                        onClick={handleChangePassword}
                      >
                        <span className="text-2xl">🔑</span>
                        <span className="text-xs [font-family:'Silkscreen',Helvetica]">SENHA</span>
                      </Button>
                      <Button
                        variant="outline"
                        className="flex flex-col items-center justify-center h-16 border-2 border-black"
                        onClick={handleLogout}
                      >
                        <span className="text-2xl">↪️</span>
                        <span className="text-xs [font-family:'Silkscreen',Helvetica]">SAIR</span>
                      </Button>
                    </div>
                  </div>
                </CardContent>
              </Card>
            </div>

            {/* Coluna direita - Informações do jogo e estatísticas */}
            <div className="space-y-4">
              {/* Card de jogar */}
              <Card className="border-2 border-solid border-black rounded-lg overflow-hidden">
                <CardContent className="p-4">
                  {/* Título do jogo e botão de jogar */}
                  <div className="flex justify-between items-center">
                    {/* Informações do jogo */}
                    <div>
                      <h2 className="[font-family:'Silkscreen',Helvetica] font-bold text-2xl" style={titleStyle}>
                        ENTREGA EFICIENTE
                      </h2>
                      <p className="[font-family:'Silkscreen',Helvetica] text-sm mt-1">
                        CONTINUE SUA JORNADA DE ENTREGAS!
                      </p>
                    </div>

                    {/* Botão de jogar */}
                    <Button
                      onClick={handlePlayNow}
                      className="bg-orange-400 text-black hover:bg-orange-500 h-12 flex items-center justify-between px-4 rounded border-2 border-black [font-family:'Silkscreen',Helvetica] font-bold"
                    >
                      <span>JOGAR AGORA</span>
                      <PlayIcon className="ml-2" />
                    </Button>
                  </div>

                  {/* Link para outros jogos */}
                  <div className="text-center mt-1">
                    <button
                      onClick={() => navigate("/game-selection")}
                      className="text-xs underline [font-family:'Silkscreen',Helvetica] text-blue-500"
                    >
                      JOGAR OUTRO JOGO!
                    </button>
                  </div>
                </CardContent>
              </Card>

              {/* Grid de estatísticas */}
              <div className="grid grid-cols-4 gap-3">
                {/* Entregas */}
                <Card className="border-2 border-solid border-black rounded-lg overflow-hidden">
                  <CardContent className="py-3 px-4 flex flex-col items-center">
                    <TruckIcon size={24} />
                    <div className="[font-family:'Silkscreen',Helvetica] text-center mt-1">
                      <span className="text-xs">ENTREGAS</span>
                      <div className="font-bold">{userStats.deliveries}</div>
                    </div>
                  </CardContent>
                </Card>

                {/* Distância */}
                <Card className="border-2 border-solid border-black rounded-lg overflow-hidden">
                  <CardContent className="py-3 px-4 flex flex-col items-center">
                    <MapPin size={24} color="#4ade80" />
                    <div className="[font-family:'Silkscreen',Helvetica] text-center mt-1">
                      <span className="text-xs">DISTÂNCIA</span>
                      <div className="font-bold">{userStats.distance}</div>
                    </div>
                  </CardContent>
                </Card>

                {/* Ganhos */}
                <Card className="border-2 border-solid border-black rounded-lg overflow-hidden">
                  <CardContent className="py-3 px-4 flex flex-col items-center">
                    <DollarSign size={24} color="#eab308" />
                    <div className="[font-family:'Silkscreen',Helvetica] text-center mt-1">
                      <span className="text-xs">GANHOS</span>
                      <div className="font-bold">{userStats.earnings}</div>
                    </div>
                  </CardContent>
                </Card>

                {/* Vitórias */}
                <Card className="border-2 border-solid border-black rounded-lg overflow-hidden">
                  <CardContent className="py-3 px-4 flex flex-col items-center">
                    <span className="text-2xl">🏆</span>
                    <div className="[font-family:'Silkscreen',Helvetica] text-center mt-1">
                      <span className="text-xs">VITÓRIAS</span>
                      <div className="font-bold">{userStats.victories}</div>
                    </div>
                  </CardContent>
                </Card>
              </div>

              {/* Cards de ação */}
              <div className="grid grid-cols-2 gap-3">
                {/* Card de ranking */}
                <Card className="border-2 border-solid border-black rounded-lg overflow-hidden cursor-pointer hover:bg-gray-50 transition-colors">
                  <CardContent className="p-4" onClick={handleCheckRanking}>
                    <div className="flex items-center">
                      <Trophy size={32} className="text-yellow-500" />
                      <div className="ml-3">
                        <h3 className="[font-family:'Silkscreen',Helvetica] font-bold" style={titleStyle}>
                          RANKING
                        </h3>
                        <p className="[font-family:'Silkscreen',Helvetica] text-xs">
                          VEJA OS MELHORES JOGADORES
                        </p>
                      </div>
                    </div>
                  </CardContent>
                </Card>

                {/* Card de continuar jogo */}
                <Card className="border-2 border-solid border-black rounded-lg overflow-hidden cursor-pointer hover:bg-gray-50 transition-colors">
                  <CardContent className="p-4" onClick={handleContinueGame}>
                    <div className="flex items-center">
                      <div className="w-8 h-8 bg-purple-700 rounded-full flex items-center justify-center">
                        <span className="text-white text-2xl">{localStorage.getItem('savedGameProgress') ? '⏱️' : '🎮'}</span>
                      </div>
                      <div className="ml-3">
                        <h3 className="[font-family:'Silkscreen',Helvetica] font-bold" style={titleStyle}>
                          {localStorage.getItem('savedGameProgress') ? 'CONTINUAR' : 'NOVO JOGO'}
                        </h3>
                        <p className="[font-family:'Silkscreen',Helvetica] text-xs">
                          {localStorage.getItem('savedGameProgress')
                            ? 'RETOMAR A ÚLTIMA PARTIDA'
                            : 'INICIAR NOVA AVENTURA'}
                        </p>
                      </div>
                    </div>
                  </CardContent>
                </Card>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

export default PerfilPage;
</file>

<file path="src/pages/RoutesPage/RoutesPage.tsx">
import React, { useState, useMemo } from 'react';
import { useLocation, useNavigate } from 'react-router-dom';
import { useQuery } from '@tanstack/react-query';
import { ArrowLeft } from 'lucide-react';
import { GameService } from '../../api/gameService';
import { MapComponent } from '../mapaRota/MapComponent';
import { routes as staticRoutesData, getRoutesByChallenge } from '../mapaRota/routesData';
import { ChallengeId } from '../mapaRota/constants';
import { debugChallenges } from '../mapaRota/challengesManager';
import { AudioControl } from '../../components/AudioControl';

interface ApiRoute {
  id: number;
  nome: string;
  descricao: string;
  distancia_km: number;
  tempo_estimado_horas: number;
  tipo_estrada: string;
  velocidade_media_kmh: number;
  danger_zones_data: any[];
  dirt_segments_data: any[];
  mapaId: number;
  routeId: number;
  name: string;
  distance: number;
  estimatedTime: string;
  estimatedTimeHours: number;
  dirtRoad: boolean;
  safety: { robberyRisk: 'Baixo' | 'Médio' | 'Alto'; };
  tollBooths: any[];
  speedLimits: any[];
  roadConditions: string;
  pathCoordinates?: [number, number][];
  actualDistance?: number;
  actualDuration?: number;
  dirtSegments?: any[];
  dangerZones?: any[];
  fuelStop?: any[];
}

export const RoutesPage: React.FC = () => {
  const location = useLocation();
  const navigate = useNavigate();

  const vehicle = location.state?.selectedVehicle || {
    id: 'carreta', name: 'Carreta', capacity: 60,
    consumption: { asphalt: 2, dirt: 1.5 },
    image: '/carreta.png', maxCapacity: 495, currentFuel: 0, cost: 4500
  };
  const availableMoney = location.state?.availableMoney || 5500;
  const selectedChallenge = location.state?.selectedChallenge;
  const backendChallengeId = location.state?.challengeId;
  
  // Função para mapear ID numérico do backend para ChallengeId string
  const mapBackendIdToChallengeId = (backendId: number | string): ChallengeId => {
    // Se já for string, usar diretamente
    if (typeof backendId === 'string') {
      return backendId as ChallengeId;
    }
    
    // Mapear ID numérico para string baseado nos dados do selectedChallenge
    if (selectedChallenge?.name) {
      const name = selectedChallenge.name.toUpperCase();
      if (name.includes('SALVADOR')) return 'salvador';
      if (name.includes('RECIFE')) return 'recife';
      if (name.includes('FORTALEZA')) return 'fortaleza';
    }
    
    // Fallback baseado no ID numérico
    switch (Number(backendId)) {
      case 1: return 'salvador';
      case 2: return 'recife';
      case 3: return 'fortaleza';
      default: return 'salvador';
    }
  };
  
  const challengeId = mapBackendIdToChallengeId(backendChallengeId) || 'salvador';
  
  // Debug: verificar se o challengeId está correto
  console.log("🎯 DEBUG RoutesPage - backendChallengeId recebido:", backendChallengeId);
  console.log("🎯 DEBUG RoutesPage - challengeId convertido:", challengeId);
  console.log("🎯 DEBUG RoutesPage - selectedChallenge:", selectedChallenge);
  console.log("🎯 DEBUG RoutesPage - location.state:", location.state);
  
  // Debug: testar todos os desafios
  debugChallenges();

  const [selectedRoute, setSelectedRoute] = useState<ApiRoute | null>(null);

  // Como agora usamos apenas dados estáticos dos desafios, não precisamos da API
  const isLoading = false;
  const isError = false;
  const error = null;
  const refetch = () => {};

  // 🔧 USANDO APENAS AS ROTAS DO DESAFIO SELECIONADO
  const allRoutes = useMemo(() => {
    // Usar diretamente as rotas do desafio selecionado
    const challengeRoutes = getRoutesByChallenge(challengeId);
    console.log(`🗺️ Usando rotas do desafio: ${challengeId}`);
    console.log("📍 Rotas disponíveis:", challengeRoutes.map(r => r.name));
    console.log("📍 Quantidade de rotas:", challengeRoutes.length);
    console.log("📍 Detalhes das rotas:", challengeRoutes);

    // Converter as rotas do desafio para o formato esperado pela interface
    const formattedRoutes = challengeRoutes.map(route => ({
      id: route.routeId,
      nome: route.name,
      descricao: route.name,
      distancia_km: route.distance,
      tempo_estimado_horas: route.estimatedTimeHours,
      tipo_estrada: route.roadConditions || 'Boa',
      velocidade_media_kmh: Math.round(route.distance / route.estimatedTimeHours),
      danger_zones_data: route.dangerZones || [],
      dirt_segments_data: route.dirtSegments || [],
      mapaId: 1,
      routeId: route.routeId,
      name: route.name,
      distance: route.distance,
      estimatedTime: route.estimatedTime,
      estimatedTimeHours: route.estimatedTimeHours,
      dirtRoad: route.dirtRoad || false,
      safety: route.safety || { robberyRisk: 'Médio' },
      tollBooths: route.tollBooths || [],
      speedLimits: route.speedLimits || [],
      roadConditions: route.roadConditions || 'Boa',
      pathCoordinates: route.pathCoordinates,
      actualDistance: route.actualDistance || route.distance,
      actualDuration: route.actualDuration || (route.estimatedTimeHours * 3600),
      dirtSegments: route.dirtSegments || [],
      dangerZones: route.dangerZones || [],
      fuelStop: route.fuelStop || []
    }));

    console.log(`✅ ${formattedRoutes.length} rotas formatadas para o desafio ${challengeId}`);
    return formattedRoutes;
  }, [challengeId]);

  const handleSelectRoute = (routeId: number) => {
    const routeToSelect = allRoutes.find(r => r.id === routeId);
    if (routeToSelect) {
      console.log("🗺️ Rota selecionada:", routeToSelect.name);
      console.log("📍 PathCoordinates disponíveis:", !!routeToSelect.pathCoordinates);
      console.log("📊 Dados completos da rota:", {
        id: routeToSelect.id,
        nome: routeToSelect.name,
        pathCoordinates: routeToSelect.pathCoordinates?.length || 0,
        dirtSegments: routeToSelect.dirtSegments?.length || 0,
        tollBooths: routeToSelect.tollBooths?.length || 0,
        dangerZones: routeToSelect.dangerZones?.length || 0,
        fuelStop: routeToSelect.fuelStop?.length || 0
      });
      setSelectedRoute(routeToSelect);
    }
  };

  const handleContinue = () => {
    if (selectedRoute) {
      // VALIDAÇÃO CRÍTICA: Verificar se temos pathCoordinates
      if (!selectedRoute.pathCoordinates || selectedRoute.pathCoordinates.length === 0) {
        console.error("❌ Rota sem coordenadas! Dados da rota:", selectedRoute);
        alert("Erro: Esta rota não possui dados de mapa. Por favor, escolha outra rota.");
        return;
      }

      // ✅ CORREÇÃO: Logs detalhados antes de navegar
      console.log("✅ Continuando com a rota:", selectedRoute.name);
      console.log("📋 Dados completos enviados:", {
        vehicle: vehicle.name,
        money: availableMoney,
        route: {
          id: selectedRoute.id,
          routeId: selectedRoute.routeId,
          mapaId: selectedRoute.mapaId,
          name: selectedRoute.name,
          pathCoordinatesLength: selectedRoute.pathCoordinates.length
        }
      });

      // Garantir que TODOS os dados necessários sejam passados
      navigate('/fuel', {
        state: {
          vehicle,
          availableMoney,
          selectedRoute: {
            ...selectedRoute,
            // Garantir explicitamente que pathCoordinates seja incluído
            pathCoordinates: selectedRoute.pathCoordinates
          },
          selectedChallenge,
          challengeId
        }
      });
    }
  };

  const goBack = () => {
    navigate('/select-vehicle');
  };

  // ✅ CORREÇÃO: Melhor tratamento de estados de loading/erro
  if (isLoading) {
    return (
      <div className="min-h-screen bg-[#200259] font-['Silkscreen'] flex items-center justify-center">
        <div className="text-center">
          <div className="text-[#E3922A] text-2xl mb-4">🚛 Carregando rotas...</div>
          <div className="text-white">Buscando dados atualizados do servidor</div>
          <button
            onClick={() => refetch()}
            className="mt-4 bg-[#E3922A] text-black font-bold px-4 py-2 rounded-md hover:bg-[#FFC06F]"
          >
            🔄 Tentar Novamente
          </button>
        </div>
      </div>
    );
  }

  if (isError) {
    return (
      <div className="min-h-screen bg-[#200259] font-['Silkscreen'] flex items-center justify-center">
        <div className="text-center">
          <div className="text-red-500 text-2xl mb-4">❌ Erro ao carregar rotas</div>
          <div className="text-white mb-4">
            {error instanceof Error ? error.message : 'Erro desconhecido'}
          </div>
          <div className="flex gap-2 justify-center">
            <button
              onClick={() => refetch()}
              className="bg-[#E3922A] text-black font-bold px-6 py-3 rounded-md hover:bg-[#FFC06F]"
            >
              🔄 Recarregar Dados
            </button>
            <button
              onClick={() => navigate('/select-vehicle')}
              className="bg-gray-600 text-white font-bold px-6 py-3 rounded-md hover:bg-gray-700"
            >
              ← Voltar
            </button>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-[#200259] font-['Silkscreen']">
      {/* Header */}
      <div className="bg-[#200259] border-b-2 border-[#E3922A] px-3 py-2">
        <div className="flex items-center justify-between mx-auto">
          <button
            className="flex items-center gap-1 px-3 py-1.5 bg-[#E3922A] text-black font-bold text-sm rounded-md shadow-lg
                     hover:bg-[#FFC06F] transition-all duration-200 border-2 border-black"
            onClick={goBack}
          >
            <ArrowLeft size={16} /> VOLTAR
          </button>

          <h1 className="text-lg lg:text-xl font-bold text-[#E3922A] text-center">
            ESCOLHA SUA ROTA
          </h1>

          <div className="flex items-center gap-2">
            <AudioControl />
            <div className="bg-[#E3922A] text-black text-sm lg:text-base font-bold px-3 py-1.5 rounded-md shadow-lg border-2 border-black">
              R$ {availableMoney.toFixed(2)}
            </div>
          </div>
        </div>
      </div>

      {/* Conteúdo principal */}
      <div className="flex flex-col lg:flex-row gap-3 p-3 h-[calc(100vh-60px)] max-h-[calc(100vh-60px)] overflow-hidden">

        {/* 🗺️ MAPA */}
        <div className="lg:w-2/3 h-full lg:h-full flex flex-col min-h-[300px] lg:min-h-0">
          <div className="flex-1 min-h-0 overflow-hidden rounded-lg border-2 border-gray-300">
            {selectedRoute ? (
              <div className="w-full h-full max-h-full overflow-hidden">
                <div className="w-full h-full">
                  <MapComponent
                    preSelectedRoute={selectedRoute}
                    preSelectedVehicle={vehicle}
                    preAvailableMoney={availableMoney}
                    showControls={false}
                  />
                </div>
              </div>
            ) : (
              <div className="w-full h-full flex items-center justify-center bg-gradient-to-br from-gray-100 to-gray-200">
                <div className="text-center text-gray-600 font-['Silkscreen'] p-4">
                  <div className="text-4xl mb-3">🗺️</div>
                  <p className="text-lg font-bold mb-1 text-gray-700">Selecione uma rota</p>
                  <p className="text-sm text-gray-500">para visualizar no mapa</p>
                </div>
              </div>
            )}
          </div>
        </div>

        {/* Lista de Rotas */}
        <div className="lg:w-2/5 flex flex-col h-full lg:h-full min-h-[400px] lg:min-h-0">
          <div className="bg-[#E3922A] text-black p-2 rounded-t-lg border-2 border-black mb-0 flex-shrink-0">
            <h2 className="text-lg font-['Silkscreen'] font-bold text-center">
              ROTAS DISPONÍVEIS ({allRoutes.length})
            </h2>
          </div>

          <div className="flex-1 min-h-0 overflow-y-auto bg-gray-100 border-x-2 border-black p-2 space-y-2">
            {allRoutes.length === 0 ? (
              <div className="text-center text-gray-500 py-8">
                <div className="text-2xl mb-2">🚫</div>
                <p>Nenhuma rota encontrada</p>
                <button
                  onClick={() => refetch()}
                  className="mt-2 bg-[#E3922A] text-black font-bold px-4 py-2 rounded-md hover:bg-[#FFC06F] text-sm"
                >
                  🔄 Recarregar
                </button>
              </div>
            ) : (
              allRoutes.map((route) => (
                <div
                  key={route.id}
                  className={`p-2 rounded-lg cursor-pointer transition-all duration-200 border-2
                    ${selectedRoute?.id === route.id
                      ? 'bg-yellow-300 border-yellow-600 shadow-lg'
                      : 'bg-white border-gray-300 hover:bg-gray-50 hover:border-gray-400'}
                    `}
                  onClick={() => handleSelectRoute(route.id)}
                >
                  <h3 className="font-['Silkscreen'] font-bold text-sm text-black mb-2 border-b border-gray-300 pb-1">
                    {route.nome}
                  </h3>

                  <div className="grid grid-cols-1 md:grid-cols-2 gap-2">
                    <div className="space-y-0.5">
                      <p className="font-['Silkscreen'] text-black text-xs">
                        <span>⏱️ TEMPO:</span> {route.estimatedTime}
                      </p>
                      <p className="font-['Silkscreen'] text-black text-xs">
                        <span>📏 DISTÂNCIA:</span> {route.distance.toFixed(0)} km
                      </p>
                    </div>

                    <div className="space-y-0.5">
                      <p className="font-['Silkscreen'] text-black text-xs flex items-center">
                        <span>🛡️ RISCO:</span>
                        <span className={`${route.safety.robberyRisk === 'Baixo' ? 'text-green-700' : 'text-red-700'} ml-1`}>
                          {route.safety.robberyRisk} {route.safety.robberyRisk === 'Baixo' ? '✅' : '⚠️'}
                        </span>
                      </p>
                      {route.dirtRoad && (
                        <p className="font-['Silkscreen'] text-black text-xs flex items-center">
                          <span>🛤️ TERRENO:</span>
                          <span className="text-yellow-700 ml-1">Estrada de Terra</span>
                        </p>
                      )}
                      {/* 🔍 INDICADOR DE MAPA */}
                      {route.pathCoordinates && route.pathCoordinates.length > 0 ? (
                        <p className="font-['Silkscreen'] text-green-600 text-xs">
                          🗺️ Mapa disponível ({route.pathCoordinates.length} pontos)
                        </p>
                      ) : (
                        <p className="font-['Silkscreen'] text-red-600 text-xs">
                          ⚠️ Mapa indisponível
                        </p>
                      )}
                    </div>
                  </div>

                  {selectedRoute?.id === route.id && (
                    <div className="mt-2 p-2 bg-blue-50 border-l-4 border-blue-400 rounded-r-md">
                      <h4 className="font-bold text-blue-800 mb-1 text-xs">📋 DETALHES:</h4>
                      <div className="grid grid-cols-2 gap-1 text-xs text-blue-700">
                        <p>🗺️ Mapa: {route.mapaId}</p>
                        <p>🆔 Rota: {route.id}</p>
                        {route.danger_zones_data.length > 0 && (
                          <p>⚠️ Perigos: {route.danger_zones_data.length}</p>
                        )}
                        {route.dirt_segments_data.length > 0 && (
                          <p>🌄 Terra: {route.dirt_segments_data.length}</p>
                        )}
                        <p>🚦 Velocidade: {route.velocidade_media_kmh} km/h</p>
                        <p>🛣️ Tipo: {route.tipo_estrada}</p>
                        {route.pathCoordinates ? (
                          <p className="text-green-700">📍 Coordenadas: {route.pathCoordinates.length} pontos</p>
                        ) : (
                          <p className="text-red-700">📍 Sem coordenadas!</p>
                        )}
                        {route.dirtSegments && route.dirtSegments.length > 0 && (
                          <p>🏜️ Trechos terra: {route.dirtSegments.length}</p>
                        )}
                      </div>
                      {route.descricao && (
                        <p className="text-xs text-gray-600 mt-1 italic">{route.descricao}</p>
                      )}
                    </div>
                  )}
                </div>
              ))
            )}
          </div>

          <div className="bg-[#E3922A] border-2 border-black rounded-b-lg p-2 flex-shrink-0">
            {selectedRoute ? (
              <button
                onClick={handleContinue}
                className="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-3 text-sm rounded-md 
                         shadow-lg border-2 border-green-800 transition-all duration-200"
              >
                🚛 CONTINUAR COM ESTA ROTA
              </button>
            ) : (
              <div className="text-center text-black font-bold py-2 text-sm">
                👆 Selecione uma rota para continuar
              </div>
            )}
          </div>
        </div>
      </div>
    </div>
  );
};
</file>

<file path="src/api/gameService.ts">
import api from './config';
import { Map as Desafio } from '../types';
import { TeamData, RankingApiResponse } from '../types/ranking';

interface EventResponse {
  id: number;
  partida: number;
  evento: {
    id: number;
    nome: string;
    descricao: string;
    tipo: 'positivo' | 'negativo';
    categoria: string;
    opcoes: Array<{
      id: number;
      descricao: string;
      efeitos: any;
    }>;
  };
  momento: string;
  ordem: number;
  opcao_escolhida: null;
}

interface PartidaResponse {
  id: number;
  saldo: number;
  combustivel_atual: number;
  quantidade_carga: number;
  condicao_veiculo: number;
  estresse_motorista: number;
  tempo_real: number;
  pontuacao: number;
  distancia_percorrida: number;
  status: "concluido" | "em_andamento" | "pausado" | "cancelada";
  tempo_jogo?: number;
  resultado?: "vitoria" | "derrota";
  motivo_finalizacao?: string;
  eficiencia?: number;
  saldo_inicial?: number;
  quantidade_carga_inicial?: number;
}

interface RespondResponse {
  detail: string;
  partida: PartidaResponse;
}

interface VehicleResponse {
  id: number;
  modelo: string;
  capacidade_carga: number;
  capacidade_combustivel: number;
  velocidade: number;
  preco: number;
  autonomia: number;
}

interface RouteResponse {
  id: number;
  nome: string;
  descricao: string;
  distancia_km: number;
  tempo_estimado_horas: number;
  tipo_estrada: string;
  velocidade_media_kmh: number;
  danger_zones_data: any[];
  dirt_segments_data: any[];
}

// ✅ INTERFACE ATUALIZADA para corresponder ao modelo 'Mapa' do backend
interface MapResponse {
  id: number;
  nome: string;
  descricao: string;
  objetivo: string;
  ferramentas: any[];
  dificuldade: string;
  tempo_limite: string;
  min_jogadores: number;
  max_jogadores: number;
  imagem: string;
  rotas: RouteResponse[];
}

// === NOVA INTERFACE PARA O TICK ===
interface TickData {
  distancia_percorrida: number;
}

export const GameService = {
  async getMaps(): Promise<Desafio[]> {
    console.log('🗺️ Buscando mapas da API...');
    try {
      const response = await api.get('/jogo1/mapas/');
      console.log('✅ Mapas recebidos:', response.data.length, 'mapas');
      return response.data;
    } catch (error) {
      console.error('❌ Erro ao buscar mapas:', error);
      throw error;
    }
  },

  // ✅ FUNÇÃO ADICIONADA
  async getMapById(id: number): Promise<MapResponse> {
    console.log(`🗺️ Buscando desafio específico com ID: ${id}...`);
    try {
      const response = await api.get<MapResponse>(`/jogo1/mapas/${id}/`);
      console.log('✅ Desafio recebido:', response.data.nome);
      return response.data;
    } catch (error) {
      console.error(`❌ Erro ao buscar desafio ${id}:`, error);
      throw error;
    }
  },

  async getRanking(): Promise<RankingApiResponse> {
    console.log('🏆 Buscando ranking de eficiência da API...');
    try {
      const response = await api.get('/jogo1/ranking/');
      console.log('✅ Ranking recebido:', response.data.length, 'equipes');
      if (Array.isArray(response.data)) {
        response.data.forEach((equipe: TeamData) => {
          console.log(`🏅 ${equipe.nome}: ${equipe.eficiencia_media.toFixed(1)}% eficiência, ${equipe.stats.vitorias} vitórias`);
        });
      }
      return response.data;
    } catch (error) {
      console.error('❌ Erro ao buscar ranking:', error);
      throw error;
    }
  },

  async getTeamById(teamId: number): Promise<TeamData | null> {
    console.log('🔍 Buscando equipe por ID:', teamId);
    try {
      const ranking = await this.getRanking();
      const team = ranking.find(t => t.id === teamId) || null;
      if (team) {
        console.log('✅ Equipe encontrada:', team.nome);
      } else {
        console.log('❌ Equipe não encontrada para ID:', teamId);
      }
      return team;
    } catch (error) {
      console.error('❌ Erro ao buscar equipe por ID:', error);
      throw error;
    }
  },

  async getTeamPosition(teamName: string): Promise<number | null> {
    console.log('🔍 Buscando posição da equipe:', teamName);
    try {
      const ranking = await this.getRanking();
      const index = ranking.findIndex(t => t.nome === teamName);
      const position = index !== -1 ? index + 1 : null;

      if (position) {
        console.log('✅ Posição encontrada:', position);
      } else {
        console.log('❌ Equipe não encontrada no ranking:', teamName);
      }

      return position;
    } catch (error) {
      console.error('❌ Erro ao buscar posição da equipe:', error);
      throw error;
    }
  },

  async getVehicles(): Promise<VehicleResponse[]> {
    console.log('🚛 Buscando veículos da API...');
    try {
      const response = await api.get('/jogo1/veiculos/');
      console.log('✅ Veículos recebidos:', response.data.length, 'veículos');
      return response.data;
    } catch (error) {
      console.error('❌ Erro ao buscar veículos:', error);
      throw error;
    }
  },

  async getNextEvent(distancia_percorrida: number): Promise<EventResponse> {
    console.log('🎲 Buscando próximo evento para distância:', distancia_percorrida.toFixed(2), 'km');
    try {
      const response = await api.post<EventResponse>('/jogo1/proximo-evento/', {
        distancia_percorrida
      });
      if (response.status === 200 && response.data?.evento) {
        console.log('✅ Evento recebido:', response.data.evento.nome, '(categoria:', response.data.evento.categoria + ')');
        return response.data;
      }
      if (response.status === 204) {
        console.log('✅ Nenhum evento desta vez (HTTP 204 - NORMAL)');
        throw new Error('NO_EVENT_AVAILABLE');
      }
      console.warn('⚠️ Resposta 200 mas dados inválidos:', response.data);
      throw new Error('INVALID_API_RESPONSE');
    } catch (error: any) {
      if (error.message === 'NO_EVENT_AVAILABLE' || error.message === 'INVALID_API_RESPONSE') {
        throw error;
      }
      if (error.response?.status === 204) {
        console.log('✅ Nenhum evento desta vez (Erro 204 - NORMAL)');
        throw new Error('NO_EVENT_AVAILABLE');
      } else if (error.response?.status === 400) {
        console.warn('⚠️ Bad Request ao buscar evento:', error.response?.data);
        throw new Error('INVALID_REQUEST');
      } else if (error.response?.status >= 500) {
        console.error('💥 Erro interno do servidor:', error.response?.status);
        throw new Error('SERVER_ERROR');
      } else if (error.code === 'ERR_NETWORK') {
        console.error('🔥 Erro de rede/conexão');
        throw new Error('NETWORK_ERROR');
      } else {
        console.error('❌ Erro desconhecido ao buscar evento:', error);
        throw new Error('UNKNOWN_ERROR');
      }
    }
  },

  // === FUNÇÃO MODIFICADA: Agora envia também a distância ===
  async respondToEvent(optionId: number, distancia_percorrida: number): Promise<RespondResponse> {
    console.log(`✋ Respondendo evento com opção ${optionId} na distância ${distancia_percorrida.toFixed(2)}km`);
    try {
      const response = await api.post<RespondResponse>('/jogo1/eventos/responder/', {
        opcao_id: optionId,
        distancia_percorrida: distancia_percorrida
      });
      console.log('✅ Resposta do evento processada:', response.data.detail);
      return response.data;
    } catch (error) {
      console.error('❌ Erro ao responder evento:', error);
      throw error;
    }
  },

  async getActiveGame(): Promise<PartidaResponse> {
    console.log('🎮 Buscando partida ativa...');
    try {
      const response = await api.get<PartidaResponse>('/jogo1/partidas/ativa/');
      console.log('✅ Partida ativa encontrada:', response.data.id);
      return response.data;
    } catch (error) {
      console.error('❌ Erro ao buscar partida ativa:', error);
      throw error;
    }
  },

  async createGame(gameData: { mapa: number; rota: number; veiculo: number }): Promise<PartidaResponse> {
    console.log('🚀 Criando nova partida com dados:', gameData);
    if (!gameData.mapa || !gameData.rota || !gameData.veiculo) {
      const error = new Error('Dados inválidos para criar partida');
      console.error('❌ Dados incompletos:', gameData);
      throw error;
    }
    if (typeof gameData.mapa !== 'number' || typeof gameData.rota !== 'number' || typeof gameData.veiculo !== 'number') {
      const error = new Error('IDs devem ser números válidos');
      console.error('❌ Tipos inválidos:', { mapa: typeof gameData.mapa, rota: typeof gameData.rota, veiculo: typeof gameData.veiculo });
      throw error;
    }
    try {
      const response = await api.post<PartidaResponse>('/jogo1/partidas/nova/', gameData);
      console.log('✅ Partida criada com sucesso! ID:', response.data.id);
      console.log('💰 Saldo inicial:', response.data.saldo);
      console.log('⛽ Combustível inicial:', response.data.combustivel_atual);
      return response.data;
    } catch (error: any) {
      console.error('❌ Erro ao criar partida:', error);
      if (error.response) {
        console.error('📋 Status do erro:', error.response.status);
        console.error('📋 Dados do erro:', error.response.data);
        if (error.response.status === 400) {
          throw new Error(`IDs inválidos: ${JSON.stringify(error.response.data)}`);
        }
      }
      throw error;
    }
  },

  // === NOVA FUNÇÃO DE TICK (CORAÇÃO DO SISTEMA) ===
  async partidaTick(data: TickData): Promise<PartidaResponse> {
    console.log('⏱️ Enviando tick para o servidor:', data.distancia_percorrida.toFixed(2), 'km');
    try {
      const response = await api.post<PartidaResponse>('/jogo1/partidas/tick/', data);
      console.log('✅ Tick processado - Tempo oficial:', response.data.tempo_jogo?.toFixed(2), 'min');
      return response.data;
    } catch (error) {
      console.error('❌ Erro no tick:', error);
      throw error;
    }
  },

  async pauseGame(): Promise<{ detail: string }> {
    console.log('⏸️ Pausando jogo...');
    try {
      const response = await api.post<{ detail: string }>('/jogo1/partidas/pausar/');
      console.log('✅ Jogo pausado:', response.data.detail);
      return response.data;
    } catch (error) {
      console.error('❌ Erro ao pausar jogo:', error);
      throw error;
    }
  },

  async resumeGame(): Promise<{ detail: string }> {
    console.log('▶️ Retomando jogo...');
    try {
      const response = await api.post<{ detail: string }>('/jogo1/partidas/continuar/');
      console.log('✅ Jogo retomado:', response.data.detail);
      return response.data;
    } catch (error) {
      console.error('❌ Erro ao retomar jogo:', error);
      throw error;
    }
  },

  async syncGameProgress(progressData: { tempo_decorrido_segundos: number }): Promise<PartidaResponse> {
    console.log('🔄 Sincronizando progresso do jogo...', progressData);
    try {
      const response = await api.post<PartidaResponse>('/jogo1/partidas/sincronizar/', progressData);
      console.log('✅ Progresso sincronizado');
      if (response.data.status === 'concluido') {
        console.log('🏁 Partida finalizada!');
        console.log('🏆 Resultado:', response.data.resultado);
        if (response.data.eficiencia !== undefined) {
          console.log('📊 Eficiência calculada:', response.data.eficiencia + '%');
        }
        console.log('💯 Pontuação final:', response.data.pontuacao);
      }
      return response.data;
    } catch (error) {
      console.error('❌ Erro ao sincronizar progresso:', error);
      throw error;
    }
  },

  async saveGameState(gameState: any) {
    return await api.post('/game/save-state/', gameState);
  },

  async loadGameState(matchId: string) {
    return await api.get(`/game/load-state/${matchId}/`);
  }
};
</file>

<file path="src/pages/escolherVeiculo/VehicleSelectionPage.tsx">
import React, { useState, useEffect } from 'react';
import { useNavigate, useLocation } from 'react-router-dom';
import { Vehicle } from '../../types/vehicle';
import {
  Carousel,
  CarouselContent,
  CarouselItem,
  CarouselNext,
  CarouselPrevious,
  type CarouselApi,
} from '@/components/ui/carousel';
import {
  Dialog,
  DialogContent,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog';
import {
  CalendarDays,
  MapPin,
  DollarSign,
  ArrowLeft,
  Home,
} from 'lucide-react';
import { Button } from "@/components/ui/button";
import { ButtonHomeBack } from "@/components/ButtonHomeBack";
import { AudioControl } from "@/components/AudioControl";

// TODO: Ajustar imagens, (adicionar imagens ao banco?)
import caminhaoMedioPng from '@/assets/caminhao_medio.png';
import camihaoPequenoPng from '@/assets/caminhao_pequeno.png';
import carretaPng from '@/assets/carreta.png';
import camhionetePng from '@/assets/caminhonete.png';

// FIXME: Ajustar imagens para cada tipo de veiculo (permitir o envio de imagens ou ter um conjunto de imagens selecionaveis via admin?)
const getSpriteName = (modelName: string) => {
  switch (modelName.toLowerCase()) {
    case 'caminhonete':
      return 'caminhonete';
    case 'caminhão pequeno':
      return 'caminhao_pequeno';
    case 'caminhão médio':
      return 'caminhao_medio';
    case 'carreta':
      return 'carreta';
    default:
      return 'caminhao_medio';
  }
};

// Componente VehicleCard atualizado com novo design
const VehicleCard: React.FC<{
  vehicle: Vehicle;
  isSelected: boolean;
  onSelect: () => void;
}> = ({ vehicle, isSelected, onSelect }) => (
  <div
    className={`
      relative min-w-[280px] max-w-[320px] mx-2 sm:mx-4 cursor-pointer transition-all duration-300
      ${isSelected ? 'scale-105 border-4 border-[#e3922a] shadow-[0_0_20px_rgba(227,146,42,0.3)]' : 'hover:scale-105 border-2 border-black shadow-[4px_4px_0px_0px_rgba(0,0,0,1)]'}
      bg-white p-4 rounded-xl flex flex-col justify-between hover:shadow-[6px_6px_0px_0px_rgba(0,0,0,1)]
    `}
    onClick={onSelect}
  >
    <div>
      <div className="flex justify-center mb-4">
        <img src={vehicle.image} alt={vehicle.name} className="h-32 sm:h-48 object-contain" />
      </div>

      <h3 className="[font-family:'Silkscreen',Helvetica] text-center text-lg sm:text-xl font-bold mb-3 text-gray-800">
        {vehicle.name}
      </h3>
      
      <div className="space-y-2 text-sm">
        <div className="flex items-center justify-between bg-gray-50 p-2 rounded border">
          <span className="[font-family:'Silkscreen',Helvetica] text-xs">🧱 Capacidade:</span>
          <span className="[font-family:'Silkscreen',Helvetica] text-xs font-bold">{vehicle.capacity} Kg</span>
        </div>
        <div className="flex items-center justify-between bg-gray-50 p-2 rounded border">
          <span className="[font-family:'Silkscreen',Helvetica] text-xs">🛢️ Tanque:</span>
          <span className="[font-family:'Silkscreen',Helvetica] text-xs font-bold">{vehicle.maxCapacity} L</span>
        </div>
        <div className="flex items-center justify-between bg-gray-50 p-2 rounded border">
          <span className="[font-family:'Silkscreen',Helvetica] text-xs">🚗 Asfalto:</span>
          <span className="[font-family:'Silkscreen',Helvetica] text-xs font-bold">{vehicle.consumption.asphalt} KM/L</span>
        </div>
      </div>
    </div>

    <div className="mt-4 p-3 bg-[#e3922a] rounded-lg border-2 border-black">
      <p className="[font-family:'Silkscreen',Helvetica] text-white font-bold text-center text-lg">
        R$ {vehicle.cost.toLocaleString()}
      </p>
    </div>
  </div>
);

export const VehicleSelectionPage = () => {
  const navigate = useNavigate();
  const location = useLocation();

  // Recebe o desafio selecionado da página anterior
  const selectedChallenge = location.state?.desafio;
  const challengeId = location.state?.challengeId;

  // Estados para guardar os veículos da API, o estado de loading e possíveis erros.
  const [vehicles, setVehicles] = useState<Vehicle[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // Estados para os dados do desafio
  const [challengeData, setChallengeData] = useState<{
    nome: string;
    descricao: string;
    objetivo?: string;
    dificuldade?: string;
  } | null>(null);

  // Debug: verificar se os dados estão sendo recebidos
  console.log("🚗 DEBUG VehicleSelection - challengeId recebido:", challengeId);
  console.log("🚗 DEBUG VehicleSelection - selectedChallenge:", selectedChallenge);
  console.log("🚗 DEBUG VehicleSelection - location.state:", location.state);
  console.log("🚗 DEBUG VehicleSelection - challengeData state:", challengeData);

  const [selectedIndex, setSelectedIndex] = useState<number | null>(null); // Inicia como nulo
  const [showConfirmation, setShowConfirmation] = useState(false);
  const [availableMoney] = useState(10000);
  const [api, setApi] = useState<CarouselApi>();

  // useEffect para buscar os dados da API quando o componente for montado.
  useEffect(() => {
    const fetchData = async () => {
      try {
        // Buscar veículos
        const vehiclesUrl = `${import.meta.env.VITE_API_URL}/jogo1/veiculos/`;
        const vehiclesResponse = await fetch(vehiclesUrl);
        if (!vehiclesResponse.ok) {
          throw new Error(`HTTP error! status: ${vehiclesResponse.status}`);
        }
        const vehiclesData = await vehiclesResponse.json();

        const formattedVehicles: Vehicle[] = vehiclesData.map((apiVehicle: any) => ({
          id: String(apiVehicle.id),
          name: apiVehicle.modelo,
          capacity: apiVehicle.capacidade_carga,
          consumption: {
            asphalt: parseFloat((apiVehicle.autonomia / apiVehicle.capacidade_combustivel).toFixed(2)),
            dirt: parseFloat(((apiVehicle.autonomia / apiVehicle.capacidade_combustivel) * 0.8).toFixed(2))
          },
          image: `/assets/${getSpriteName(apiVehicle.modelo)}.png`,
          spriteSheet: `/assets/${getSpriteName(apiVehicle.modelo)}_sheet.png`,
          spriteName: getSpriteName(apiVehicle.modelo),
          maxCapacity: apiVehicle.capacidade_combustivel,
          currentFuel: 0, // Tanque sempre vazio - usuário deve abastecer
          cost: parseFloat(apiVehicle.preco),
        }));

        setVehicles(formattedVehicles);
        if (formattedVehicles.length > 0) {
          setSelectedIndex(0); // Define o primeiro veículo como selecionado por padrão
        }

        // Buscar dados do desafio se challengeId estiver disponível
        if (challengeId) {
          console.log("🔍 DEBUG - Tentando buscar desafio com ID:", challengeId);
          const challengeUrl = `${import.meta.env.VITE_API_URL}/jogo1/mapas/${challengeId}/`;
          console.log("🔍 DEBUG - URL da requisição:", challengeUrl);

          const challengeResponse = await fetch(challengeUrl);
          console.log("🔍 DEBUG - Status da resposta:", challengeResponse.status);

          if (challengeResponse.ok) {
            const challengeDataFromApi = await challengeResponse.json();
            console.log("🎯 DEBUG - Dados brutos da API:", challengeDataFromApi);

            const formattedChallengeData = {
              nome: challengeDataFromApi.nome,
              descricao: challengeDataFromApi.descricao,
              objetivo: challengeDataFromApi.objetivo,
              dificuldade: challengeDataFromApi.dificuldade
            };

            console.log("🎯 DEBUG - Dados formatados:", formattedChallengeData);
            setChallengeData(formattedChallengeData);
          } else {
            console.error("❌ Erro ao carregar desafio - Status:", challengeResponse.status);
            const errorText = await challengeResponse.text();
            console.error("❌ Erro detalhado:", errorText);

            // Se falhar com o ID numérico, tenta usar os dados do selectedChallenge
            if (selectedChallenge) {
              console.log("🔄 DEBUG - Usando dados do selectedChallenge como fallback");
              setChallengeData({
                nome: selectedChallenge.name,
                descricao: selectedChallenge.description,
                objetivo: selectedChallenge.objective,
                dificuldade: selectedChallenge.difficulty
              });
            }
          }
        } else if (selectedChallenge) {
          // Se não tiver challengeId, usa os dados do selectedChallenge diretamente
          console.log("🔄 DEBUG - Usando dados do selectedChallenge diretamente");
          setChallengeData({
            nome: selectedChallenge.name,
            descricao: selectedChallenge.description,
            objetivo: selectedChallenge.objective,
            dificuldade: selectedChallenge.difficulty
          });
        } else {
          console.warn("⚠️ Nem challengeId nem selectedChallenge estão disponíveis");
        }

      } catch (e) {
        if (e instanceof Error) {
          setError(`Falha ao buscar dados: ${e.message}`);
        } else {
          setError("Ocorreu um erro desconhecido.");
        }
        console.error(e);
      } finally {
        setIsLoading(false);
      }
    };

    fetchData();
  }, [challengeId]);

  useEffect(() => {
    if (!api || selectedIndex === null) return;
    api.scrollTo(selectedIndex);
    const onSelect = () => {
      setSelectedIndex(api.selectedScrollSnap());
    };
    api.on('select', onSelect);
    return () => {
      api.off('select', onSelect);
    };
  }, [api, selectedIndex]);

  const handleVehicleSelect = (index: number) => {
    setSelectedIndex(index);
    setShowConfirmation(true);
  };

  const handleConfirm = () => {
    if (selectedIndex === null) return; // Proteção extra
    const selectedVehicle = vehicles[selectedIndex];
    if (selectedVehicle.cost <= availableMoney) {
      navigate('/routes', {
        state: {
          selectedVehicle: selectedVehicle,
          availableMoney: availableMoney - selectedVehicle.cost,
          selectedChallenge: selectedChallenge,
          challengeId: challengeId
        }
      });
    }
  };

  if (isLoading) {
    return (
      <div className="[background:linear-gradient(180deg,rgba(32,2,89,1)_0%,rgba(121,70,213,1)_100%)] min-h-screen flex items-center justify-center">
        <div className="bg-white rounded-lg p-8 shadow-lg border-2 border-black">
          <div className="animate-spin rounded-full h-12 w-12 border-4 border-[#e3922a] border-t-transparent mx-auto mb-4"></div>
          <p className="[font-family:'Silkscreen',Helvetica] text-[#e3922a] text-xl text-center">
            Carregando desafio e veículos...
          </p>
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="[background:linear-gradient(180deg,rgba(32,2,89,1)_0%,rgba(121,70,213,1)_100%)] min-h-screen flex items-center justify-center p-4">
        <div className="bg-white rounded-lg p-8 shadow-lg border-2 border-black max-w-md w-full">
          <h1 className="[font-family:'Silkscreen',Helvetica] text-red-600 text-xl mb-4 text-center">
            Erro ao carregar dados
          </h1>
          <p className="[font-family:'Silkscreen',Helvetica] text-sm text-gray-600 mb-4 text-center">
            {error}
          </p>
          <div className="flex gap-2 justify-center">
            <Button 
              onClick={() => window.location.reload()} 
              className="bg-[#e3922a] hover:bg-[#d4831f] text-white border-2 border-black [font-family:'Silkscreen',Helvetica]"
            >
              Tentar Novamente
            </Button>
          </div>
        </div>
      </div>
    );
  }

  const selectedVehicle = selectedIndex !== null ? vehicles[selectedIndex] : null;

  return (
    <div className="bg-white flex flex-row justify-center w-full min-h-screen">
      <div className="w-full min-h-screen [background:linear-gradient(180deg,rgba(32,2,89,1)_0%,rgba(121,70,213,1)_100%)] relative overflow-hidden flex flex-col">
        
        {/* Header com botões de navegação e saldo */}
        <div className="flex justify-between items-center p-4 relative z-10">
          <div className="absolute top-4 left-4">
            <Button
              onClick={() => navigate('/desafio')}
              className="bg-orange-500 hover:bg-orange-600 text-white px-4 py-2 border border-black rounded-md shadow-md font-['Silkscreen'] h-10"
            >
              ← Voltar
            </Button>
          </div>

          {/* Controle de áudio */}
          <div className="absolute top-4 right-4 flex gap-2">
            <AudioControl />
            <div className="font-['Silkscreen'] bg-orange-500 hover:bg-orange-600 text-white px-4 py-2 border border-black rounded-md shadow-md flex items-center justify-center h-10">
              R$ {availableMoney.toLocaleString()}
            </div>
          </div>
        </div>

        {/* Conteúdo principal */}
        <div className="px-4 pb-8 flex flex-col items-center min-h-0 flex-1">
          
          {/* Informações do desafio */}
          <div className="bg-white rounded-[18px] border-2 border-black shadow-[4px_4px_0px_0px_rgba(0,0,0,1)] w-full max-w-4xl p-4 sm:p-6 mb-4 mt-2">
            <h2 className="[font-family:'Silkscreen',Helvetica] text-xl sm:text-2xl text-[#e3922a] font-bold text-center mb-2">
              {challengeData?.nome || "DESAFIO DE ENTREGA: JUAZEIRO A SALVADOR!"}
            </h2>
            
            {challengeData?.descricao && (
              <div className="[font-family:'Silkscreen',Helvetica] text-sm sm:text-base text-gray-700 text-center max-w-3xl mx-auto mb-2">
                {challengeData.descricao}
              </div>
            )}

            {challengeData?.dificuldade && (
              <div className="[font-family:'Silkscreen',Helvetica] text-xs sm:text-sm text-[#e3922a] text-center mb-2">
                📊 Dificuldade: {challengeData.dificuldade}
              </div>
            )}
            
            {!challengeData?.descricao && (
              <div className="flex items-center justify-center gap-2 text-sm sm:text-lg text-gray-700 [font-family:'Silkscreen',Helvetica]">
                <span role="img" aria-label="carga">🧱</span> 1100kg
              </div>
            )}
          </div>

          {/* Título da seleção de veículos */}
          <h1 className="[font-family:'Silkscreen',Helvetica] text-2xl sm:text-3xl mb-4 text-center text-white font-bold">
            ESCOLHA UM CAMINHÃO
          </h1>

          {/* Carrossel de veículos */}
          <div className="relative w-full max-w-[1200px] px-4 sm:px-16 mb-4">
            <Carousel
              setApi={setApi}
              className="w-full"
              opts={{
                align: "center",
                loop: true,
              }}
            >
              <CarouselContent className="-ml-2 sm:-ml-4 py-6">
                {vehicles.map((vehicle, index) => (
                  <CarouselItem key={vehicle.id} className="basis-full sm:basis-auto md:basis-1/2 lg:basis-1/3 pl-2 sm:pl-4">
                    <VehicleCard
                      vehicle={vehicle}
                      isSelected={selectedIndex === index}
                      onSelect={() => handleVehicleSelect(index)}
                    />
                  </CarouselItem>
                ))}
              </CarouselContent>

              <CarouselPrevious className="hidden md:flex opacity-100 -left-4 h-14 w-14 bg-[#e3922a] hover:bg-[#d4831f] transition-all duration-300 ease-in-out hover:scale-110 text-white border-2 border-black rounded-sm shadow-[4px_4px_0px_0px_rgba(0,0,0,1)]" />
              <CarouselNext className="hidden transition-all duration-300 ease-in-out hover:scale-110 md:flex opacity-100 -right-4 h-14 w-14 bg-[#e3922a] hover:bg-[#d4831f] text-white border-2 border-black rounded-sm shadow-[4px_4px_0px_0px_rgba(0,0,0,1)]" />
            </Carousel>
          </div>

          {/* Indicadores para mobile */}
          {vehicles.length > 1 && (
            <div className="flex gap-2 mt-2 mb-4 md:hidden">
              {vehicles.map((_, index) => (
                <div
                  key={index}
                  className={`w-2 h-2 rounded-full transition-colors ${
                    selectedIndex === index ? 'bg-[#e3922a]' : 'bg-white/50'
                  }`}
                />
              ))}
            </div>
          )}
        </div>

        {/* Modal de confirmação */}
        {selectedVehicle && (
          <Dialog open={showConfirmation} onOpenChange={setShowConfirmation}>
            <DialogContent className="sm:max-w-md [font-family:'Silkscreen',Helvetica] border-2 border-black shadow-[4px_4px_0px_0px_rgba(0,0,0,1)]">
              <DialogHeader>
                <DialogTitle className="[font-family:'Silkscreen',Helvetica] flex items-center gap-2 text-xl text-[#e3922a]">
                  Veículo Selecionado
                </DialogTitle>
              </DialogHeader>
              
              <div className="space-y-4 text-sm">
                <div className="bg-gray-50 p-4 rounded-lg border-2 border-gray-200">
                  <div className="flex items-center gap-4 mb-3">
                    <img src={selectedVehicle.image} className="h-16 w-16 object-contain border rounded" />
                    <div>
                      <p className="[font-family:'Silkscreen',Helvetica] font-bold text-base text-gray-800">
                        {selectedVehicle.name}
                      </p>
                    </div>
                  </div>
                  
                  <div className="grid grid-cols-2 gap-2 text-xs">
                    <div className="bg-white p-2 rounded border">
                      <span className="text-gray-600">Capacidade:</span>
                      <span className="font-bold ml-1">{selectedVehicle.capacity} Kg</span>
                    </div>
                    <div className="bg-white p-2 rounded border">
                      <span className="text-gray-600">Tanque:</span>
                      <span className="font-bold ml-1">{selectedVehicle.maxCapacity} L</span>
                    </div>
                    <div className="bg-white p-2 rounded border">
                      <span className="text-gray-600">Asfalto:</span>
                      <span className="font-bold ml-1">{selectedVehicle.consumption.asphalt} KM/L</span>
                    </div>
                    <div className="bg-white p-2 rounded border">
                      <span className="text-gray-600">Terra:</span>
                      <span className="font-bold ml-1">{selectedVehicle.consumption.dirt} KM/L</span>
                    </div>
                  </div>
                </div>

                <div className="bg-[#e3922a]/10 p-4 rounded-lg border-2 border-[#e3922a]/20">
                  <h4 className="font-semibold mb-2 text-base text-[#e3922a]">Detalhes da Compra</h4>
                  <div className="text-sm space-y-2">
                    <p className="flex items-center gap-2">
                      <CalendarDays size={16} className="text-[#e3922a]" /> 
                      <span>Data/Hora: Agora</span>
                    </p>
                    <p className="flex items-center gap-2">
                      <MapPin size={16} className="text-[#e3922a]" /> 
                      <span>Local de Retirada: Base</span>
                    </p>
                    <div className="bg-[#e3922a] text-white p-2 rounded border-2 border-black mt-3">
                      <p className="[font-family:'Silkscreen',Helvetica] flex items-center justify-center gap-2 text-lg font-bold">
                        <DollarSign size={16} /> 
                        Total: R$ {selectedVehicle.cost.toLocaleString()}
                      </p>
                    </div>
                  </div>
                </div>
              </div>
              
              <DialogFooter className="pt-4 gap-2">
                <Button 
                  onClick={handleConfirm} 
                  className="bg-green-600 hover:bg-green-700 [font-family:'Silkscreen',Helvetica] border-2 border-black shadow-[2px_2px_0px_0px_rgba(0,0,0,1)]" 
                  disabled={availableMoney < selectedVehicle.cost}
                >
                  {availableMoney < selectedVehicle.cost ? "Dinheiro Insuficiente" : "Confirmar"}
                </Button>
                <Button 
                  variant="destructive" 
                  onClick={() => setShowConfirmation(false)} 
                  className="[font-family:'Silkscreen',Helvetica] border-2 border-black shadow-[2px_2px_0px_0px_rgba(0,0,0,1)]"
                >
                  Cancelar
                </Button>
              </DialogFooter>
            </DialogContent>
          </Dialog>
        )}
      </div>
    </div>
  );
};
</file>

<file path="src/pages/mapaRota/MapComponent.tsx">
// src/pages/mapaRota/MapComponent.tsx

import React, { useState, useRef, useEffect, useCallback, useMemo } from 'react';
import { MapContainer, TileLayer, Polyline, Marker, Popup, Tooltip, useMapEvents } from 'react-leaflet';
import 'leaflet/dist/leaflet.css';
import L from 'leaflet';
import { Route, REFERENCE_COORDINATES } from './constants';
import { challenges, getDestinationCoordinates } from './challengesManager';
import { useLocation, useNavigate } from 'react-router-dom';
import { Vehicle } from '../../types/vehicle';
import { ArrowLeft } from 'lucide-react';
import { GameService } from '../../api/gameService';
import { calculatePositionFromProgress, calculatePathFromProgress } from '../../utils/mapUtils';
import defaultIcon from 'leaflet/dist/images/marker-icon.png';
import iconShadow from 'leaflet/dist/images/marker-shadow.png';

let DefaultIcon = L.icon({
  iconUrl: defaultIcon,
  shadowUrl: iconShadow,
  iconSize: [25, 41],
  iconAnchor: [12, 41],
  popupAnchor: [1, -34]
});
L.Marker.prototype.options.icon = DefaultIcon;

interface StaticTruckMarkerProps {
  routePath: [number, number][];
  totalProgress: number;
  vehicle: Vehicle;
}

// --- Ícones Customizados ---
// rest, construction, gas, toll, danger
const tollIcon = L.icon({ iconUrl: 'https://cdn-icons-png.flaticon.com/512/2297/2297592.png', iconSize: [30, 30], iconAnchor: [15, 15] });
const dangerIcon = L.icon({ iconUrl: 'https://cdn-icons-png.flaticon.com/512/1008/1008928.png', iconSize: [30, 30], iconAnchor: [15, 15] });
const restStopIcon = L.icon({ iconUrl: 'https://cdn-icons-png.flaticon.com/512/6807/6807796.png', iconSize: [30, 30], iconAnchor: [15, 15] });
const constructionIcon = L.icon({ iconUrl: 'https://cdn-icons-png.flaticon.com/512/4725/4725077.png', iconSize: [30, 30], iconAnchor: [15, 15] });
const gasStationIcon = L.icon({ iconUrl: 'https://cdn-icons-png.flaticon.com/512/465/465090.png', iconSize: [30, 30], iconAnchor: [15, 15] });


// --- Ícones para áreas de risco ---
const lowRiskIcon = L.icon({ iconUrl: 'https://cdn-icons-png.flaticon.com/512/6276/6276686.png', iconSize: [30, 30], iconAnchor: [15, 15] });
const mediumRiskIcon = L.icon({ iconUrl: 'https://cdn-icons-png.flaticon.com/512/4751/4751259.png', iconSize: [30, 30], iconAnchor: [15, 15] });
const highRiskIcon = L.icon({ iconUrl: 'https://cdn-icons-png.flaticon.com/512/900/900532.png', iconSize: [30, 30], iconAnchor: [15, 15] });

// --- Ícones de velocidade ---
const speedLimitIcon20 = L.icon({ iconUrl: 'https://cdn-icons-png.flaticon.com/512/1670/1670172.png', iconSize: [30, 30], iconAnchor: [15, 15] });
const speedLimitIcon40 = L.icon({ iconUrl: 'https://cdn-icons-png.flaticon.com/512/5124/5124881.png', iconSize: [30, 30], iconAnchor: [15, 15] });
const speedLimitIcon50 = L.icon({ iconUrl: 'https://cdn-icons-png.flaticon.com/512/752/752738.png', iconSize: [30, 30], iconAnchor: [15, 15] });
const speedLimitIcon60 = L.icon({ iconUrl: 'https://cdn-icons-png.flaticon.com/512/15674/15674424.png', iconSize: [30, 30], iconAnchor: [15, 15] });
const speedLimitIcon80 = L.icon({ iconUrl: 'https://cdn-icons-png.flaticon.com/512/3897/3897785.png', iconSize: [30, 30], iconAnchor: [15, 15] });
const speedLimitIcon100 = L.icon({ iconUrl: 'https://cdn-icons-png.flaticon.com/512/10392/10392769.png', iconSize: [30, 30], iconAnchor: [15, 15] });


// logica para obter o ícone de limite de velocidade
const getSpeedLimitIcon = (speed: number): L.Icon => {
  switch (speed) {
    case 20: return speedLimitIcon20;
    case 40: return speedLimitIcon40;
    case 50: return speedLimitIcon50;
    case 60: return speedLimitIcon60;
    case 80: return speedLimitIcon80;
    case 100: return speedLimitIcon100;
    default: return speedLimitIcon60; // ícone padrão caso a velocidade não corresponda
  }
};

// NOVA INTERFACE PARA OS SEGMENTOS RENDERIZÁVEIS
interface RenderSegment {
  path: [number, number][];
  isDirt: boolean;
  style: L.PathOptions;
}

// Componente para animar o caminhão
interface TruckAnimationProps {
  routePath: [number, number][];
  speed: number; // Velocidade média em km/h
  playing: boolean;
  onTripEnd: () => void;
  onFuelEmpty: () => void;
  vehicle: Vehicle;
  setCurrentFuel: (fuel: number) => void;
  isDirtRoad: boolean;
}

const TruckAnimation: React.FC<TruckAnimationProps> = ({
  routePath,
  speed,
  playing,
  onTripEnd,
  onFuelEmpty,
  vehicle,
  setCurrentFuel,
  isDirtRoad
}) => {
  const truckRef = useRef<L.Marker>(null);
  const animationFrameRef = useRef<number | null>(null);
  const currentSegment = useRef<number>(0);
  const segmentProgress = useRef<number>(0);
  const startTimeRef = useRef<number>(0);
  const lastTimeRef = useRef<number>(0);
  const totalDistanceTraveledRef = useRef<number>(0);
  const lastFuelUpdateRef = useRef<number>(0);
  const currentFuelRef = useRef<number>(vehicle.currentFuel);
  const visualizationSpeedFactor = 300; // Fator de aceleração da visualização

  // Criar ícone personalizado para o veículo
  const vehicleIcon = useMemo(() => {
    return L.icon({
      iconUrl: vehicle.image,
      iconSize: [40, 40],
      iconAnchor: [20, 20],
      popupAnchor: [0, -20]
    });
  }, [vehicle.image]);

  // Calcular consumo de combustível com base no tipo de estrada
  const calculateFuelConsumption = useCallback((distanceTraveled: number) => {
    const consumption = isDirtRoad ? vehicle.consumption.dirt : vehicle.consumption.asphalt;
    return distanceTraveled / consumption;
  }, [isDirtRoad, vehicle.consumption]);

  // Atualizar o combustível do veículo
  const updateFuel = useCallback((distanceTraveled: number) => {
    const fuelConsumed = calculateFuelConsumption(distanceTraveled);
    const newFuel = Math.max(0, currentFuelRef.current - fuelConsumed);

    currentFuelRef.current = newFuel;
    setCurrentFuel(newFuel);

    // Se o combustível acabou, parar o caminhão
    if (newFuel <= 0) {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current);
        animationFrameRef.current = null;
      }
      onFuelEmpty();
      return true;
    }
    return false;
  }, [calculateFuelConsumption, onFuelEmpty, setCurrentFuel]);

  const animateTruck = useCallback(() => {
    if (!playing || !truckRef.current || !routePath || routePath.length < 2) {
      return;
    }

    // Se estamos no final da rota
    if (currentSegment.current >= routePath.length - 1) {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current);
      }
      onTripEnd();
      return;
    }

    const now = performance.now();

    // Para a primeira execução ou após resumir de uma pausa
    if (startTimeRef.current === 0) {
      startTimeRef.current = now;
      lastTimeRef.current = now;
    }

    const elapsed = now - startTimeRef.current;
    const deltaTime = now - lastTimeRef.current;
    lastTimeRef.current = now;

    // Pontos do segmento atual
    const startPoint = routePath[currentSegment.current];
    const endPoint = routePath[currentSegment.current + 1];

    // Calcular distância em metros do segmento (usando a fórmula de Haversine)
    const R = 6371e3; // Raio da Terra em metros
    const φ1 = startPoint[0] * Math.PI / 180;
    const φ2 = endPoint[0] * Math.PI / 180;
    const Δφ = (endPoint[0] - startPoint[0]) * Math.PI / 180;
    const Δλ = (endPoint[1] - startPoint[1]) * Math.PI / 180;

    const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
      Math.cos(φ1) * Math.cos(φ2) *
      Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    const segmentDistanceMeters = R * c;
    const segmentDistanceKm = segmentDistanceMeters / 1000;

    // Tempo para percorrer este segmento em milissegundos (considerando a velocidade)
    const timeToCompleteMsec = (segmentDistanceKm / speed) * 3600 * 1000;

    // Ajustar para uma velocidade de visualização acelerada
    const adjustedTimeToCompleteMsec = timeToCompleteMsec / visualizationSpeedFactor;

    // Calcular progresso neste segmento (0 a 1)
    segmentProgress.current = Math.min(elapsed / adjustedTimeToCompleteMsec, 1);

    // Calcular distância percorrida neste frame
    const previousProgress = (elapsed - deltaTime) / adjustedTimeToCompleteMsec;
    const previousDistanceFraction = Math.min(previousProgress, 1);
    const currentDistanceFraction = segmentProgress.current;
    const distanceDiff = currentDistanceFraction - previousDistanceFraction;
    const distanceThisFrameKm = segmentDistanceKm * distanceDiff;

    // Atualizar a distância total percorrida
    totalDistanceTraveledRef.current += distanceThisFrameKm;

    // Atualizar o combustível a cada 1km ou quando o combustível estiver abaixo de 10%
    if (totalDistanceTraveledRef.current - lastFuelUpdateRef.current >= 1 ||
      currentFuelRef.current <= (vehicle.maxCapacity * 0.1)) {
      const distanceSinceLastUpdate = totalDistanceTraveledRef.current - lastFuelUpdateRef.current;
      lastFuelUpdateRef.current = totalDistanceTraveledRef.current;

      // Se o combustível acabou, parar a animação
      if (updateFuel(distanceSinceLastUpdate)) {
        return;
      }
    }

    // Se completou este segmento, avançar para o próximo
    if (segmentProgress.current >= 1) {
      currentSegment.current += 1;
      segmentProgress.current = 0;
      startTimeRef.current = now;

      // Se ainda tem segmentos a percorrer, continua a animação
      if (currentSegment.current < routePath.length - 1) {
        animationFrameRef.current = requestAnimationFrame(animateTruck);
      } else {
        onTripEnd();
      }
      return;
    }

    const newLat = startPoint[0] + (endPoint[0] - startPoint[0]) * segmentProgress.current;
    const newLng = startPoint[1] + (endPoint[1] - startPoint[1]) * segmentProgress.current;
    const newPosition = L.latLng(newLat, newLng);

    truckRef.current.setLatLng(newPosition);
    animationFrameRef.current = requestAnimationFrame(animateTruck);
  }, [playing, routePath, speed, onTripEnd, updateFuel, vehicle.maxCapacity, onFuelEmpty]);

  // Iniciar ou reiniciar a animação quando o estado de playing mudar
  useEffect(() => {
    if (playing && routePath && routePath.length > 1) {
      if (!truckRef.current || (currentSegment.current === 0 && segmentProgress.current === 0)) {
        truckRef.current?.setLatLng(L.latLng(routePath[0][0], routePath[0][1]));
      }

      if (currentSegment.current === 0 && segmentProgress.current === 0) {
        totalDistanceTraveledRef.current = 0;
        lastFuelUpdateRef.current = 0;
        currentFuelRef.current = vehicle.currentFuel;
      }

      if (segmentProgress.current === 0) {
        startTimeRef.current = 0;
      }

      animationFrameRef.current = requestAnimationFrame(animateTruck);
    } else if (!playing && animationFrameRef.current) {
      cancelAnimationFrame(animationFrameRef.current);
      animationFrameRef.current = null;
    }

    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current);
      }
    };
  }, [playing, routePath, animateTruck, vehicle.currentFuel]);

  if (!routePath || routePath.length === 0) return null;

  return (
    <Marker
      position={L.latLng(routePath[0][0], routePath[0][1])} // Posição inicial
      icon={vehicleIcon}
      ref={truckRef}
    >
      <Popup>
        <div className="text-sm">
          <p className="font-bold">{vehicle.name}</p>
          <p>Combustível: {Math.round(currentFuelRef.current)} de {vehicle.maxCapacity}L</p>
        </div>
      </Popup>
    </Marker>
  );
};

const StaticTruckMarker: React.FC<StaticTruckMarkerProps> = ({
  routePath,
  totalProgress,
  vehicle
}) => {
  const vehicleIcon = useMemo(() => {
    let imageUrl = vehicle.image;
    if (imageUrl.startsWith('/src/assets/')) {
      imageUrl = imageUrl.replace('/src/assets/', '/assets/');
    }
    if (!imageUrl.startsWith('/assets/') && !imageUrl.startsWith('http')) {
      imageUrl = `/assets/${imageUrl.split('/').pop()}`;
    }
    return L.icon({
      iconUrl: imageUrl,
      iconSize: [40, 40],
      iconAnchor: [20, 20],
      popupAnchor: [0, -20]
    });
  }, [vehicle.image]);

  // Apenas a nova lógica de cálculo deve existir aqui
  const currentPosition = useMemo(() => {
    return calculatePositionFromProgress(routePath, totalProgress);
  }, [routePath, totalProgress]);

  if (!routePath || routePath.length === 0) return null;

  return (
    <Marker position={currentPosition} icon={vehicleIcon}>
      <Tooltip
        permanent // Faz o tooltip ficar sempre visível
        direction="top" // Posição em relação ao ícone
        offset={[0, -20]} // Ajuste fino da posição (eixo X, eixo Y)
        className="truck-tooltip font-[Silkscreen]" // Classe CSS para estilização customizada
      >
        {/* O conteúdo que você queria no overlay */}
        <div>{totalProgress.toFixed(1)}%</div>
      </Tooltip>
      <Popup>
        <div className="text-sm">
          <p className="font-bold">{vehicle.name}</p>
          <p>🚛 Posição Atual do Jogo</p>
          <p>Progresso: {totalProgress.toFixed(1)}%</p>
        </div>
      </Popup>
    </Marker>
  );
};

interface MapComponentProps {
  preSelectedRoute?: Route | null;
  preSelectedVehicle?: Vehicle | null;
  preAvailableMoney?: number;
  showControls?: boolean;
  // Novos props para sincronizar com o progresso do jogo
  externalProgress?: {
    currentPathIndex: number;
    pathProgress: number;
    totalProgress: number;
  };
}

export const MapComponent: React.FC<MapComponentProps> = ({
  preSelectedRoute = null,
  preSelectedVehicle = null,
  preAvailableMoney = null,
  showControls = true,
  externalProgress = null
}) => {
  const [simulatedTime, setSimulatedTime] = useState<number>(0);
  const location = useLocation();
  const navigate = useNavigate();
  const juazeiroCoordinates = REFERENCE_COORDINATES.JUAZEIRO;
  const salvadorCoordinates = REFERENCE_COORDINATES.SALVADOR;
  const recifeCoordinates = REFERENCE_COORDINATES.RECIFE;
  const fortalezaCoordinates = REFERENCE_COORDINATES.FORTALEZA;
  
  // Obter o desafio selecionado
  const challengeId = location.state?.challengeId || 'salvador';
  const destinationCoordinates = getDestinationCoordinates(challengeId);

  // CORREÇÃO: Sempre priorizar a prop sobre location.state
  const selectedRoute = useMemo(() => {
    if (preSelectedRoute) {
      console.log("📍 Usando rota da prop:", preSelectedRoute.name);
      return preSelectedRoute;
    }
    if (location.state?.selectedRoute) {
      console.log("📍 Usando rota do location.state:", location.state.selectedRoute.name);
      return location.state.selectedRoute;
    }
    console.log("⚠️ Nenhuma rota selecionada");
    return null;
  }, [preSelectedRoute, location.state?.selectedRoute]);
  const [isPlaying, setIsPlaying] = useState(false);

  const completedPath = useMemo(() => {
    if (externalProgress && selectedRoute?.pathCoordinates) {
      return calculatePathFromProgress(selectedRoute.pathCoordinates, externalProgress.totalProgress);
    }
    return [];
  }, [externalProgress, selectedRoute]);

  useEffect(() => {
    let interval: NodeJS.Timeout;

    if (isPlaying) {
      const start = Date.now();
      interval = setInterval(() => {
        const elapsedRealMs = Date.now() - start;
        const accelerationFactor = 8 / 3;
        const simulatedMinutes = (elapsedRealMs / 60000) * accelerationFactor;
        setSimulatedTime(simulatedMinutes);
      }, 1000);
    }

    return () => clearInterval(interval);
  }, [isPlaying]);


  // Estado para veículo e saldo
  const [vehicle, setVehicle] = useState<Vehicle>(() => {
    if (preSelectedVehicle) {
      return preSelectedVehicle;
    }
    if (location.state && location.state.selectedVehicle) {
      return location.state.selectedVehicle;
    }
    if (showControls) {
      navigate('/routes');
    }
    // Retornar um veículo padrão
    return { id: 'carreta', name: 'Carreta', capacity: 60, consumption: { asphalt: 2, dirt: 1.5 }, image: '/carreta.png', maxCapacity: 495, currentFuel: 0, cost: 4500 };
  });

  // Estado para o saldo disponível
  const [availableMoney] = useState<number>(() => {
    if (preAvailableMoney !== null) {
      return preAvailableMoney;
    }
    if (location.state && location.state.availableMoney !== undefined) {
      return location.state.availableMoney;
    }
    return 5500; // Valor padrão
  });

  // Estado para controlar a exibição do modal de fim de jogo
  const [showGameOverModal, setShowGameOverModal] = useState(false);
  const [gameOverReason, setGameOverReason] = useState('');

  // Variável para controlar se o mapa deve ser ajustado automaticamente
  const [initialMapViewSet, setInitialMapViewSet] = useState(false);

  // NOVO ESTADO PARA ARMAZENAR OS SEGMENTOS DA ROTA
  const [renderedSegments, setRenderedSegments] = useState<RenderSegment[]>([]);

  // Centraliza o mapa nos pontos inicial e final da rota selecionada
  function MapViewControl({ route }: { route: Route | null }) {
    const map = useMapEvents({});

useEffect(() => {
  if (route?.pathCoordinates) {
    // Converta pathCoordinates para o formato esperado pelo Leaflet
    const pathCoordinates: [number, number][] = route.pathCoordinates.map(coord => {
      if (coord.length === 2) {
        return [coord[0], coord[1]]; // Garante que cada coordenada tenha exatamente dois elementos
      }
      throw new Error("Coordenada inválida: cada ponto deve ter exatamente [latitude, longitude]");
    });

    // Ajusta os limites do mapa com as coordenadas convertidas
    const bounds = L.latLngBounds(pathCoordinates);
    map.fitBounds(bounds, { padding: [50, 50] });
  }

  // Só ajuste o mapa automaticamente quando uma rota for selecionada pela primeira vez
  // ou quando isPlaying for false (não está em execução)
  if (route && route.pathCoordinates && route.pathCoordinates.length > 1 && (!initialMapViewSet || !isPlaying)) {
    const pathCoordinates: [number, number][] = route.pathCoordinates.map(coord => {
      if (coord.length === 2) {
        return [coord[0], coord[1]];
      }
      throw new Error("Coordenada inválida: cada ponto deve ter exatamente [latitude, longitude]");
    });

    const bounds = L.latLngBounds(pathCoordinates);
    map.fitBounds(bounds, { padding: [50, 50] }); // Ajusta o zoom para caber a rota
    setInitialMapViewSet(true);
  } else if (!route && !initialMapViewSet) {
    // Se nenhuma rota estiver selecionada, centraliza em Juazeiro/Salvador
    const bounds = L.latLngBounds(juazeiroCoordinates, salvadorCoordinates);
    map.fitBounds(bounds, { padding: [100, 100] });
    setInitialMapViewSet(true);
  }
}, [map, route, isPlaying]); // Adicionado isPlaying para reajustar o zoom quando pausado

    return null;
  }

  // NOVA LÓGICA PARA SEGMENTAR A ROTA
  useEffect(() => {
    if (!selectedRoute || !selectedRoute.pathCoordinates) {
      setRenderedSegments([]);
      return;
    }

    const segments: RenderSegment[] = [];
    const totalPoints = selectedRoute.pathCoordinates.length;
    const totalDistance = selectedRoute.actualDistance || selectedRoute.distance;
    let lastIndex = 0;

    const sortedDirtSegments = (selectedRoute.dirtSegments || []).sort((a: any, b: any) => a.startKm - b.startKm);

    sortedDirtSegments.forEach((dirtSegment: any) => {
      const startIndex = Math.floor((dirtSegment.startKm / totalDistance) * totalPoints);
      const endIndex = Math.floor((dirtSegment.endKm / totalDistance) * totalPoints);

      if (startIndex > lastIndex) {
        segments.push({
          path: selectedRoute.pathCoordinates!.slice(lastIndex, startIndex + 1),
          isDirt: false,
          style: { color: '#1e40af', weight: 6, opacity: 1 }
        });
      }

      segments.push({
        path: selectedRoute.pathCoordinates!.slice(startIndex, endIndex + 1),
        isDirt: true,
        style: { color: '#8B4513', weight: 7, opacity: 0.9, dashArray: '10, 10' }
      });

      lastIndex = endIndex;
    });

    if (lastIndex < totalPoints - 1) {
      segments.push({
        path: selectedRoute.pathCoordinates.slice(lastIndex),
        isDirt: false,
        style: { color: '#1e40af', weight: 6, opacity: 1 }
      });
    }

    // Se não houver nenhum segmento (rota sem trechos de terra), desenha a rota inteira
    if (segments.length === 0 && selectedRoute.pathCoordinates.length > 0) {
      segments.push({
        path: selectedRoute.pathCoordinates,
        isDirt: false,
        style: { color: '#1e40af', weight: 6, opacity: 1 }
      });
    }

    setRenderedSegments(segments);

  }, [selectedRoute]);

  const handleTripEnd = useCallback(() => {
    setIsPlaying(false);
    alert('Viagem concluída!');
  }, []);



  // Ícone para áreas de risco
  const getRiskIcon = (riskLevel: 'Baixo' | 'Médio' | 'Alto'): L.Icon => {
    switch (riskLevel) {
      case 'Baixo': return lowRiskIcon;
      case 'Médio': return mediumRiskIcon;
      case 'Alto': return highRiskIcon;
      default: return mediumRiskIcon;
    }
  };

  const getGasIcon = (): L.Icon => {
    return gasStationIcon;
  };

  const handleChangeRoute = () => {
    navigate('/routes', {
      state: {
        selectedVehicle: vehicle,
        availableMoney: availableMoney
      }
    });
  };

  const handlePause = async () => {
    try {
      await GameService.pauseGame();
      setIsPlaying(false);
      console.log('Jogo pausado no backend');
    } catch (error) {
      console.error('Erro ao pausar jogo:', error);
    }
  };
  
  const handleResume = async () => {
    try {
      await GameService.resumeGame();
      setIsPlaying(true);
      console.log('Jogo retomado no backend');
    } catch (error) {
      console.error('Erro ao retomar jogo:', error);
    }
  };

  const handleFuelEmpty = useCallback(() => {
    setIsPlaying(false);
    setGameOverReason('combustível');
    setShowGameOverModal(true);
  }, []);

  return (
    <div className="flex flex-col lg:flex-row h-screen p-4 font-['Silkscreen'] bg-[#200259]">
      {showControls && (
        <div className="absolute top-0 left-0 w-full flex items-center justify-between px-8 py-4 z-40">
          <button
            className="flex items-center px-6 py-2 bg-[#E3922A] text-black font-bold text-lg rounded-md shadow-lg
                     hover:bg-[#FFC06F] transition-all duration-200 border-2 border-black"
            onClick={handleChangeRoute}
          >
            <ArrowLeft /> TROCAR ROTA
          </button>
          <h1 className="text-3xl font-bold text-[#E3922A] text-center flex-1 -ml-16">
            {selectedRoute?.name || 'MAPA DA ROTA'}
          </h1>
          <div className="bg-[#E3922A] text-black text-2xl font-bold px-6 py-2 rounded-md shadow-lg border-2 border-black">
            R$ {availableMoney.toFixed(2)}
          </div>
        </div>
      )}

      <div className={` font-[silkscreen] flex-1 w-full relative bg-gray-200 rounded-lg shadow-inner border-4 border-black ${showControls ? 'mt-20' : ''}`}>
        {selectedRoute && showControls && (
          <div className="font-[silkscreen] absolute top-4 right-4 flex space-x-2 z-[1000]">
            <button
              className="font-[silkscreen]px-4 py-2 bg-green-500 text-white font-bold text-md rounded-md shadow-lg hover:bg-green-600 transition-all duration-200 border-2 border-black"
              onClick={() => setIsPlaying(true)}
              disabled={isPlaying || !selectedRoute.pathCoordinates || selectedRoute.pathCoordinates.length < 2 || vehicle.currentFuel <= 0}
            >
              {isPlaying ? 'EM ANDAMENTO' : 'INICIAR'}
            </button>
            <button
              className="px-4 py-2 bg-blue-500 text-white font-bold text-md rounded-md shadow-lg hover:bg-blue-600 transition-all duration-200 border-2 border-black"
              onClick={() => navigate('/game', {
                state: {
                  vehicle,
                  availableMoney
                }
              })}
              disabled={!selectedRoute || vehicle.currentFuel <= 0}
            >
              JOGO 2D
            </button>
            {isPlaying && (
              <div className="px-4 py-2 bg-white text-black font-['Silkscreen'] text-md rounded shadow-md border-2 border-black">
                Tempo: {Math.floor(simulatedTime / 60).toString().padStart(2, '0')}h:{Math.floor(simulatedTime % 60).toString().padStart(2, '0')}
              </div>
            )}
            <button
              className="px-4 py-2 bg-yellow-500 text-black font-bold text-md rounded-md shadow-lg hover:bg-yellow-600 transition-all duration-200 border-2 border-black"
              onClick={handlePause}
              disabled={!isPlaying}
            >
              PAUSAR
            </button>
          </div>

          
        )}
        <MapContainer
          center={juazeiroCoordinates}
          zoom={7}
          scrollWheelZoom={true}
          className="w-full h-full rounded-lg"
        >
          <TileLayer
            attribution='© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
          />
          <MapViewControl route={selectedRoute} />

          {/* Apenas a rota selecionada será exibida */}

          {/* Renderiza a rota selecionada em segmentos */}
          {renderedSegments.map((segment, index) => (
            <Polyline
              key={`segment-${selectedRoute?.routeId}-${index}`}
              positions={segment.path}
              pathOptions={segment.style}
            >
              <Popup>
                {segment.isDirt ?
                  <span className="font-bold text-yellow-800">Trecho de Terra</span> :
                  <span className="font-bold text-blue-700">{selectedRoute?.name}</span>
                }
              </Popup>
            </Polyline>
          ))}

          {/* Linha do progresso percorrido (quando há dados externos) */}
          {completedPath.length > 0 && (
            <Polyline
              positions={completedPath}
              pathOptions={{
                color: '#00cc66',
                weight: 6,
                opacity: 0.9
              }}
            >
              <Popup>
                <span className="font-bold text-green-700">Percurso Concluído - {externalProgress?.totalProgress.toFixed(1)}%</span>
              </Popup>
            </Polyline>
          )}
          {/* Marcadores de Velocidade para a Rota Selecionada */}
          {selectedRoute?.speedLimits.map((speedLimit: any, index: number) => (
            speedLimit.coordinates && (
              <Marker
                key={`speed-${selectedRoute.routeId}-${index}`}
                position={speedLimit.coordinates}
                icon={getSpeedLimitIcon(speedLimit.value ?? 60)}
              >
                <Popup>
                  <span className="font-bold">Limite de Velocidade:</span><br />
                  {speedLimit.limit} na {speedLimit.road}
                </Popup>
              </Marker>
            )
          ))}

          {/* Renderiza os marcadores */}
          {selectedRoute?.tollBooths.map((toll: any, index: number) =>{ 
            // console.log("Renderizando tollBooths:", toll);
            <Marker key={`toll-${index}`} position={toll.coordinates as L.LatLngTuple} icon={tollIcon}><Popup>{toll.location}</Popup></Marker>})}

          {selectedRoute?.fuelStop?.map((gas: any, index: number) => {
            return (
              <Marker
                key={`fuel-${index}`}
                position={gas.coordinates as L.LatLngTuple}
                icon={getGasIcon()}
              >
                <Popup>{gas.locationName}</Popup>
              </Marker>
            );
          })}

          {selectedRoute?.dangerZones?.map((zone: any, index: number) => <Marker key={`danger-${index}`} position={zone.coordinates as L.LatLngTuple} icon={getRiskIcon(zone.riskLevel)}><Popup>{zone.description}</Popup></Marker>)}

          <Marker position={juazeiroCoordinates}><Popup>Ponto de Partida: Juazeiro</Popup></Marker>
          <Marker position={destinationCoordinates}><Popup>Destino: {challengeId === 'recife' ? 'Recife' : challengeId === 'fortaleza' ? 'Fortaleza' : 'Salvador'}</Popup></Marker>

          {/* Componente de animação do caminhão */}
          {selectedRoute?.pathCoordinates && (
            externalProgress ? (
              // Usar posição externa quando fornecida (para modal do jogo)
              <StaticTruckMarker
                routePath={selectedRoute.pathCoordinates}
                totalProgress={externalProgress.totalProgress}
                vehicle={vehicle}
              />
            ) : (
              // Usar animação normal quando não há dados externos
              <TruckAnimation
                routePath={selectedRoute.pathCoordinates}
                speed={(selectedRoute.actualDistance || selectedRoute.distance) / selectedRoute.estimatedTimeHours}
                playing={isPlaying}
                onTripEnd={handleTripEnd}
                onFuelEmpty={handleFuelEmpty}
                vehicle={vehicle}
                setCurrentFuel={(fuel) => setVehicle(prev => ({ ...prev, currentFuel: fuel }))}
                isDirtRoad={selectedRoute.dirtRoad || false}
              />
            )
          )}
        </MapContainer>
      </div>
      {showControls && (
        <div className="lg:w-1/4 w-full p-4 rounded-lg shadow-lg overflow-y-auto mb-4 lg:mb-0 lg:ml-4 mt-20 font-['Silkscreen']">
          <div className="bg-[#FFC06F] p-4 rounded-lg shadow-md border-2 border-black mb-6">
            <h2 className="text-xl font-['Silkscreen'] font-bold mb-3 text-black text-center border-b-2 border-black pb-2">
              INFORMAÇÕES DA ROTA
            </h2>

            {selectedRoute && (
              <div>
                <h3 className="font-['Silkscreen'] text-lg font-bold text-black mb-2">
                  {selectedRoute.name.toUpperCase()}
                </h3>
                <p className="font-sans text-black text-md mb-1">
                  <span className="font-bold">TEMPO ESTIMADO:</span> {selectedRoute.estimatedTime}
                </p>
                <p className="font-sans text-black text-md mb-1">
                  <span className="font-bold">DISTÂNCIA:</span> {selectedRoute.actualDistance ? `${selectedRoute.actualDistance.toFixed(0)}` : selectedRoute.distance} km
                </p>
                <p className="font-sans text-black text-md mb-3">
                  <span className="font-bold">RISCO:</span> {selectedRoute.safety.robberyRisk}
                </p>
              </div>
            )}

            <div className="bg-black h-px my-4"></div>

            <h3 className="font-['Silkscreen'] text-lg font-bold text-black mb-2">
              VEÍCULO: {vehicle.name.toUpperCase()}
            </h3>
            <p className="font-sans text-black text-md mb-1">- ASFALTO: {vehicle.consumption.asphalt}KM/L</p>
            <p className="font-sans text-black text-md mb-3">- TERRA: {vehicle.consumption.dirt}KM/L</p>

            <p className="font-sans text-black text-md mb-2">NÍVEL DO TANQUE</p>
            <div className="w-full bg-gray-300 rounded-full h-6 border-2 border-black">
              <div
                className="bg-green-500 h-full rounded-full flex items-center justify-center text-xs font-bold text-white"
                style={{ width: `${(vehicle.currentFuel / vehicle.maxCapacity) * 100}%` }}
              >
                {vehicle.currentFuel.toFixed(0)}/{vehicle.maxCapacity}L
              </div>
            </div>
          </div>
        </div>
      )}

      {showGameOverModal && (
        <div className="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-[9999] p-4">
          <div className="bg-[#200259] rounded-lg shadow-2xl border-4 border-red-500 max-w-md w-full p-6">
            <h1 className="text-2xl font-['Silkscreen'] font-bold text-red-500 text-center mb-4">FIM DE JOGO!</h1>
            <p className="text-xl font-['Silkscreen'] text-white text-center mb-6">{gameOverReason === 'combustível' ? 'Seu combustível acabou!' : 'Viagem interrompida!'}</p>
            <div className="flex justify-center space-x-4">
              <button onClick={() => { setShowGameOverModal(false); navigate('/select-vehicle'); }} className="px-6 py-3 bg-red-500 text-white font-bold rounded-md shadow-lg border-2 border-black hover:bg-red-600 transition-all duration-200">
                VOLTAR AO INÍCIO
              </button>
            </div>
          </div>
        </div>
      )}


    </div>
  );
};
</file>

<file path="src/pages/Game-truck/game.tsx">
// src/pages/Game-truck/game.tsx - VERSÃO FINAL CORRIGIDA COM BACKGROUND FUNCIONANDO
import { useEffect, useRef, useState } from "react";
import { useLocation, useNavigate } from "react-router-dom";
import { useMutation } from "@tanstack/react-query";
import kaboom from "kaboom";
import './game.css';
import { PartidaData } from "../../types/ranking";
import { Vehicle } from "../../types/vehicle";
import { GameMiniMap } from "./GameMiniMap";
import { MapComponent } from "../mapaRota/MapComponent";
import { PauseMenu } from "../PauseMenu/PauseMenu";
import { GameService } from "../../api/gameService";
import { PixelProgressBar } from "../../components/PixelProgressBar/PixelProgressBar";
import '../../components/PixelProgressBar/PixelProgressBar.css';
import type {
  GameObj,
  SpriteComp,
  PosComp,
  ZComp,
  AreaComp,
  BodyComp,
  ScaleComp
} from "kaboom";

// Interface para eventos vindos da API
interface EventData {
  id: number;
  partida: number;
  evento: {
    id: number;
    nome: string;
    descricao: string;
    tipo: 'positivo' | 'negativo';
    categoria: string;
    opcoes: Array<{
      id: number;
      descricao: string;
      efeitos: any;
    }>;
  };
  momento: string;
  ordem: number;
  opcao_escolhida: null;
}

export function GameScene() {

  // REFs DE CONTROLE DE EVENTOS
  const lastEventCheckKm = useRef(0);
  const activeGameIdRef = useRef<number | null>(null);
  const isFinishing = useRef(false);

  const location = useLocation();
  const navigate = useNavigate();
  const canvasRef = useRef<HTMLCanvasElement | null>(null);
  const [showPopup, setShowPopup] = useState(false);
  const [playerChoice, setPlayerChoice] = useState<string | null>(null);
  const [isPaused, setIsPaused] = useState(false);
  const gamePaused = useRef(false);
  const collidedObstacle = useRef<GameObj | null>(null);
  const destroyRef = useRef<((obj: GameObj) => void) | null>(null);

  // ESTADOS PARA INTEGRAÇÃO COM API
  const [activeEvent, setActiveEvent] = useState<EventData | null>(null);
  const [isResponding, setIsResponding] = useState(false);
  const [activeGameId, setActiveGameId] = useState<number | null>(null);

  const processingEvent = useRef(false);
  const [gameEnded, setGameEnded] = useState(false);
  const [showEndMessage, setShowEndMessage] = useState(false);
  const [gameLoaded, setGameLoaded] = useState(false);
  const [loadingError, setLoadingError] = useState<string | null>(null);
  const gameInitialized = useRef(false);
  const progressRef = useRef(0);
  const [progress, setProgress] = useState(0);
  const distanceTravelled = useRef(0);

  const [currentPathIndex, setCurrentPathIndex] = useState(0);
  const pathProgressRef = useRef(0);
  const currentPathIndexRef = useRef(0);
  const gameSpeedMultiplier = useRef(1);
  const obstacleTimerRef = useRef(0);
  const collisionCooldownRef = useRef(0);
  const obstacleSystemLockedRef = useRef(false);
  const handleResizeRef = useRef<(() => void) | null>(null);

  // LÓGICA DE TEMPO CORRIGIDA
  const [gameTime, setGameTime] = useState(0);
  const FATOR_ACELERACAO_TEMPO = 24;
  const lastFrameTimeRef = useRef(performance.now());
  const tickTimerRef = useRef<NodeJS.Timeout | null>(null);

  const [finalGameResults, setFinalGameResults] = useState<PartidaData | null>(null);
  const [currentFuel, setCurrentFuel] = useState<number>(location.state?.selectedVehicle?.currentFuel || 0);
  const [totalDistance, setTotalDistance] = useState<number>(500);

  const [showMapModal, setShowMapModal] = useState(false);

  // ✅ ADIÇÃO: Estados para sistema de background da versão antiga
  const currentBg = useRef<'cidade' | 'terra'>('cidade');
  const nextBg = useRef<'cidade' | 'terra' | null>(null);
  const backgroundSwitchTimer = useRef(0);
  const transitionProgress = useRef(0);
  const isTransitioning = useRef(false);
  const transitionCooldown = useRef(0);
  const TRANSITION_DURATION = 5;
  const COOLDOWN_DURATION = 0.1;

  // ✅ ADIÇÃO: Sistema de zoom cinematográfico
  const ZOOM_CONFIG = {
    MAX_ZOOM: 1.5,
    LEAD_IN_TIME: 0.5,
    LEAD_OUT_TIME: 1.0,
  };
  const ZOOM_TOTAL_DURATION = ZOOM_CONFIG.LEAD_IN_TIME + TRANSITION_DURATION + ZOOM_CONFIG.LEAD_OUT_TIME;

  const zoomEffect = useRef({
    isActive: false,
    progress: 0,
    duration: ZOOM_TOTAL_DURATION,
    maxZoom: ZOOM_CONFIG.MAX_ZOOM,
    originalZoom: 1.0,
  });

  // Estados vindos dos parâmetros de navegação
  const [vehicle, setVehicle] = useState<Vehicle>(() => {
    console.log("Estado recebido no jogo:", location.state);

    if (location.state && location.state.selectedVehicle) {
      console.log("Veículo encontrado:", location.state.selectedVehicle);
      return location.state.selectedVehicle;
    }

    console.warn("Nenhum veículo encontrado, redirecionando...");
    navigate('/select-vehicle');
    return { id: 'default', name: 'Caminhão Padrão', capacity: 1000, consumption: { asphalt: 3, dirt: 2 }, image: '/assets/truck.png', maxCapacity: 100, currentFuel: 0, cost: 1000 };
  });

  const [money, setMoney] = useState(() => {
    const money = location.state?.availableMoney;
    console.log("Dinheiro recebido:", money);
    return money !== undefined ? money : 1000;
  });

  const [selectedRoute, setSelectedRoute] = useState(() => {
    const route = location.state?.selectedRoute;
    console.log("Rota recebida:", route);
    return route || null;
  });

  useEffect(() => {
    console.log("🎮 GameScene montado com estado:", {
      vehicle: location.state?.selectedVehicle?.name,
      route: location.state?.selectedRoute?.name,
      hasPathCoordinates: !!location.state?.selectedRoute?.pathCoordinates,
      pathCoordinatesLength: location.state?.selectedRoute?.pathCoordinates?.length || 0,
      money: location.state?.availableMoney,
      savedProgress: !!location.state?.savedProgress
    });
  }, []);

  // ============= MUTAÇÕES PARA COMUNICAÇÃO COM A API =============

  // Mutação para criar o jogo no backend
  const createGameMutation = useMutation({
    mutationFn: (gameData: { mapa: number; rota: number; veiculo: number }) =>
      GameService.createGame(gameData),
    onSuccess: (partida) => {
      console.log('🎮 Partida criada com sucesso no backend, ID:', partida.id);

      setActiveGameId(partida.id);
      activeGameIdRef.current = partida.id;
      setMoney(partida.saldo);
      setCurrentFuel(partida.combustivel_atual);

      console.log('💰 Estado sincronizado - Saldo:', partida.saldo, 'Combustível:', partida.combustivel_atual);
      console.log('🔗 activeGameIdRef definido como:', activeGameIdRef.current);
    },
    onError: (error) => {
      console.error('❌ Erro ao criar partida:', error);
      alert('Não foi possível iniciar o jogo. Tente novamente.');
      navigate('/routes');
    }
  });

  // MUTAÇÃO DE TICK CORRIGIDA - SEM SINCRONIZAÇÃO DE TEMPO
  const partidaTickMutation = useMutation({
    mutationFn: (data: { distancia_percorrida: number }) => GameService.partidaTick(data),
    onSuccess: (updatedPartida) => {
      // Sincroniza apenas dados financeiros e combustível
      setMoney(updatedPartida.saldo);
      setCurrentFuel(updatedPartida.combustivel_atual);

      // ✅ CORREÇÃO: REMOVIDA sincronização de tempo aqui
      // O tempo continua acelerado no frontend sem interferência
      console.log(`💰 Tick processado - Saldo: ${updatedPartida.saldo}, Combustível: ${updatedPartida.combustivel_atual}`);
    },
    onError: (error) => {
      console.error("Erro no tick:", error);
    }
  });

  // MUTAÇÃO PARA BUSCAR EVENTOS
  const fetchNextEventMutation = useMutation({
    mutationFn: (distancia: number) => GameService.getNextEvent(distancia),
    onSuccess: (data) => {
      if (data && data.evento) {
        console.log('🎲 Evento recebido do backend:', data.evento.nome, '(categoria:', data.evento.categoria + ')');
        setActiveEvent(data);
        setShowPopup(true);
      } else {
        console.warn('⚠️ onSuccess chamado com dados inválidos, resetando estado');
        processingEvent.current = false;
        gamePaused.current = false;
      }
    },
    onError: (error: any) => {
      console.warn('⚠️ Erro ao buscar evento:', error);

      if (error.message === 'NO_EVENT_AVAILABLE') {
        console.log('ℹ️ Nenhum evento desta vez (NORMAL) - continuando jogo');

        setActiveEvent(null);
        setShowPopup(false);
        setIsResponding(false);
        gamePaused.current = false;
        processingEvent.current = false;
        collidedObstacle.current = null;

        obstacleTimerRef.current = -3;
        collisionCooldownRef.current = 1.5;

        return;
      }

      console.error('❌ Erro real detectado:', error.message);

      setActiveEvent(null);
      setShowPopup(false);
      setIsResponding(false);
      gamePaused.current = false;
      processingEvent.current = false;
      collidedObstacle.current = null;

      if (error.message === 'INVALID_REQUEST') {
        console.warn('⚠️ Request inválido, aguardando próximo checkpoint');
        lastEventCheckKm.current += 10;
      } else if (error.message === 'SERVER_ERROR' || error.message === 'NETWORK_ERROR') {
        console.error('💥 Erro de servidor/rede, aguardando recuperação');
        lastEventCheckKm.current += 30;
      } else if (error.message === 'INVALID_API_RESPONSE') {
        console.error('💥 API retornou dados inválidos');
        lastEventCheckKm.current += 15;
      } else {
        console.error('❌ Erro não categorizado:', error.message);
        lastEventCheckKm.current += 15;
      }

      obstacleTimerRef.current = -5;
      collisionCooldownRef.current = 2.0;

      setTimeout(() => {
        obstacleSystemLockedRef.current = false;
        console.log('🔓 Sistema de obstáculos destravado após erro de evento');
      }, 3000);
    }
  });

  // MUTAÇÃO PARA RESPONDER EVENTO - MANTÉM sincronização de tempo apenas aqui
  const respondToEventMutation = useMutation({
    mutationFn: (data: { optionId: number; distancia: number }) =>
      GameService.respondToEvent(data.optionId, data.distancia),
    onSuccess: (data) => {
      const updatedPartida = data.partida;
      console.log('✅ Resposta processada pelo backend:', data.detail);

      // Sincronizar estado financeiro e combustível
      setMoney(updatedPartida.saldo);
      setCurrentFuel(updatedPartida.combustivel_atual);

      // Sincronizar tempo (para penalidades e bônus de eventos)
      if (updatedPartida.tempo_jogo_segundos !== undefined) {
        setGameTime(updatedPartida.tempo_jogo_segundos);
        console.log(`⏱️ TEMPO ATUALIZADO APÓS EVENTO: ${updatedPartida.tempo_jogo_segundos}s (${Math.floor(updatedPartida.tempo_jogo_segundos / 60)}min)`);
      }

      // ✅ CORREÇÃO: Sincronizar distância se houve mudança (bônus de distância)
      if (updatedPartida.distancia_percorrida !== undefined && totalDistance > 0) {
        const novoProgresso = Math.min(100, (updatedPartida.distancia_percorrida / totalDistance) * 100);

        const progressoAnterior = progressRef.current;
        progressRef.current = novoProgresso;
        setProgress(novoProgresso);
        distanceTravelled.current = updatedPartida.distancia_percorrida;

        console.log(`📍 PROGRESSO ATUALIZADO APÓS EVENTO:`);
        console.log(`   Anterior: ${progressoAnterior.toFixed(2)}%`);
        console.log(`   Novo: ${novoProgresso.toFixed(2)}%`);
        console.log(`   Distância: ${updatedPartida.distancia_percorrida}km/${totalDistance}km`);

        if (novoProgresso - progressoAnterior > 1) {
          console.log(`🚀 BÔNUS DE DISTÂNCIA APLICADO: +${(novoProgresso - progressoAnterior).toFixed(2)}% de progresso!`);
        }
      }

      // Mostrar resultado do evento
      if (data.detail && data.detail !== "Sua decisão foi processada.") {
        alert(`📋 Resultado: ${data.detail}`);
      }

      // Limpar e continuar o jogo
      setShowPopup(false);
      setActiveEvent(null);
      setIsResponding(false);
      processingEvent.current = false;
      gamePaused.current = false;
      collidedObstacle.current = null;

      obstacleTimerRef.current = -8;
      collisionCooldownRef.current = 3.0;

      setTimeout(() => {
        obstacleSystemLockedRef.current = false;
        console.log('🔓 Sistema de obstáculos destravado após evento');
      }, 8000);
    },
    onError: (error) => {
      console.error('❌ Erro ao responder evento:', error);
      alert('Erro ao processar sua resposta. O jogo continuará.');
      setIsResponding(false);
      gamePaused.current = false;
      processingEvent.current = false;
    }
  });

  // Função de finalização
  const syncGameMutation = useMutation({
    mutationFn: (progressData: { tempo_decorrido_segundos: number }) =>
      GameService.syncGameProgress(progressData),
    onSuccess: (updatedPartida: PartidaData) => {
      console.log("✅ Progresso sincronizado!", updatedPartida);

      if (updatedPartida.status === 'concluido') {
        console.log("🏁 PARTIDA FINALIZADA! Resultados:", updatedPartida);
        setFinalGameResults(updatedPartida);
        setGameEnded(true);
        setShowEndMessage(true);
        gamePaused.current = true;
      }
    },
    onError: (error) => {
      console.error("❌ Erro ao sincronizar jogo:", error);
      alert("Houve um erro ao finalizar a partida. Tente novamente.");
    }
  });

  // ✅ ADIÇÃO: Funções do sistema de zoom
  const easeInOutCubic = (t: number): number => {
    return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
  };

  const applyZoomEffect = (k: any, deltaTime: number) => {
    if (!zoomEffect.current.isActive) return;

    zoomEffect.current.progress += deltaTime / zoomEffect.current.duration;
    let currentZoom = zoomEffect.current.originalZoom;

    if (zoomEffect.current.progress >= 1.0) {
      zoomEffect.current.isActive = false;
      zoomEffect.current.progress = 0;

      k.camScale(k.vec2(1.0));
      k.camPos(k.center());

      console.log("🎬 Efeito de zoom de transição finalizado!");
      return;
    }

    if (zoomEffect.current.progress < 0.5) {
      const t = zoomEffect.current.progress / 0.5;
      currentZoom = zoomEffect.current.originalZoom + (zoomEffect.current.maxZoom - zoomEffect.current.originalZoom) * easeInOutCubic(t);
    } else {
      const t = (zoomEffect.current.progress - 0.5) / 0.5;
      currentZoom = zoomEffect.current.maxZoom - (zoomEffect.current.maxZoom - zoomEffect.current.originalZoom) * easeInOutCubic(t);
    }

    k.camScale(k.vec2(currentZoom));

    const centerX = k.width() / 2;
    const centerY = k.height() / 2;
    const yOffset = (centerY * 0.5) * (currentZoom - 1);
    const xOffset = (centerX * -0.9) * (currentZoom - 1);

    k.camPos(centerX + xOffset, centerY + yOffset);
  };

  const startZoomEffect = () => {
    console.log("🎬 Iniciando efeito de zoom cinematográfico!");
    zoomEffect.current.isActive = true;
    zoomEffect.current.progress = 0;
  };

  // ✅ ADIÇÃO: Sistema de background modular da versão antiga
  const updateBackgroundSystem = (k: any, deltaTime: number, moveAmount: number) => {
    // Aplicar efeito de zoom
    applyZoomEffect(k, deltaTime);

    // Movimento dos backgrounds
    k.get("bg_cidade").forEach((bg: any) => bg.move(moveAmount, 0));
    k.get("bg_terra").forEach((bg: any) => bg.move(moveAmount, 0));

    // Gerenciar cooldown
    if (transitionCooldown.current > 0) {
      transitionCooldown.current -= deltaTime;
    }

    // Garantir que sempre temos um background visível quando não há transição
    if (!isTransitioning.current && !nextBg.current && transitionProgress.current === 0 && transitionCooldown.current <= 0) {
      k.get(`bg_${currentBg.current}`).forEach((bg: any) => {
        if (bg.opacity !== 1) bg.opacity = 1;
      });
      const otherBg = currentBg.current === 'cidade' ? 'terra' : 'cidade';
      k.get(`bg_${otherBg}`).forEach((bg: any) => {
        if (bg.opacity !== 0) bg.opacity = 0;
      });
    }

    // Reposicionamento dos backgrounds
    const bgWidth = 2048 * Math.max(k.width() / 2048, k.height() / 762);
    const backgrounds = k.get("bg_cidade").concat(k.get("bg_terra"));

    backgrounds.forEach((bg: any, index: number) => {
      if (index % 2 === 0) { // bg1 de cada tipo
        const otherBg = backgrounds[index + 1];
        if (otherBg && bg.pos.x + bgWidth <= 0) {
          bg.pos.x = otherBg.pos.x + bgWidth;
        }
      } else { // bg2 de cada tipo
        const otherBg = backgrounds[index - 1];
        if (otherBg && bg.pos.x + bgWidth <= 0) {
          bg.pos.x = otherBg.pos.x + bgWidth;
        }
      }
    });

    // Sistema de transição suave com opacity
    if (isTransitioning.current && nextBg.current) {
      transitionProgress.current += deltaTime / TRANSITION_DURATION;

      if (transitionProgress.current >= 1) {
        transitionProgress.current = 0;
        isTransitioning.current = false;

        const newCurrentBg = nextBg.current;
        const oldBg = currentBg.current;

        k.get(`bg_${newCurrentBg}`).forEach((bg: any) => { bg.opacity = 1; });
        k.get(`bg_${oldBg}`).forEach((bg: any) => { bg.opacity = 0; });

        currentBg.current = newCurrentBg;
        nextBg.current = null;
        transitionCooldown.current = COOLDOWN_DURATION;

        console.log(`Transição suave completa! Novo cenário é ${currentBg.current}`);
      }

      if (isTransitioning.current && nextBg.current) {
        const easedProgress = easeInOutCubic(transitionProgress.current);
        const currentOpacity = 1 - easedProgress;
        const nextOpacity = easedProgress;

        k.get(`bg_${currentBg.current}`).forEach((bg: any) => { bg.opacity = currentOpacity; });
        k.get(`bg_${nextBg.current}`).forEach((bg: any) => { bg.opacity = nextOpacity; });
      }
    }

    // Timer para mudança de background
    backgroundSwitchTimer.current -= deltaTime;
    if (backgroundSwitchTimer.current <= 0 && !nextBg.current && !isTransitioning.current) {
      const shouldSwitchToTerra = (currentBg.current === 'cidade' && k.rand() < 0.3);
      const shouldSwitchToCidade = (currentBg.current === 'terra' && k.rand() < 0.8);

      if (shouldSwitchToTerra || shouldSwitchToCidade) {
        startZoomEffect();

        k.wait(ZOOM_CONFIG.LEAD_IN_TIME, () => {
          const bgWidth = 2048 * Math.max(k.width() / 2048, k.height() / 762);

          if (shouldSwitchToTerra) {
            nextBg.current = 'terra';
            const bgTerra = k.get("bg_terra");
            if (bgTerra.length >= 2) {
              bgTerra[0].pos.x = 0;
              bgTerra[1].pos.x = bgWidth;
            }
            console.log("🎬 Iniciando FADE: cidade → terra");
          } else if (shouldSwitchToCidade) {
            nextBg.current = 'cidade';
            const bgCidade = k.get("bg_cidade");
            if (bgCidade.length >= 2) {
              bgCidade[0].pos.x = 0;
              bgCidade[1].pos.x = bgWidth;
            }
            console.log("🎬 Iniciando FADE: terra → cidade");
          }

          isTransitioning.current = true;
          transitionProgress.current = 0;
        });

        backgroundSwitchTimer.current = k.rand(15, 25);
      }
    }
  };

  const togglePause = () => {
    const nextPausedState = !gamePaused.current;
    gamePaused.current = nextPausedState;
    setIsPaused(nextPausedState);
    console.log(`Jogo ${nextPausedState ? "pausado" : "despausado"}`);
  };

  const handleRestart = () => {
    window.location.reload();
  };

  const handleGoToProfile = () => {
    const gameProgress = {
      vehicle,
      money,
      selectedRoute,
      currentFuel,
      progress,
      currentPathIndex,
      pathProgress: pathProgressRef.current,
      gameTime,
      timestamp: Date.now(),
      activeGameId: activeGameIdRef.current
    };
    localStorage.setItem('savedGameProgress', JSON.stringify(gameProgress));
    navigate('/perfil');
  };

  const handleSaveAndPause = () => {
    console.log("💾 Salvando progresso e pausando o jogo...");
    const gameProgress = {
      vehicle,
      money,
      selectedRoute,
      currentFuel,
      progress,
      currentPathIndex,
      pathProgress: pathProgressRef.current,
      gameTime,
      timestamp: Date.now(),
      activeGameId: activeGameIdRef.current
    };
    localStorage.setItem('savedGameProgress', JSON.stringify(gameProgress));
    togglePause();
  };

  const handleOptionClick = (optionId: number) => {
    if (isResponding) return;

    console.log("🎯 Processando escolha do evento - Opção ID:", optionId);
    setIsResponding(true);
    const distanciaAtual = (progressRef.current / 100) * totalDistance;
    respondToEventMutation.mutate({ optionId, distancia: distanciaAtual });
  };

  // ============= INICIALIZAÇÃO DO JOGO =============

  const initializeGame = (savedProgress?: any) => {
    if (!vehicle || !vehicle.name) {
      console.error("Dados do veículo não encontrados");
      return;
    }

    if (!canvasRef.current) {
      console.error("Canvas não encontrado, tentando novamente...");
      setTimeout(() => initializeGame(savedProgress), 100);
      return;
    }

    console.log("Canvas encontrado:", canvasRef.current);

    if (!document.contains(canvasRef.current)) {
      console.error("Canvas não está no DOM, aguardando...");
      setTimeout(() => initializeGame(savedProgress), 100);
      return;
    }

    if ((window as any).__kaboom_initiated__) {
      (window as any).__kaboom_initiated__ = false;
    }

    console.log("Inicializando jogo com veículo:", vehicle.name, "Imagem:", vehicle.image);
    console.log("Combustível atual no início:", currentFuel);

    handleResizeRef.current = () => {
      if (canvasRef.current) {
        canvasRef.current.width = window.innerWidth;
        canvasRef.current.height = window.innerHeight;
      }
    };

    try {
      setGameLoaded(false);
      setLoadingError(null);

      const testContext = canvasRef.current!.getContext('webgl') || canvasRef.current!.getContext('experimental-webgl');
      if (!testContext) {
        throw new Error("WebGL não suportado neste navegador");
      }

      const k = kaboom({
        canvas: canvasRef.current!,
        width: window.innerWidth,
        height: window.innerHeight,
        background: [0, 0, 0],
        crisp: true,
      });

      window.addEventListener('resize', handleResizeRef.current!);
      (window as any).__kaboom_initiated__ = true;

      const {
        loadSprite,
        scene,
        go,
        add,
        sprite,
        pos,
        area,
        body,
        isKeyDown,
        width,
        height,
        dt,
        onUpdate,
        z,
        scale,
        destroy,
        loop,
        rand,
        choose,
        move,
        tween,
        easings,
        LEFT,
        RIGHT,
        get,
        wait,
        opacity
      } = k;

      destroyRef.current = destroy;

      try {
        console.log("Tentando carregar sprites...");

        // ✅ CORREÇÃO: Carregamento correto dos backgrounds
        loadSprite("background_cidade", "/assets/background-cidade.png");
        loadSprite("background_terra", "/assets/background-terra.png");

        const vehicleImageUrl = getVehicleImageUrl(vehicle.spriteSheet);
        console.log("Imagem original do veículo:", vehicle.image);
        console.log("URL convertida para kaboom:", vehicleImageUrl);

        loadSprite("car", vehicleImageUrl, {
          sliceX: 2,
          sliceY: 1,
          anims: {
            run: { from: 0, to: 1, loop: true, speed: 8 },
          },
        });

        // veiculos do trafego
        loadSprite("carro_1", "/assets/carro_trafego_1.png");
        loadSprite("carro_2", "/assets/carro_trafego_2.png");
        loadSprite("carro_3", "/assets/carro_trafego_3.png");
        loadSprite("carro_4", "/assets/carro_trafego_4.png");
        loadSprite("carro_5", "/assets/carro_trafego_5.png");
        loadSprite("carro_6", "/assets/carro_trafego_6.png");
        loadSprite("carro_7", "/assets/carro_trafego_7.png");
        loadSprite("carro_8", "/assets/carro_trafego_8.png");
        loadSprite("moto_1", "/assets/moto_trafego_1.png");

        console.log("Todos os sprites carregados com sucesso");
      } catch (error) {
        console.error("Erro ao carregar sprites:", error);
      }

      scene("main", () => {
        const speed = 5000;

        // ✅ CORREÇÃO: Uso das dimensões corretas
        const LARGURA_ORIGINAL_BG = 2048;
        const ALTURA_ORIGINAL_BG = 762;

        const bgScaleX = width() / LARGURA_ORIGINAL_BG;
        const bgScaleY = height() / ALTURA_ORIGINAL_BG;
        const bgScale = Math.max(bgScaleX, bgScaleY);
        const bgWidth = LARGURA_ORIGINAL_BG * bgScale;

        const bgOffsetY = -height() * 0.05;

        // ✅ ADIÇÃO: Sistema de background completo da versão antiga
        const bg_cidade_1 = add([sprite("background_cidade"), pos(0, bgOffsetY), scale(bgScale), z(0), "bg_cidade", opacity(1)]);
        const bg_cidade_2 = add([sprite("background_cidade"), pos(bgWidth, bgOffsetY), scale(bgScale), z(0), "bg_cidade", opacity(1)]);
        const bg_terra_1 = add([sprite("background_terra"), pos(0, bgOffsetY), scale(bgScale), z(0), "bg_terra", opacity(0)]);
        const bg_terra_2 = add([sprite("background_terra"), pos(bgWidth, bgOffsetY), scale(bgScale), z(0), "bg_terra", opacity(0)]);

        // Inicializar timer de transição
        backgroundSwitchTimer.current = rand(2, 4);

        const roadYPosition = height() * 0.48;
        const baseWidth = 600;
        const scaleFactor = (width() / baseWidth) * 0.3;

        const car = add([
          sprite("car", { anim: "run" }),
          pos(width() * 0.08, roadYPosition),
          area(),
          body(),
          z(2),
          scale(scaleFactor),
        ]);

        const lane_contramao = height() * 0.60;
        const lane_mesmo_sentido = height() * 0.68;
        const trafficCarSprites = ["carro_1", "carro_2", "carro_3", "carro_4", "carro_5", "carro_6", "carro_7", "carro_8", "moto_1"];

        loop(rand(4, 7), () => {
          if (gamePaused.current || get("traffic_car").length > 0) {
            return;
          }
          const carSprite = choose(trafficCarSprites);
          const carType = choose(["ultrapassagem", "contramao"]);

          if (carType === "contramao") {
            const startX = width() + 150;
            const carSpeed = speed * rand(0.2, 0.3);
            add([
              sprite(carSprite, { flipX: true }),
              pos(startX, lane_contramao),
              scale(scaleFactor * 1.6),
              move(LEFT, carSpeed),
              "traffic_car",
              z(1),
              { behavior: "contramao" },
            ]);
          } else {
            const startX = -250;
            const carSpeed = speed * rand(0.05, 0.1);
            add([
              sprite(carSprite, { flipX: false }),
              pos(startX, lane_contramao),
              scale(scaleFactor * 1.7),
              move(RIGHT, carSpeed),
              "traffic_car",
              z(1),
              { isChangingLane: false, behavior: "ultrapassagem" },
            ]);
          }
        });

        onUpdate("traffic_car", (trafficCar) => {
          if (trafficCar.behavior === "ultrapassagem" && !trafficCar.isChangingLane && trafficCar.pos.x > (car.pos.x + car.width - 150)) {
            trafficCar.isChangingLane = true;
            tween(
              trafficCar.pos.y,
              lane_mesmo_sentido,
              0.9,
              (newY) => (trafficCar.pos.y = newY),
              easings.easeInOutQuad
            );
          }
          if (trafficCar.pos.x < -trafficCar.width || trafficCar.pos.x > width() + trafficCar.width) {
            destroy(trafficCar);
          }
        });

        onUpdate(() => {
          // ✅ MANTÉM: Proteção de pausa da versão atual
          if (gamePaused.current) {
            return;
          }
          const deltaTime = dt();

          // ✅ MANTÉM: Sistema de cooldown da versão atual
          if (collisionCooldownRef.current > 0) {
            collisionCooldownRef.current = Math.max(0, collisionCooldownRef.current - deltaTime);
          }

          const moveAmount = -speed * deltaTime;

          // ✅ ADIÇÃO: Chamada para o sistema de background modular
          updateBackgroundSystem(k, deltaTime, moveAmount);

          // ✅ MANTÉM: Toda a lógica da versão atual
          const progressPercent = calculatePathProgress(deltaTime);
          const previousProgress = progressRef.current;
          progressRef.current = progressPercent;

          if (Math.abs(progressPercent - progress) > 0.05) {
            setProgress(progressPercent);
          }

          const routeDistance = totalDistance || 500;
          const progressDelta = progressPercent - previousProgress;
          const distanceInKm = (progressDelta / 100) * routeDistance;

          if (distanceInKm > 0) {
            // ✅ MELHORIA: Consumo dinâmico baseado no terreno
            const consumptionRate = (currentBg.current === 'cidade' ? vehicle.consumption?.asphalt : vehicle.consumption?.dirt) || 10;
            const fuelConsumption = distanceInKm / consumptionRate;
            const updatedFuel = Math.max(0, currentFuel - fuelConsumption);
            setCurrentFuel(updatedFuel);
            const newGasolinePercent = (updatedFuel / vehicle.maxCapacity) * 100;
            setGasoline(newGasolinePercent);
            if (currentFuel > 0 && updatedFuel <= 0) {
              requestAnimationFrame(() => {
                checkGameOver();
              });
            }
          }

          // ✅ MANTÉM: Sistema de eventos refinado da versão atual
          const EVENT_CHECK_INTERVAL_KM = 10;
          const distanciaAtualKm = (progressPercent / 100) * totalDistance;
          const canTriggerEvent = (
            activeGameIdRef.current &&
            !processingEvent.current &&
            !gamePaused.current &&
            !activeEvent &&
            !showPopup &&
            !fetchNextEventMutation.isPending &&
            distanciaAtualKm - lastEventCheckKm.current >= EVENT_CHECK_INTERVAL_KM
          );

          if (canTriggerEvent) {
            lastEventCheckKm.current = distanciaAtualKm;
            console.log(`🔍 Checkpoint em ${distanciaAtualKm.toFixed(2)}km. Perguntando ao backend por eventos...`);
            processingEvent.current = true;
            gamePaused.current = true;
            fetchNextEventMutation.mutate(distanciaAtualKm);
          }
        });
      });

      go("main");

      setCurrentPathIndex(0);
      currentPathIndexRef.current = 0;
      pathProgressRef.current = 0;
      progressRef.current = 0;
      setProgress(0);
      distanceTravelled.current = 0;

      obstacleTimerRef.current = 0;
      gamePaused.current = false;

      setGameLoaded(true);

      console.log("✅ Jogo inicializado com sucesso!");

    } catch (error) {
      console.error("Erro ao inicializar o jogo:", error);
      setLoadingError(`Erro ao carregar o jogo: ${error}`);
      setGameLoaded(false);
      (window as any).__kaboom_initiated__ = false;
    }
  };

  // ============= USEEFFECT PRINCIPAL =============

  useEffect(() => {
    if (gameInitialized.current) {
      return;
    }
    gameInitialized.current = true;

    console.log("🚀 Lógica de inicialização única está rodando...");

    const { selectedVehicle, selectedRoute: route, savedProgress } = location.state || {};

    if (!selectedVehicle || !route?.id || !route?.mapaId) {
      console.error("❌ Dados insuficientes para criar partida. Redirecionando...");
      alert("Erro: Dados do veículo ou rota incompletos.");
      navigate('/routes');
      return;
    }

    if (savedProgress && savedProgress.activeGameId) {
      console.log("🟢 Restaurando partida existente com ID:", savedProgress.activeGameId);
      setActiveGameId(savedProgress.activeGameId);
      activeGameIdRef.current = savedProgress.activeGameId;

      initializeGame(savedProgress);
      return;
    }

    createGameMutation.mutateAsync({
      mapa: route.mapaId,
      rota: route.id,
      veiculo: parseInt(selectedVehicle.id, 10) || 1
    }).then(() => {
      initializeGame(savedProgress);
    }).catch(error => {
      console.error("❌ Falha crítica na criação da partida, não inicializando Kaboom", error);
    });

    return () => {
      console.log("🧹 Limpando GameScene ao sair da página...");
      if ((window as any).__kaboom_initiated__) {
        const k = (window as any).k;
        if (k?.destroy) k.destroy();
        (window as any).__kaboom_initiated__ = false;
      }
      if (handleResizeRef.current) {
        window.removeEventListener('resize', handleResizeRef.current);
      }
    };
  }, []);

  // ============= LISTENERS DE EVENTOS =============

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Escape') {
        if (!activeEvent && !gameEnded) {
          togglePause();
        }
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => {
      window.removeEventListener('keydown', handleKeyDown);
    };
  }, [activeEvent, gameEnded]);

  // Inicializar estados
  useEffect(() => {
    const { savedProgress } = location.state || {};

    if (savedProgress) {
      console.log("📄 Restaurando progresso salvo...");
      setCurrentFuel(savedProgress.currentFuel);
      setProgress(savedProgress.progress);
      setCurrentPathIndex(savedProgress.currentPathIndex);
      setGameTime(Math.max(0, savedProgress.gameTime || 0));

      progressRef.current = savedProgress.progress;
      currentPathIndexRef.current = savedProgress.currentPathIndex;
      pathProgressRef.current = savedProgress.pathProgress;
    } else {
      console.log("✨ Iniciando um novo jogo...");
      setCurrentFuel(vehicle?.currentFuel || 0);
      setGameTime(0);
    }

    if (selectedRoute) {
      const routeDistance = selectedRoute.actualDistance || selectedRoute.distance;
      setTotalDistance(routeDistance);

      const estimatedHours = selectedRoute.estimatedTimeHours || 7.5;
      const targetGameDurationMinutes = 20;
      gameSpeedMultiplier.current = (estimatedHours * 60) / targetGameDurationMinutes;
    }
  }, [vehicle, selectedRoute, location.state]);

  const [gasoline, setGasoline] = useState(() => {
    const fuelPercent = (currentFuel / vehicle.maxCapacity) * 100;
    console.log("Inicializando gasoline com:", fuelPercent, "%");
    return fuelPercent;
  });

  // Validação de dados essenciais
  useEffect(() => {
    if (!vehicle || !vehicle.name || !vehicle.image) {
      console.error("ERRO: Dados do veículo incompletos!");
      console.log("Redirecionando para seleção de veículo...");
      setTimeout(() => {
        navigate('/select-vehicle');
      }, 1000);
    }
  }, []);

  // Sistema de ticks periódicos
  useEffect(() => {
    tickTimerRef.current = setInterval(() => {
      if (!gamePaused.current && !gameEnded && gameLoaded && activeGameIdRef.current) {
        const distanciaAtual = (progressRef.current / 100) * totalDistance;
        partidaTickMutation.mutate({ distancia_percorrida: distanciaAtual });
      }
    }, 2000);

    return () => {
      if (tickTimerRef.current) clearInterval(tickTimerRef.current);
    };
  }, [gameEnded, gameLoaded, totalDistance]);

  // ✅ SISTEMA DE TEMPO CORRIGIDO - ACELERA SEMPRE NO FRONTEND
  useEffect(() => {
    let animationFrameId: number;

    const animateClock = (now: number) => {
      if (!gamePaused.current && !gameEnded) {
        const deltaTime = (now - lastFrameTimeRef.current) / 1000;

        // ✅ TEMPO ACELERA CONSTANTEMENTE NO FRONTEND
        setGameTime(prevTime => prevTime + (deltaTime * FATOR_ACELERACAO_TEMPO));
      }
      lastFrameTimeRef.current = now;
      animationFrameId = requestAnimationFrame(animateClock);
    };

    animationFrameId = requestAnimationFrame(animateClock);
    return () => cancelAnimationFrame(animationFrameId);
  }, [gameEnded]);

  // Finalização do jogo
  useEffect(() => {
    if (progress >= 100 && !isFinishing.current) {
      isFinishing.current = true;

      console.log("🏁 Finalizando jogo - progresso 100% (CHAMADA ÚNICA)");

      const tempoFinal = Math.max(0, gameTime);
      console.log(`⏱️ Tempo enviado para sincronização: ${tempoFinal} segundos`);

      syncGameMutation.mutate({ tempo_decorrido_segundos: tempoFinal });
    }
  }, [progress, gameTime]);

  const checkGameOver = () => {
    if (!gameLoaded) {
      console.log("Game Over check skipped - jogo não carregado ainda");
      return false;
    }

    if (currentFuel <= 0) {
      console.log("Game Over: Combustível esgotado - currentFuel:", currentFuel);
      gamePaused.current = true;
      alert("Combustível esgotado! Jogo encerrado.");
      navigate('/routes');
      return true;
    }

    if (money <= 0) {
      console.log("Game Over: Sem recursos financeiros - money:", money);
      gamePaused.current = true;
      alert("Sem recursos financeiros! Jogo encerrado.");
      navigate('/routes');
      return true;
    }

    return false;
  };

  const formatTime = (totalSeconds: number) => {
    const totalSecondsInt = Math.floor(totalSeconds);
    const hours = Math.floor(totalSecondsInt / 3600);
    const minutes = Math.floor((totalSecondsInt % 3600) / 60);
    const secs = totalSecondsInt % 60;
    return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  };

  const handleMapModalToggle = () => {
    setShowMapModal(!showMapModal);
  };

  const calculatePathProgress = (deltaTime: number) => {
    if (!selectedRoute?.pathCoordinates || selectedRoute.pathCoordinates.length < 2) {
      console.log("Usando fallback - sem pathCoordinates");
      return calculateFallbackProgress(deltaTime);
    }

    const pathCoords = selectedRoute.pathCoordinates;
    const totalSegments = pathCoords.length - 1;

    const targetDurationSeconds = 1200;
    const segmentsPerSecond = totalSegments / targetDurationSeconds;
    const segmentSpeed = segmentsPerSecond * deltaTime;

    pathProgressRef.current += segmentSpeed;

    if (pathProgressRef.current >= 1.0 && currentPathIndexRef.current < totalSegments - 1) {
      currentPathIndexRef.current += 1;
      setCurrentPathIndex(currentPathIndexRef.current);
      pathProgressRef.current = 0;
    }

    const totalProgress = (currentPathIndexRef.current + pathProgressRef.current) / totalSegments;
    const progressPercent = Math.min(100, Math.max(0, totalProgress * 100));

    return progressPercent;
  };

  const calculateFallbackProgress = (deltaTime: number) => {
    const routeDistance = totalDistance || 500;
    distanceTravelled.current += deltaTime * gameSpeedMultiplier.current * 0.2;
    const progressKm = (distanceTravelled.current * routeDistance) / 5000;
    return Math.min(100, Math.max(0, (progressKm / routeDistance) * 100));
  };

  const getVehicleImageUrl = (vehicleImage: string) => {
    console.log("Convertendo imagem do veículo:", vehicleImage);

    if (vehicleImage.startsWith('/assets/')) {
      console.log("Já é uma URL pública:", vehicleImage);
      return vehicleImage;
    }

    if (vehicleImage.startsWith('/src/assets/')) {
      const fileName = vehicleImage.replace('/src/assets/', '');
      console.log("Nome do arquivo extraído de /src/assets/:", fileName);
      return `/assets/${fileName}`;
    }

    const fileName = vehicleImage.split('/').pop()?.split('?')[0];
    console.log("Nome do arquivo extraído da URL:", fileName);

    const imageMap: { [key: string]: string } = {
      'caminhao_medio.png': '/assets/caminhao_medio.png',
      'caminhao_pequeno.png': '/assets/caminhao_pequeno.png',
      'caminhonete.png': '/assets/caminhonete.png',
      'carreta.png': '/assets/carreta.png',
      'truck.png': '/assets/truck.png'
    };

    if (fileName && imageMap[fileName]) {
      console.log("URL encontrada no mapeamento:", imageMap[fileName]);
      return imageMap[fileName];
    }

    console.log("Usando fallback truck.png");
    return '/assets/truck.png';
  };

  useEffect(() => {
    if (gameEnded) {
      console.log("Jogo finalizado. Mostrando mensagem final.");
      localStorage.removeItem('savedGameProgress');
      setShowEndMessage(true);
    }
  }, [gameEnded]);

  // ============= RENDER DO COMPONENTE =============

  return (
    <div style={{ position: "relative" }}>

      {/* Indicador de carregamento */}
      {!gameLoaded && !loadingError && (
        <div style={{
          position: "fixed",
          top: "50%",
          left: "50%",
          transform: "translate(-50%, -50%)",
          zIndex: 2000,
          backgroundColor: "rgba(0, 0, 0, 0.8)",
          color: "white",
          padding: "20px",
          borderRadius: "10px",
          textAlign: "center",
          fontSize: "18px"
        }}>
          <div>🎮 Carregando jogo...</div>
          <div style={{ fontSize: "14px", marginTop: "10px" }}>
            Veículo: {vehicle.name}
          </div>
          {createGameMutation.isPending && (
            <div style={{ fontSize: "12px", marginTop: "5px", color: "#00ff00" }}>
              📄 Criando partida no servidor...
            </div>
          )}
        </div>
      )}

      {/* Indicador de erro */}
      {loadingError && (
        <div style={{
          position: "fixed",
          top: "50%",
          left: "50%",
          transform: "translate(-50%, -50%)",
          zIndex: 2000,
          backgroundColor: "rgba(220, 20, 60, 0.9)",
          color: "white",
          padding: "20px",
          borderRadius: "10px",
          textAlign: "center",
          fontSize: "16px"
        }}>
          <div>❌ Erro ao carregar o jogo</div>
          <div style={{ fontSize: "12px", marginTop: "10px" }}>
            {loadingError}
          </div>
          <button
            onClick={() => window.location.reload()}
            style={{
              marginTop: "15px",
              padding: "8px 16px",
              backgroundColor: "white",
              color: "red",
              border: "none",
              borderRadius: "5px",
              cursor: "pointer"
            }}
          >
            Recarregar
          </button>
        </div>
      )}

      {/* Botão de pausa e salvamento */}
      <div style={{
        position: "fixed",
        top: "2vh",
        left: "2vw",
        zIndex: 1000
      }}>
        <button
          onClick={handleSaveAndPause}
          style={{
            backgroundColor: "#E3922A",
            border: "2px solid #000",
            borderRadius: "8px",
            padding: "min(1.5vh, 10px)",
            cursor: "pointer",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            boxShadow: "2px 2px 4px rgba(0,0,0,0.3)",
            transition: "all 0.2s ease",
            width: "min(6vh, 50px)",
            height: "min(6vh, 50px)"
          }}
          title="Pausar e Salvar Progresso"
          onMouseOver={(e) => e.currentTarget.style.backgroundColor = "#FFC06F"}
          onMouseOut={(e) => e.currentTarget.style.backgroundColor = "#E3922A"}
        >
          <img
            src="src/assets/pausa.png"
            alt="Pausar"
            style={{
              width: 'min(3vh, 24px)',
              height: 'min(3vh, 24px)'
            }}
          />
        </button>
      </div>

      {/* Barra de progresso */}
      <div style={{
        position: "fixed",
        top: "2vh",
        left: "50%",
        transform: "translateX(-50%)",
        zIndex: 1000,
      }}>
        <PixelProgressBar progress={progress} />
      </div>

      {/* Container para minimapa e informações */}
      <div style={{
        position: "fixed",
        top: "2vh",
        right: "2vw",
        zIndex: 1000,
        display: "flex",
        flexDirection: "column",
        gap: "1vh",
        alignItems: "flex-end",
        fontFamily: "'Silkscreen', monospace"
      }}>
        {/* Minimapa */}
        {selectedRoute?.pathCoordinates && (
          <div
            style={{
              width: "min(12vw, 180px)",
              height: "min(12vw, 180px)",
              cursor: "pointer",
              transition: "transform 0.2s ease, box-shadow 0.2s ease",
              borderRadius: "50%",
              overflow: "hidden",
              fontFamily: "'Silkscreen', monospace"
            }}
            onClick={handleMapModalToggle}
            onMouseOver={(e) => {
              e.currentTarget.style.transform = "scale(1.05)";
              e.currentTarget.style.boxShadow = "0 4px 15px rgba(0,0,0,0.3)";
            }}
            onMouseOut={(e) => {
              e.currentTarget.style.transform = "scale(1)";
              e.currentTarget.style.boxShadow = "none";
            }}
            title="Clique para abrir o mapa completo"
          >
            <GameMiniMap
              pathCoordinates={selectedRoute.pathCoordinates}
              vehicle={vehicle}
              progress={progress}
              className="w-full h-full border-2 border-white rounded-full overflow-hidden"
            />
          </div>
        )}

        {/* Informações do jogo */}
        <div style={{
          padding: "min(2vh, 15px)",
          backgroundColor: "rgba(255, 255, 255, 0.9)",
          borderRadius: "12px",
          width: "min(18vw, 220px)",
          boxShadow: "0 2px 10px rgba(0,0,0,0.1)",
          fontSize: "min(2vw, 16px)",
          fontFamily: "'Silkscreen', monospace"
        }}>
          <div style={{ fontSize: "16px", marginBottom: "10px", color: "#333" }}>
            💰 <strong>R$ {money.toFixed(2)}</strong>
          </div>

          <div style={{ marginBottom: "10px" }}>
            <div style={{
              display: "flex",
              alignItems: "center",
              gap: "8px",
              marginBottom: "4px"
            }}>
              <span style={{ fontSize: "16px" }}>⛽</span>
              <div style={{
                height: "10px",
                width: "120px",
                backgroundColor: "#ddd",
                borderRadius: "5px",
                overflow: "hidden"
              }}>
                <div style={{
                  width: `${gasoline}%`,
                  height: "100%",
                  backgroundColor: gasoline > 30 ? "#00cc66" : gasoline > 15 ? "#ffaa00" : "#cc3300",
                  transition: "width 0.3s ease"
                }}></div>
              </div>
            </div>
            <div style={{ fontSize: "12px", color: "#666", paddingLeft: "24px" }}>
              {currentFuel.toFixed(1)}L / {vehicle.maxCapacity}L
            </div>
          </div>

          <div style={{ fontSize: "14px", color: "#333" }}>
            <div style={{ display: "flex", alignItems: "center", gap: "8px" }}>
              <span style={{ fontSize: "16px" }}>⏱️</span>
              <strong>{formatTime(gameTime)}</strong>
            </div>
          </div>

          {selectedRoute && (
            <div style={{ fontSize: "12px", color: "#666", marginTop: "8px", borderTop: "1px solid #eee", paddingTop: "8px" }}>
              <div>{selectedRoute.name}</div>
              <div>{selectedRoute.distance} km</div>
            </div>
          )}

          {/* Indicador de partida ativa */}
          {activeGameId && (
            <div style={{ fontSize: "10px", color: "#0077cc", marginTop: "5px", textAlign: "center" }}>
              🎮 Partida #{activeGameId}
            </div>
          )}
        </div>
      </div>

      <canvas
        ref={canvasRef}
        width={window.innerWidth}
        height={window.innerHeight}
        style={{
          display: "block",
          width: "100vw",
          height: "100vh",
          position: "fixed",
          top: 0,
          left: 0,
          zIndex: 1
        }}
      />

      {/* Modal de evento */}
      {showPopup && activeEvent && !gameEnded && (
        <div
          style={{
            position: "fixed",
            top: "50%",
            left: "50%",
            transform: "translate(-50%, -50%)",
            backgroundColor: "#f9f9f9",
            padding: "30px",
            borderRadius: "15px",
            boxShadow: "0 8px 25px rgba(0,0,0,0.2)",
            textAlign: "center",
            minWidth: "400px",
            maxWidth: "600px",
            zIndex: 2000,
            border: "3px solid #333",
            fontFamily: "'Silkscreen', monospace"
          }}
        >
          <div style={{
            backgroundColor: activeEvent.evento.categoria === 'perigo' ? '#ff4444' :
              activeEvent.evento.categoria === 'terreno' ? '#ff8800' : '#0077cc',
            color: 'white',
            padding: '5px 10px',
            borderRadius: '20px',
            fontSize: '12px',
            fontWeight: 'bold',
            marginBottom: '10px',
            display: 'inline-block'
          }}>
            {activeEvent.evento.categoria === 'perigo' ? '⚠️ ZONA DE PERIGO' :
              activeEvent.evento.categoria === 'terreno' ? '🌄 ESTRADA DE TERRA' : '🛣️ EVENTO GERAL'}
          </div>

          <div className="font-[Silkscreen]" style={{ marginBottom: "10px" }}>
            <p style={{
              fontSize: "28px",
              color: "#333",
              marginBottom: "5px",
              fontWeight: "bold"
            }}>
              {activeEvent.evento.nome}
            </p>
            <p style={{
              fontSize: "16px",
              color: "#555"
            }}>
              {activeEvent.evento.descricao}
            </p>
          </div>

          <div
            style={{
              display: "flex",
              justifyContent: "center",
              gap: "20px",
              flexWrap: "wrap",
              marginTop: "20px"
            }}
          >
            {activeEvent.evento.opcoes.map((opcao, index) => (
              <button
                key={opcao.id}
                onClick={() => handleOptionClick(opcao.id)}
                disabled={isResponding}
                style={{
                  padding: "15px 20px",
                  borderRadius: "10px",
                  border: "2px solid #fff",
                  backgroundColor: index % 2 === 0 ? "#0077cc" : "#e63946",
                  color: "white",
                  fontSize: "14px",
                  cursor: isResponding ? "not-allowed" : "pointer",
                  transition: "all 0.3s ease",
                  minWidth: "200px",
                  textAlign: "center",
                  lineHeight: "1.4",
                  boxShadow: "0 2px 4px rgba(0,0,0,0.2)",
                  opacity: isResponding ? 0.6 : 1
                }}
                onMouseOver={(e) => {
                  if (!isResponding) {
                    e.currentTarget.style.backgroundColor = index % 2 === 0 ? "#005fa3" : "#c92a2a";
                    e.currentTarget.style.transform = "scale(1.02)";
                    e.currentTarget.style.boxShadow = "0 4px 8px rgba(0,0,0,0.3)";
                  }
                }}
                onMouseOut={(e) => {
                  if (!isResponding) {
                    e.currentTarget.style.backgroundColor = index % 2 === 0 ? "#0077cc" : "#e63946";
                    e.currentTarget.style.transform = "scale(1)";
                    e.currentTarget.style.boxShadow = "0 2px 4px rgba(0,0,0,0.2)";
                  }
                }}
              >
                {isResponding && respondToEventMutation.isPending ? (
                  "⏳ Processando..."
                ) : (
                  opcao.descricao
                )}
              </button>
            ))}
          </div>

          {isResponding && (
            <div style={{
              marginTop: "15px",
              fontSize: "14px",
              color: "#666",
              fontStyle: "italic"
            }}>
              📄 Enviando sua escolha para o servidor...
            </div>
          )}
        </div>
      )}

      {/* Mensagem de fim de jogo */}
      {showEndMessage && finalGameResults && (
        <div
          className="endMessage"
          style={{
            position: 'fixed',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            backgroundColor: 'rgba(255, 255, 255, 0.98)',
            border: '3px solid #000',
            borderRadius: '15px',
            padding: '30px',
            textAlign: 'center',
            boxShadow: '0 8px 32px rgba(0,0,0,0.3)',
            zIndex: 2000,
            maxWidth: '500px',
            width: '90%'
          }}
        >
          <h2 style={{
            color: finalGameResults.resultado === 'vitoria' ? "#00cc66" : "#cc3300",
            marginBottom: "20px",
            fontFamily: "'Silkscreen', monospace"
          }}>
            {finalGameResults.resultado === 'vitoria' ? '🏁 Viagem Concluída! 🏁' : '❌ Fim de Jogo ❌'}
          </h2>

          <p style={{ fontSize: "16px", marginBottom: "25px", fontWeight: "bold" }}>
            {finalGameResults.motivo_finalizacao}
          </p>

          <div style={{
            backgroundColor: "#f8f9fa", padding: "20px", borderRadius: "10px",
            marginBottom: "25px", textAlign: "left", border: "2px solid #e9ecef"
          }}>
            <h3 style={{ margin: "0 0 15px 0", color: "#333", textAlign: "center", fontFamily: "'Silkscreen', monospace" }}>
              📊 Resultados Finais
            </h3>
            <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr", gap: "10px" }}>
              <div><strong>🎯 Eficiência:</strong><br /><span style={{ fontSize: "18px", color: "#0066cc" }}>{finalGameResults.eficiencia?.toFixed(1) || '0.0'}%</span></div>
              <div><strong>💯 Pontuação:</strong><br /><span style={{ fontSize: "18px", color: "#0066cc" }}>{finalGameResults.pontuacao} pts</span></div>
              <div><strong>💰 Saldo Final:</strong><br /><span style={{ fontSize: "16px" }}>R$ {finalGameResults.saldo.toFixed(2)}</span></div>
              <div><strong>📦 Carga:</strong><br /><span style={{ fontSize: "16px" }}>{finalGameResults.quantidade_carga} / {finalGameResults.quantidade_carga_inicial} un.</span></div>
            </div>
            <div style={{ marginTop: "15px", textAlign: "center" }}>
              <strong>⏱️ Tempo Total:</strong> {formatTime(finalGameResults.tempo_real * 60)}
            </div>
          </div>

          <div style={{ display: "flex", gap: "15px", justifyContent: "center", flexWrap: "wrap" }}>
            <button
              onClick={() => navigate('/ranking')}
              style={{
                padding: "12px 24px",
                backgroundColor: "#28a745",
                color: "white",
                border: "none",
                borderRadius: "8px",
                cursor: "pointer",
                fontSize: "14px",
                fontWeight: "bold"
              }}
            >
              🏆 Ver Ranking
            </button>
            <button
              onClick={() => navigate('/game-selection')}
              style={{
                padding: "12px 24px",
                backgroundColor: "#0077cc",
                color: "white",
                border: "none",
                borderRadius: "8px",
                cursor: "pointer",
                fontSize: "14px",
                fontWeight: "bold"
              }}
            >
              🚚 Nova Viagem
            </button>
            <button
              onClick={() => navigate('/perfil')}
              style={{
                padding: "12px 24px",
                backgroundColor: "#6c757d",
                color: "white",
                border: "none",
                borderRadius: "8px",
                cursor: "pointer",
                fontSize: "14px"
              }}
            >
              👤 Perfil
            </button>
          </div>
        </div>
      )}

      {/* Overlay de carregamento durante finalização */}
      {syncGameMutation.isPending && (
        <div style={{
          position: 'fixed',
          top: 0,
          left: 0,
          right: 0,
          bottom: 0,
          backgroundColor: 'rgba(0,0,0,0.5)',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          zIndex: 1999
        }}>
          <div style={{
            backgroundColor: 'white',
            padding: '20px',
            borderRadius: '10px',
            textAlign: 'center',
            border: '2px solid #000'
          }}>
            <div style={{ marginBottom: '10px', fontSize: '24px' }}>⏳</div>
            <p style={{ margin: 0, fontSize: '16px' }}>Finalizando partida...</p>
          </div>
        </div>
      )}

      {/* Modal do Mapa Completo */}
      {showMapModal && selectedRoute && (
        <div
          style={{
            position: "fixed",
            top: 0,
            left: 0,
            width: "100vw",
            height: "100vh",
            backgroundColor: "rgba(0, 0, 0, 0.8)",
            zIndex: 3000,
            display: "flex",
            justifyContent: "center",
            alignItems: "center",
            padding: "20px"
          }}
          onClick={handleMapModalToggle}
        >
          <div
            style={{
              width: "95%",
              height: "95%",
              backgroundColor: "white",
              borderRadius: "10px",
              overflow: "hidden",
              position: "relative",
              boxShadow: "0 10px 30px rgba(0,0,0,0.5)"
            }}
            onClick={(e) => e.stopPropagation()}
          >
            <div
              style={{
                position: 'absolute',
                top: 0,
                left: 0,
                width: '100%',
                padding: '15px',
                display: 'flex',
                justifyContent: 'space-between',
                alignItems: 'center',
                boxSizing: 'border-box',
                zIndex: 9999,
              }}
            >
              <div
                style={{
                  backgroundColor: 'rgba(0, 0, 0, 0.7)',
                  color: 'white',
                  padding: '10px 15px',
                  borderRadius: '5px',
                  fontFamily: '"Silkscreen", monospace',
                  fontSize: '16px',
                  fontWeight: 'bold',
                }}
              >
                🗺️ {selectedRoute.name}
              </div>
              <button
                onClick={handleMapModalToggle}
                style={{
                  backgroundColor: '#e63946',
                  color: 'white',
                  border: 'none',
                  borderRadius: '50%',
                  height: '45px',
                  width: '25px',
                  fontSize: '20px',
                  fontWeight: 'bold',
                  cursor: 'pointer',
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                  boxShadow: '0 2px 10px rgba(0,0,0,0.3)',
                  flexShrink: 0,
                  marginLeft: '15px',
                }}
                title="Fechar mapa"
              >
                ×
              </button>
            </div>

            <div style={{ width: "100%", height: "100%" }}>
              <MapComponent
                preSelectedRoute={selectedRoute}
                preSelectedVehicle={vehicle}
                preAvailableMoney={money}
                showControls={false}
                externalProgress={{
                  currentPathIndex: currentPathIndexRef.current,
                  pathProgress: pathProgressRef.current,
                  totalProgress: progress
                }}
              />
            </div>
          </div>
        </div>
      )}

      {/* Menu de pausa */}
      <PauseMenu
        isVisible={isPaused}
        onResume={togglePause}
        onRestart={handleRestart}
        onGoToProfile={handleGoToProfile}
      />
    </div>
  );
}
</file>

</files>
